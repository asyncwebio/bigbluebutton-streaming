{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": ["import { Vec } from '@tldraw/vec'\n\nexport type TLIntersection = {\n  didIntersect: boolean\n  message: string\n  points: number[][]\n}\n\nexport interface TLBounds {\n  minX: number\n  minY: number\n  maxX: number\n  maxY: number\n  width: number\n  height: number\n  rotation?: number\n}\n\n/**\n * Get an intersection.\n * @param message\n * @param points\n * @internal\n */\nfunction createIntersection(message: string, ...points: number[][]): TLIntersection {\n  const didIntersect = points.length > 0\n  return { didIntersect, message, points }\n}\n\n/**\n *\n * @param point\n * @param size\n * @param rotation\n * @internal\n */\nfunction getRectangleSides(point: number[], size: number[], rotation = 0): [string, number[][]][] {\n  const center = [point[0] + size[0] / 2, point[1] + size[1] / 2]\n  const tl = Vec.rotWith(point, center, rotation)\n  const tr = Vec.rotWith(Vec.add(point, [size[0], 0]), center, rotation)\n  const br = Vec.rotWith(Vec.add(point, size), center, rotation)\n  const bl = Vec.rotWith(Vec.add(point, [0, size[1]]), center, rotation)\n\n  return [\n    ['top', [tl, tr]],\n    ['right', [tr, br]],\n    ['bottom', [br, bl]],\n    ['left', [bl, tl]],\n  ]\n}\n\n/**\n * Get whether angle c lies between angles a and b.\n * @param a\n * @param b\n * @param c\n * @internal\n */\nfunction isAngleBetween(a: number, b: number, c: number): boolean {\n  if (c === a || c === b) return true\n  const PI2 = Math.PI * 2\n  const AB = (b - a + PI2) % PI2\n  const AC = (c - a + PI2) % PI2\n  return AB <= Math.PI !== AC > AB\n}\n\n/* -------------------------------------------------- */\n/*                        Line                        */\n/* -------------------------------------------------- */\n\nexport function intersectLineLine(AB: number[][], PQ: number[][]): number[] | undefined {\n  const slopeAB = Vec.slope(AB[0], AB[1])\n  const slopePQ = Vec.slope(PQ[0], PQ[1])\n\n  if (slopeAB === slopePQ) return undefined\n\n  if (Number.isNaN(slopeAB) && !Number.isNaN(slopePQ)) {\n    return [AB[0][0], (AB[0][0] - PQ[0][0]) * slopePQ + PQ[0][1]]\n  }\n\n  if (Number.isNaN(slopePQ) && !Number.isNaN(slopeAB)) {\n    return [PQ[0][0], (PQ[0][0] - AB[0][0]) * slopeAB + AB[0][1]]\n  }\n\n  const x = (slopeAB * AB[0][0] - slopePQ * PQ[0][0] + PQ[0][1] - AB[0][1]) / (slopeAB - slopePQ)\n  const y = slopePQ * (x - PQ[0][0]) + PQ[0][1]\n\n  return [x, y]\n}\n\n/* -------------------------------------------------- */\n/*                         Ray                        */\n/* -------------------------------------------------- */\n\n/**\n * Find the intersection between a ray and a ray.\n * @param p0 The first ray's point\n * @param n0 The first ray's direction vector.\n * @param p1 The second ray's point.\n * @param n1 The second ray's direction vector.\n */\nexport function intersectRayRay(\n  p0: number[],\n  n0: number[],\n  p1: number[],\n  n1: number[]\n): TLIntersection {\n  const dx = p1[0] - p0[0]\n  const dy = p1[1] - p0[1]\n  const det = n1[0] * n0[1] - n1[1] * n0[0]\n  const u = (dy * n1[0] - dx * n1[1]) / det\n  const v = (dy * n0[0] - dx * n0[1]) / det\n  if (u < 0 || v < 0) return createIntersection('miss')\n\n  const m0 = n0[1] / n0[0]\n  const m1 = n1[1] / n1[0]\n  const b0 = p0[1] - m0 * p0[0]\n  const b1 = p1[1] - m1 * p1[0]\n  const x = (b1 - b0) / (m0 - m1)\n  const y = m0 * x + b0\n\n  return Number.isFinite(x)\n    ? createIntersection('intersection', [x, y])\n    : createIntersection('parallel')\n}\n\n/**\n * Find the intersections between a ray and a line segment.\n * @param origin\n * @param direction\n * @param a1\n * @param a2\n */\nexport function intersectRayLineSegment(\n  origin: number[],\n  direction: number[],\n  a1: number[],\n  a2: number[]\n): TLIntersection {\n  const [x, y] = origin\n  const [dx, dy] = direction\n  const [x1, y1] = a1\n  const [x2, y2] = a2\n\n  if (dy / dx !== (y2 - y1) / (x2 - x1)) {\n    const d = dx * (y2 - y1) - dy * (x2 - x1)\n    if (d !== 0) {\n      const r = ((y - y1) * (x2 - x1) - (x - x1) * (y2 - y1)) / d\n      const s = ((y - y1) * dx - (x - x1) * dy) / d\n      if (r >= 0 && s >= 0 && s <= 1) {\n        return createIntersection('intersection', [x + r * dx, y + r * dy])\n      }\n    }\n  }\n  return createIntersection('no intersection')\n}\n\n/**\n * Find the intersections between a ray and a rectangle.\n * @param origin\n * @param direction\n * @param point\n * @param size\n * @param rotation\n */\nexport function intersectRayRectangle(\n  origin: number[],\n  direction: number[],\n  point: number[],\n  size: number[],\n  rotation = 0\n): TLIntersection[] {\n  return intersectRectangleRay(point, size, rotation, origin, direction)\n}\n\n/**\n * Find the intersections between a ray and an ellipse.\n * @param origin\n * @param direction\n * @param center\n * @param rx\n * @param ry\n * @param rotation\n */\nexport function intersectRayEllipse(\n  origin: number[],\n  direction: number[],\n  center: number[],\n  rx: number,\n  ry: number,\n  rotation: number\n): TLIntersection {\n  const a1 = origin\n  const a2 = Vec.mul(direction, 999999999)\n  return intersectLineSegmentEllipse(a1, a2, center, rx, ry, rotation)\n}\n\n/**\n * Find the intersections between a ray and a bounding box.\n * @param origin\n * @param direction\n * @param bounds\n * @param rotation\n */\nexport function intersectRayBounds(\n  origin: number[],\n  direction: number[],\n  bounds: TLBounds,\n  rotation = 0\n): TLIntersection[] {\n  const { minX, minY, width, height } = bounds\n  return intersectRayRectangle(origin, direction, [minX, minY], [width, height], rotation)\n}\n\n/* -------------------------------------------------- */\n/*                    Line Segment                    */\n/* -------------------------------------------------- */\n\n/**\n * Find the intersection between a line segment and a ray.\n * @param a1\n * @param a2\n * @param origin\n * @param direction\n */\nexport function intersectLineSegmentRay(\n  a1: number[],\n  a2: number[],\n  origin: number[],\n  direction: number[]\n): TLIntersection {\n  return intersectRayLineSegment(origin, direction, a1, a2)\n}\n\n/**\n * Find the intersection between a line segment and a line segment.\n * @param a1\n * @param a2\n * @param b1\n * @param b2\n */\nexport function intersectLineSegmentLineSegment(\n  a1: number[],\n  a2: number[],\n  b1: number[],\n  b2: number[]\n): TLIntersection {\n  const AB = Vec.sub(a1, b1)\n  const BV = Vec.sub(b2, b1)\n  const AV = Vec.sub(a2, a1)\n\n  const ua_t = BV[0] * AB[1] - BV[1] * AB[0]\n  const ub_t = AV[0] * AB[1] - AV[1] * AB[0]\n  const u_b = BV[1] * AV[0] - BV[0] * AV[1]\n\n  if (ua_t === 0 || ub_t === 0) {\n    return createIntersection('coincident')\n  }\n\n  if (u_b === 0) {\n    return createIntersection('parallel')\n  }\n\n  if (u_b !== 0) {\n    const ua = ua_t / u_b\n    const ub = ub_t / u_b\n    if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {\n      return createIntersection('intersection', Vec.add(a1, Vec.mul(AV, ua)))\n    }\n  }\n\n  return createIntersection('no intersection')\n}\n\n/**\n * Find the intersections between a line segment and a rectangle.\n * @param a1\n * @param a2\n * @param point\n * @param size\n */\nexport function intersectLineSegmentRectangle(\n  a1: number[],\n  a2: number[],\n  point: number[],\n  size: number[]\n): TLIntersection[] {\n  return intersectRectangleLineSegment(point, size, a1, a2)\n}\n\n/**\n * Find the intersections between a line segment and an arc.\n * @param a1\n * @param a2\n * @param center\n * @param radius\n * @param start\n * @param end\n */\nexport function intersectLineSegmentArc(\n  a1: number[],\n  a2: number[],\n  center: number[],\n  radius: number,\n  start: number[],\n  end: number[]\n): TLIntersection {\n  const sa = Vec.angle(center, start)\n  const ea = Vec.angle(center, end)\n  const ellipseTest = intersectEllipseLineSegment(center, radius, radius, 0, a1, a2)\n\n  if (!ellipseTest.didIntersect) return createIntersection('no intersection')\n\n  const points = ellipseTest.points.filter((point) =>\n    isAngleBetween(sa, ea, Vec.angle(center, point))\n  )\n\n  if (points.length === 0) {\n    return createIntersection('no intersection')\n  }\n\n  return createIntersection('intersection', ...points)\n}\n\n/**\n * Find the intersections between a line segment and a circle.\n * @param a1\n * @param a2\n * @param c\n * @param r\n */\nexport function intersectLineSegmentCircle(\n  a1: number[],\n  a2: number[],\n  c: number[],\n  r: number\n): TLIntersection {\n  const a = (a2[0] - a1[0]) * (a2[0] - a1[0]) + (a2[1] - a1[1]) * (a2[1] - a1[1])\n  const b = 2 * ((a2[0] - a1[0]) * (a1[0] - c[0]) + (a2[1] - a1[1]) * (a1[1] - c[1]))\n  const cc =\n    c[0] * c[0] +\n    c[1] * c[1] +\n    a1[0] * a1[0] +\n    a1[1] * a1[1] -\n    2 * (c[0] * a1[0] + c[1] * a1[1]) -\n    r * r\n\n  const deter = b * b - 4 * a * cc\n\n  if (deter < 0) {\n    return createIntersection('outside')\n  }\n\n  if (deter === 0) {\n    return createIntersection('tangent')\n  }\n\n  const e = Math.sqrt(deter)\n  const u1 = (-b + e) / (2 * a)\n  const u2 = (-b - e) / (2 * a)\n  if ((u1 < 0 || u1 > 1) && (u2 < 0 || u2 > 1)) {\n    if ((u1 < 0 && u2 < 0) || (u1 > 1 && u2 > 1)) {\n      return createIntersection('outside')\n    } else {\n      return createIntersection('inside')\n    }\n  }\n\n  const results: number[][] = []\n  if (0 <= u1 && u1 <= 1) results.push(Vec.lrp(a1, a2, u1))\n  if (0 <= u2 && u2 <= 1) results.push(Vec.lrp(a1, a2, u2))\n\n  return createIntersection('intersection', ...results)\n}\n\n/**\n * Find the intersections between a line segment and an ellipse.\n * @param a1\n * @param a2\n * @param center\n * @param rx\n * @param ry\n * @param rotation\n */\nexport function intersectLineSegmentEllipse(\n  a1: number[],\n  a2: number[],\n  center: number[],\n  rx: number,\n  ry: number,\n  rotation = 0\n): TLIntersection {\n  // If the ellipse or line segment are empty, return no tValues.\n  if (rx === 0 || ry === 0 || Vec.isEqual(a1, a2)) {\n    return createIntersection('no intersection')\n  }\n\n  // Get the semimajor and semiminor axes.\n  rx = rx < 0 ? rx : -rx\n  ry = ry < 0 ? ry : -ry\n\n  // Rotate points and translate so the ellipse is centered at the origin.\n  a1 = Vec.sub(Vec.rotWith(a1, center, -rotation), center)\n  a2 = Vec.sub(Vec.rotWith(a2, center, -rotation), center)\n\n  // Calculate the quadratic parameters.\n  const diff = Vec.sub(a2, a1)\n\n  const A = (diff[0] * diff[0]) / rx / rx + (diff[1] * diff[1]) / ry / ry\n  const B = (2 * a1[0] * diff[0]) / rx / rx + (2 * a1[1] * diff[1]) / ry / ry\n  const C = (a1[0] * a1[0]) / rx / rx + (a1[1] * a1[1]) / ry / ry - 1\n\n  // Make a list of t values (normalized points on the line where intersections occur).\n  const tValues: number[] = []\n\n  // Calculate the discriminant.\n  const discriminant = B * B - 4 * A * C\n\n  if (discriminant === 0) {\n    // One real solution.\n    tValues.push(-B / 2 / A)\n  } else if (discriminant > 0) {\n    const root = Math.sqrt(discriminant)\n    // Two real solutions.\n    tValues.push((-B + root) / 2 / A)\n    tValues.push((-B - root) / 2 / A)\n  }\n\n  // Filter to only points that are on the segment.\n  // Solve for points, then counter-rotate points.\n  const points = tValues\n    .filter((t) => t >= 0 && t <= 1)\n    .map((t) => Vec.add(center, Vec.add(a1, Vec.mul(Vec.sub(a2, a1), t))))\n    .map((p) => Vec.rotWith(p, center, rotation))\n\n  return createIntersection('intersection', ...points)\n}\n\n/**\n * Find the intersections between a line segment and a bounding box.\n * @param a1\n * @param a2\n * @param bounds\n */\nexport function intersectLineSegmentBounds(\n  a1: number[],\n  a2: number[],\n  bounds: TLBounds\n): TLIntersection[] {\n  return intersectBoundsLineSegment(bounds, a1, a2)\n}\n\n/**\n * Find the intersections between a line segment and a polyline.\n * @param a1\n * @param a2\n * @param points\n */\nexport function intersectLineSegmentPolyline(\n  a1: number[],\n  a2: number[],\n  points: number[][]\n): TLIntersection {\n  const pts: number[][] = []\n\n  for (let i = 1; i < points.length; i++) {\n    const int = intersectLineSegmentLineSegment(a1, a2, points[i - 1], points[i])\n\n    if (int) {\n      pts.push(...int.points)\n    }\n  }\n\n  if (pts.length === 0) {\n    return createIntersection('no intersection')\n  }\n\n  return createIntersection('intersection', ...points)\n}\n/**\n * Find the intersections between a line segment and a closed polygon.\n * @param a1\n * @param a2\n * @param points\n */\nexport function intersectLineSegmentPolygon(\n  a1: number[],\n  a2: number[],\n  points: number[][]\n): TLIntersection {\n  const pts: number[][] = []\n\n  for (let i = 1; i < points.length + 1; i++) {\n    const int = intersectLineSegmentLineSegment(a1, a2, points[i - 1], points[i % points.length])\n\n    if (int) {\n      pts.push(...int.points)\n    }\n  }\n\n  if (pts.length === 0) {\n    return createIntersection('no intersection')\n  }\n\n  return createIntersection('intersection', ...points)\n}\n\n/* -------------------------------------------------- */\n/*                      Rectangle                     */\n/* -------------------------------------------------- */\n\n/**\n * Find the intersections between a rectangle and a ray.\n * @param point\n * @param size\n * @param rotation\n * @param origin\n * @param direction\n */\nexport function intersectRectangleRay(\n  point: number[],\n  size: number[],\n  rotation: number,\n  origin: number[],\n  direction: number[]\n): TLIntersection[] {\n  const sideIntersections = getRectangleSides(point, size, rotation).reduce<TLIntersection[]>(\n    (acc, [message, [a1, a2]]) => {\n      const intersection = intersectRayLineSegment(origin, direction, a1, a2)\n\n      if (intersection) {\n        acc.push(createIntersection(message, ...intersection.points))\n      }\n\n      return acc\n    },\n    []\n  )\n\n  return sideIntersections.filter((int) => int.didIntersect)\n}\n\n/**\n * Find the intersections between a rectangle and a line segment.\n * @param point\n * @param size\n * @param a1\n * @param a2\n */\nexport function intersectRectangleLineSegment(\n  point: number[],\n  size: number[],\n  a1: number[],\n  a2: number[]\n): TLIntersection[] {\n  const sideIntersections = getRectangleSides(point, size).reduce<TLIntersection[]>(\n    (acc, [message, [b1, b2]]) => {\n      const intersection = intersectLineSegmentLineSegment(a1, a2, b1, b2)\n\n      if (intersection) {\n        acc.push(createIntersection(message, ...intersection.points))\n      }\n\n      return acc\n    },\n    []\n  )\n\n  return sideIntersections.filter((int) => int.didIntersect)\n}\n\n/**\n * Find the intersections between a rectangle and a rectangle.\n * @param point1\n * @param size1\n * @param point2\n * @param size2\n */\nexport function intersectRectangleRectangle(\n  point1: number[],\n  size1: number[],\n  point2: number[],\n  size2: number[]\n): TLIntersection[] {\n  const sideIntersections = getRectangleSides(point1, size1).reduce<TLIntersection[]>(\n    (acc, [message, [a1, a2]]) => {\n      const intersections = intersectRectangleLineSegment(point2, size2, a1, a2)\n\n      acc.push(\n        ...intersections.map((int) =>\n          createIntersection(`${message} ${int.message}`, ...int.points)\n        )\n      )\n\n      return acc\n    },\n    []\n  )\n\n  return sideIntersections.filter((int) => int.didIntersect)\n}\n\n/**\n * Find the intersections between a rectangle and an arc.\n * @param point\n * @param size\n * @param center\n * @param radius\n * @param start\n * @param end\n */\nexport function intersectRectangleArc(\n  point: number[],\n  size: number[],\n  center: number[],\n  radius: number,\n  start: number[],\n  end: number[]\n): TLIntersection[] {\n  const sideIntersections = getRectangleSides(point, size).reduce<TLIntersection[]>(\n    (acc, [message, [a1, a2]]) => {\n      const intersection = intersectArcLineSegment(center, radius, start, end, a1, a2)\n\n      if (intersection) {\n        acc.push({ ...intersection, message })\n      }\n\n      return acc\n    },\n    []\n  )\n\n  return sideIntersections.filter((int) => int.didIntersect)\n}\n\n/**\n * Find the intersections between a rectangle and a circle.\n * @param point\n * @param size\n * @param c\n * @param r\n */\nexport function intersectRectangleCircle(\n  point: number[],\n  size: number[],\n  c: number[],\n  r: number\n): TLIntersection[] {\n  const sideIntersections = getRectangleSides(point, size).reduce<TLIntersection[]>(\n    (acc, [message, [a1, a2]]) => {\n      const intersection = intersectLineSegmentCircle(a1, a2, c, r)\n\n      if (intersection) {\n        acc.push({ ...intersection, message })\n      }\n\n      return acc\n    },\n    []\n  )\n\n  return sideIntersections.filter((int) => int.didIntersect)\n}\n\n/**\n * Find the intersections between a rectangle and an ellipse.\n * @param point\n * @param size\n * @param c\n * @param rx\n * @param ry\n * @param rotation\n */\nexport function intersectRectangleEllipse(\n  point: number[],\n  size: number[],\n  c: number[],\n  rx: number,\n  ry: number,\n  rotation = 0\n): TLIntersection[] {\n  const sideIntersections = getRectangleSides(point, size).reduce<TLIntersection[]>(\n    (acc, [message, [a1, a2]]) => {\n      const intersection = intersectLineSegmentEllipse(a1, a2, c, rx, ry, rotation)\n\n      if (intersection) {\n        acc.push({ ...intersection, message })\n      }\n\n      return acc\n    },\n    []\n  )\n\n  return sideIntersections.filter((int) => int.didIntersect)\n}\n\n/**\n * Find the intersections between a rectangle and a bounding box.\n * @param point\n * @param size\n * @param bounds\n */\nexport function intersectRectangleBounds(\n  point: number[],\n  size: number[],\n  bounds: TLBounds\n): TLIntersection[] {\n  const { minX, minY, width, height } = bounds\n  return intersectRectangleRectangle(point, size, [minX, minY], [width, height])\n}\n\n/**\n * Find the intersections between a rectangle and a polyline.\n * @param point\n * @param size\n * @param points\n */\nexport function intersectRectanglePolyline(\n  point: number[],\n  size: number[],\n  points: number[][]\n): TLIntersection[] {\n  const sideIntersections = getRectangleSides(point, size).reduce<TLIntersection[]>(\n    (acc, [message, [a1, a2]]) => {\n      const intersection = intersectLineSegmentPolyline(a1, a2, points)\n\n      if (intersection.didIntersect) {\n        acc.push(createIntersection(message, ...intersection.points))\n      }\n\n      return acc\n    },\n    []\n  )\n\n  return sideIntersections.filter((int) => int.didIntersect)\n}\n/**\n * Find the intersections between a rectangle and a polygon.\n * @param point\n * @param size\n * @param points\n */\nexport function intersectRectanglePolygon(\n  point: number[],\n  size: number[],\n  points: number[][]\n): TLIntersection[] {\n  const sideIntersections = getRectangleSides(point, size).reduce<TLIntersection[]>(\n    (acc, [message, [a1, a2]]) => {\n      const intersection = intersectLineSegmentPolygon(a1, a2, points)\n\n      if (intersection.didIntersect) {\n        acc.push(createIntersection(message, ...intersection.points))\n      }\n\n      return acc\n    },\n    []\n  )\n\n  return sideIntersections.filter((int) => int.didIntersect)\n}\n\n/* -------------------------------------------------- */\n/*                         Arc                        */\n/* -------------------------------------------------- */\n\n/**\n * Find the intersections between a arc and a line segment.\n * @param center\n * @param radius\n * @param start\n * @param end\n * @param a1\n * @param a2\n */\nexport function intersectArcLineSegment(\n  center: number[],\n  radius: number,\n  start: number[],\n  end: number[],\n  a1: number[],\n  a2: number[]\n): TLIntersection {\n  return intersectLineSegmentArc(a1, a2, center, radius, start, end)\n}\n\n/**\n * Find the intersections between a arc and a rectangle.\n * @param center\n * @param radius\n * @param start\n * @param end\n * @param point\n * @param size\n */\nexport function intersectArcRectangle(\n  center: number[],\n  radius: number,\n  start: number[],\n  end: number[],\n  point: number[],\n  size: number[]\n): TLIntersection[] {\n  return intersectRectangleArc(point, size, center, radius, start, end)\n}\n\n/**\n * Find the intersections between a arc and a bounding box.\n * @param center\n * @param radius\n * @param start\n * @param end\n * @param bounds\n */\nexport function intersectArcBounds(\n  center: number[],\n  radius: number,\n  start: number[],\n  end: number[],\n  bounds: TLBounds\n): TLIntersection[] {\n  const { minX, minY, width, height } = bounds\n  return intersectArcRectangle(center, radius, start, end, [minX, minY], [width, height])\n}\n\n/* -------------------------------------------------- */\n/*                       Circle                       */\n/* -------------------------------------------------- */\n\n/**\n * Find the intersections between a circle and a line segment.\n * @param c\n * @param r\n * @param a1\n * @param a2\n */\nexport function intersectCircleLineSegment(\n  c: number[],\n  r: number,\n  a1: number[],\n  a2: number[]\n): TLIntersection {\n  return intersectLineSegmentCircle(a1, a2, c, r)\n}\n\n/**\n * Find the intersections between a circle and a circle.\n * @param c1\n * @param r1\n * @param c2\n * @param r2\n */\nexport function intersectCircleCircle(\n  c1: number[],\n  r1: number,\n  c2: number[],\n  r2: number\n): TLIntersection {\n  let dx = c2[0] - c1[0],\n    dy = c2[1] - c1[1]\n\n  const d = Math.sqrt(dx * dx + dy * dy),\n    x = (d * d - r2 * r2 + r1 * r1) / (2 * d),\n    y = Math.sqrt(r1 * r1 - x * x)\n\n  dx /= d\n  dy /= d\n\n  return createIntersection(\n    'intersection',\n    [c1[0] + dx * x - dy * y, c1[1] + dy * x + dx * y],\n    [c1[0] + dx * x + dy * y, c1[1] + dy * x - dx * y]\n  )\n}\n\n/**\n * Find the intersections between a circle and a rectangle.\n * @param c\n * @param r\n * @param point\n * @param size\n */\nexport function intersectCircleRectangle(\n  c: number[],\n  r: number,\n  point: number[],\n  size: number[]\n): TLIntersection[] {\n  return intersectRectangleCircle(point, size, c, r)\n}\n\n/**\n * Find the intersections between a circle and a bounding box.\n * @param c\n * @param r\n * @param bounds\n */\nexport function intersectCircleBounds(c: number[], r: number, bounds: TLBounds): TLIntersection[] {\n  const { minX, minY, width, height } = bounds\n  return intersectCircleRectangle(c, r, [minX, minY], [width, height])\n}\n\n/* -------------------------------------------------- */\n/*                       Ellipse                      */\n/* -------------------------------------------------- */\n\n/**\n * Find the intersections between an ellipse and a ray.\n * @param center\n * @param rx\n * @param ry\n * @param rotation\n * @param point\n * @param direction\n */\nexport function intersectEllipseRay(\n  center: number[],\n  rx: number,\n  ry: number,\n  rotation: number,\n  point: number[],\n  direction: number[]\n): TLIntersection {\n  return intersectRayEllipse(point, direction, center, rx, ry, rotation)\n}\n\n/**\n * Find the intersections between an ellipse and a line segment.\n * @param center\n * @param rx\n * @param ry\n * @param rotation\n * @param a1\n * @param a2\n */\nexport function intersectEllipseLineSegment(\n  center: number[],\n  rx: number,\n  ry: number,\n  rotation = 0,\n  a1: number[],\n  a2: number[]\n): TLIntersection {\n  if (rx === ry) {\n    return intersectLineSegmentCircle(a1, a2, center, rx)\n  }\n\n  return intersectLineSegmentEllipse(a1, a2, center, rx, ry, rotation)\n}\n\n/**\n * Find the intersections between an ellipse and a rectangle.\n * @param center\n * @param rx\n * @param ry\n * @param rotation\n * @param point\n * @param size\n */\nexport function intersectEllipseRectangle(\n  center: number[],\n  rx: number,\n  ry: number,\n  rotation = 0,\n  point: number[],\n  size: number[]\n): TLIntersection[] {\n  if (rx === ry) {\n    return intersectRectangleCircle(point, size, center, rx)\n  }\n\n  return intersectRectangleEllipse(point, size, center, rx, ry, rotation)\n}\n\n/**\n * Find the intersections between an ellipse and an ellipse.\n * Adapted from https://gist.github.com/drawable/92792f59b6ff8869d8b1\n * @param _c1\n * @param _rx1\n * @param _ry1\n * @param _r1\n * @param _c2\n * @param _rx2\n * @param _ry2\n * @param _r2\n */\nexport function intersectEllipseEllipse(\n  _c1: number[],\n  _rx1: number,\n  _ry1: number,\n  _r1: number,\n  _c2: number[],\n  _rx2: number,\n  _ry2: number,\n  _r2: number\n): TLIntersection {\n  // TODO\n  return createIntersection('no intersection')\n}\n\n/**\n * Find the intersections between an ellipse and a circle.\n * @param c\n * @param rx\n * @param ry\n * @param rotation\n * @param c2\n * @param r2\n */\nexport function intersectEllipseCircle(\n  c: number[],\n  rx: number,\n  ry: number,\n  rotation: number,\n  c2: number[],\n  r2: number\n): TLIntersection {\n  return intersectEllipseEllipse(c, rx, ry, rotation, c2, r2, r2, 0)\n}\n\n/**\n * Find the intersections between an ellipse and a bounding box.\n * @param c\n * @param rx\n * @param ry\n * @param rotation\n * @param bounds\n */\nexport function intersectEllipseBounds(\n  c: number[],\n  rx: number,\n  ry: number,\n  rotation: number,\n  bounds: TLBounds\n): TLIntersection[] {\n  const { minX, minY, width, height } = bounds\n  return intersectEllipseRectangle(c, rx, ry, rotation, [minX, minY], [width, height])\n}\n\n/**\n * Find the intersections between a bounding box and a ray.\n * @param bounds\n * @param origin\n * @param direction\n */\nexport function intersectBoundsRay(\n  bounds: TLBounds,\n  origin: number[],\n  direction: number[]\n): TLIntersection[] {\n  const { minX, minY, width, height } = bounds\n  return intersectRayRectangle(origin, direction, [minX, minY], [width, height])\n}\n\n/**\n * Find the intersections between a bounding box and a line segment.\n * @param bounds\n * @param a1\n * @param a2\n */\nexport function intersectBoundsLineSegment(\n  bounds: TLBounds,\n  a1: number[],\n  a2: number[]\n): TLIntersection[] {\n  const { minX, minY, width, height } = bounds\n  return intersectLineSegmentRectangle(a1, a2, [minX, minY], [width, height])\n}\n\n/**\n * Find the intersections between a bounding box and a rectangle.\n * @param bounds\n * @param point\n * @param size\n */\nexport function intersectBoundsRectangle(\n  bounds: TLBounds,\n  point: number[],\n  size: number[]\n): TLIntersection[] {\n  const { minX, minY, width, height } = bounds\n  return intersectRectangleRectangle(point, size, [minX, minY], [width, height])\n}\n\n/**\n * Find the intersections between a bounding box and a bounding box.\n * @param bounds1\n * @param bounds2\n */\nexport function intersectBoundsBounds(bounds1: TLBounds, bounds2: TLBounds): TLIntersection[] {\n  return intersectRectangleRectangle(\n    [bounds1.minX, bounds1.minY],\n    [bounds1.width, bounds1.height],\n    [bounds2.minX, bounds2.minY],\n    [bounds2.width, bounds2.height]\n  )\n}\n\n/**\n * Find the intersections between a bounding box and an arc.\n * @param bounds\n * @param center\n * @param radius\n * @param start\n * @param end\n */\nexport function intersectBoundsArc(\n  bounds: TLBounds,\n  center: number[],\n  radius: number,\n  start: number[],\n  end: number[]\n): TLIntersection[] {\n  const { minX, minY, width, height } = bounds\n  return intersectArcRectangle(center, radius, start, end, [minX, minY], [width, height])\n}\n\n/**\n * Find the intersections between a bounding box and a circle.\n * @param bounds\n * @param c\n * @param r\n */\nexport function intersectBoundsCircle(bounds: TLBounds, c: number[], r: number): TLIntersection[] {\n  const { minX, minY, width, height } = bounds\n  return intersectCircleRectangle(c, r, [minX, minY], [width, height])\n}\n\n/**\n * Find the intersections between a bounding box and an ellipse.\n * @param bounds\n * @param c\n * @param rx\n * @param ry\n * @param rotation\n */\nexport function intersectBoundsEllipse(\n  bounds: TLBounds,\n  c: number[],\n  rx: number,\n  ry: number,\n  rotation = 0\n): TLIntersection[] {\n  const { minX, minY, width, height } = bounds\n  return intersectEllipseRectangle(c, rx, ry, rotation, [minX, minY], [width, height])\n}\n\n/**\n * Find the intersections between a bounding box and a polyline.\n * @param bounds\n * @param points\n */\nexport function intersectBoundsPolyline(bounds: TLBounds, points: number[][]): TLIntersection[] {\n  return intersectPolylineBounds(points, bounds)\n}\n\n/**\n * Find the intersections between a bounding box and a polygon.\n * @param bounds\n * @param points\n */\nexport function intersectBoundsPolygon(bounds: TLBounds, points: number[][]): TLIntersection[] {\n  return intersectPolygonBounds(points, bounds)\n}\n\n/* -------------------------------------------------- */\n/*                      Polyline                      */\n/* -------------------------------------------------- */\n\n/**\n * Find the intersections between a polyline and a line segment.\n * @param points\n * @param a1\n * @param a2\n */\nexport function intersectPolylineLineSegment(\n  points: number[][],\n  a1: number[],\n  a2: number[]\n): TLIntersection {\n  return intersectLineSegmentPolyline(a1, a2, points)\n}\n\n/**\n * Find the intersections between a polyline and a rectangle.\n * @param points\n * @param point\n * @param size\n */\nexport function intersectPolylineRectangle(\n  points: number[][],\n  point: number[],\n  size: number[]\n): TLIntersection[] {\n  return intersectRectanglePolyline(point, size, points)\n}\n\n/**\n * Find the intersections between a polyline and a bounding box.\n * @param points\n * @param bounds\n */\nexport function intersectPolylineBounds(points: number[][], bounds: TLBounds): TLIntersection[] {\n  return intersectRectanglePolyline(\n    [bounds.minX, bounds.minY],\n    [bounds.width, bounds.height],\n    points\n  )\n}\n\n/* -------------------------------------------------- */\n/*                       Polygon                      */\n/* -------------------------------------------------- */\n\n/**\n * Find the intersections between a polygon nd a line segment.\n * @param points\n * @param a1\n * @param a2\n */\nexport function intersectPolygonLineSegment(\n  points: number[][],\n  a1: number[],\n  a2: number[]\n): TLIntersection {\n  return intersectLineSegmentPolyline(a1, a2, points)\n}\n\n/**\n * Find the intersections between a polygon and a rectangle.\n * @param points\n * @param point\n * @param size\n */\nexport function intersectPolygonRectangle(\n  points: number[][],\n  point: number[],\n  size: number[]\n): TLIntersection[] {\n  return intersectRectanglePolyline(point, size, points)\n}\n\n/**\n * Find the intersections between a polygon and a bounding box.\n * @param points\n * @param bounds\n */\nexport function intersectPolygonBounds(points: number[][], bounds: TLBounds): TLIntersection[] {\n  return intersectRectanglePolygon(\n    [bounds.minX, bounds.minY],\n    [bounds.width, bounds.height],\n    points\n  )\n}\n\n/**\n * Find the intersections between a rectangle and a ray.\n * @param point\n * @param size\n * @param rotation\n * @param origin\n * @param direction\n */\nexport function intersectRayPolygon(\n  origin: number[],\n  direction: number[],\n  points: number[][]\n): TLIntersection[] {\n  const sideIntersections = pointsToLineSegments(points, true).reduce<TLIntersection[]>(\n    (acc, [a1, a2], i) => {\n      const intersection = intersectRayLineSegment(origin, direction, a1, a2)\n\n      if (intersection) {\n        acc.push(createIntersection(i.toString(), ...intersection.points))\n      }\n\n      return acc\n    },\n    []\n  )\n\n  return sideIntersections.filter((int) => int.didIntersect)\n}\n\nexport function pointsToLineSegments(points: number[][], closed = false) {\n  const segments = []\n  for (let i = 1; i < points.length; i++) segments.push([points[i - 1], points[i]])\n  if (closed) segments.push([points[points.length - 1], points[0]])\n  return segments\n}\n"],
  "mappings": "i3BAAA,ipDAAoB,uBAwBpB,WAA4B,KAAoB,EAAoC,CAElF,MAAO,CAAE,aADY,EAAO,OAAS,EACd,UAAS,UAUlC,WAA2B,EAAiB,EAAgB,EAAW,EAA2B,CAChG,GAAM,GAAS,CAAC,EAAM,GAAK,EAAK,GAAK,EAAG,EAAM,GAAK,EAAK,GAAK,GACvD,EAAK,MAAI,QAAQ,EAAO,EAAQ,GAChC,EAAK,MAAI,QAAQ,MAAI,IAAI,EAAO,CAAC,EAAK,GAAI,IAAK,EAAQ,GACvD,EAAK,MAAI,QAAQ,MAAI,IAAI,EAAO,GAAO,EAAQ,GAC/C,EAAK,MAAI,QAAQ,MAAI,IAAI,EAAO,CAAC,EAAG,EAAK,KAAM,EAAQ,GAE7D,MAAO,CACL,CAAC,MAAO,CAAC,EAAI,IACb,CAAC,QAAS,CAAC,EAAI,IACf,CAAC,SAAU,CAAC,EAAI,IAChB,CAAC,OAAQ,CAAC,EAAI,KAWlB,YAAwB,EAAW,EAAW,EAAoB,CAChE,GAAI,IAAM,GAAK,IAAM,EAAG,MAAO,GAC/B,GAAM,GAAM,KAAK,GAAK,EAChB,EAAM,GAAI,EAAI,GAAO,EACrB,EAAM,GAAI,EAAI,GAAO,EAC3B,MAAO,IAAM,KAAK,IAAO,EAAK,EAOzB,YAA2B,EAAgB,EAAsC,CACtF,GAAM,GAAU,MAAI,MAAM,EAAG,GAAI,EAAG,IAC9B,EAAU,MAAI,MAAM,EAAG,GAAI,EAAG,IAEpC,GAAI,IAAY,EAAS,OAEzB,GAAI,OAAO,MAAM,IAAY,CAAC,OAAO,MAAM,GACzC,MAAO,CAAC,EAAG,GAAG,GAAK,GAAG,GAAG,GAAK,EAAG,GAAG,IAAM,EAAU,EAAG,GAAG,IAG5D,GAAI,OAAO,MAAM,IAAY,CAAC,OAAO,MAAM,GACzC,MAAO,CAAC,EAAG,GAAG,GAAK,GAAG,GAAG,GAAK,EAAG,GAAG,IAAM,EAAU,EAAG,GAAG,IAG5D,GAAM,GAAK,GAAU,EAAG,GAAG,GAAK,EAAU,EAAG,GAAG,GAAK,EAAG,GAAG,GAAK,EAAG,GAAG,IAAO,GAAU,GACjF,EAAI,EAAW,GAAI,EAAG,GAAG,IAAM,EAAG,GAAG,GAE3C,MAAO,CAAC,EAAG,GAcN,YACL,EACA,EACA,EACA,EACgB,CAChB,GAAM,GAAK,EAAG,GAAK,EAAG,GAChB,EAAK,EAAG,GAAK,EAAG,GAChB,EAAM,EAAG,GAAK,EAAG,GAAK,EAAG,GAAK,EAAG,GACjC,EAAK,GAAK,EAAG,GAAK,EAAK,EAAG,IAAM,EAChC,EAAK,GAAK,EAAG,GAAK,EAAK,EAAG,IAAM,EACtC,GAAI,EAAI,GAAK,EAAI,EAAG,MAAO,GAAmB,QAE9C,GAAM,GAAK,EAAG,GAAK,EAAG,GAChB,EAAK,EAAG,GAAK,EAAG,GAChB,EAAK,EAAG,GAAK,EAAK,EAAG,GAErB,EAAK,CADA,EAAG,GAAK,EAAK,EAAG,GACX,GAAO,GAAK,GACtB,EAAI,EAAK,EAAI,EAEnB,MAAO,QAAO,SAAS,GACnB,EAAmB,eAAgB,CAAC,EAAG,IACvC,EAAmB,YAUlB,WACL,EACA,EACA,EACA,EACgB,CAChB,GAAM,CAAC,EAAG,GAAK,EACT,CAAC,EAAI,GAAM,EACX,CAAC,EAAI,GAAM,EACX,CAAC,EAAI,GAAM,EAEjB,GAAI,EAAK,IAAQ,GAAK,GAAO,GAAK,GAAK,CACrC,GAAM,GAAI,EAAM,GAAK,GAAM,EAAM,GAAK,GACtC,GAAI,IAAM,EAAG,CACX,GAAM,GAAM,IAAI,GAAO,GAAK,GAAO,GAAI,GAAO,GAAK,IAAO,EACpD,EAAM,IAAI,GAAM,EAAM,GAAI,GAAM,GAAM,EAC5C,GAAI,GAAK,GAAK,GAAK,GAAK,GAAK,EAC3B,MAAO,GAAmB,eAAgB,CAAC,EAAI,EAAI,EAAI,EAAI,EAAI,KAIrE,MAAO,GAAmB,mBAWrB,WACL,EACA,EACA,EACA,EACA,EAAW,EACO,CAClB,MAAO,GAAsB,EAAO,EAAM,EAAU,EAAQ,GAYvD,WACL,EACA,EACA,EACA,EACA,EACA,EACgB,CAChB,GAAM,GAAK,EACL,EAAK,MAAI,IAAI,EAAW,WAC9B,MAAO,GAA4B,EAAI,EAAI,EAAQ,EAAI,EAAI,GAUtD,YACL,EACA,EACA,EACA,EAAW,EACO,CAClB,GAAM,CAAE,OAAM,OAAM,QAAO,UAAW,EACtC,MAAO,GAAsB,EAAQ,EAAW,CAAC,EAAM,GAAO,CAAC,EAAO,GAAS,GAc1E,YACL,EACA,EACA,EACA,EACgB,CAChB,MAAO,GAAwB,EAAQ,EAAW,EAAI,GAUjD,WACL,EACA,EACA,EACA,EACgB,CAChB,GAAM,GAAK,MAAI,IAAI,EAAI,GACjB,EAAK,MAAI,IAAI,EAAI,GACjB,EAAK,MAAI,IAAI,EAAI,GAEjB,EAAO,EAAG,GAAK,EAAG,GAAK,EAAG,GAAK,EAAG,GAClC,EAAO,EAAG,GAAK,EAAG,GAAK,EAAG,GAAK,EAAG,GAClC,EAAM,EAAG,GAAK,EAAG,GAAK,EAAG,GAAK,EAAG,GAEvC,GAAI,IAAS,GAAK,IAAS,EACzB,MAAO,GAAmB,cAG5B,GAAI,IAAQ,EACV,MAAO,GAAmB,YAG5B,GAAI,IAAQ,EAAG,CACb,GAAM,GAAK,EAAO,EACZ,EAAK,EAAO,EAClB,GAAI,GAAK,GAAM,GAAM,GAAK,GAAK,GAAM,GAAM,EACzC,MAAO,GAAmB,eAAgB,MAAI,IAAI,EAAI,MAAI,IAAI,EAAI,KAItE,MAAO,GAAmB,mBAUrB,WACL,EACA,EACA,EACA,EACkB,CAClB,MAAO,GAA8B,EAAO,EAAM,EAAI,GAYjD,WACL,EACA,EACA,EACA,EACA,EACA,EACgB,CAChB,GAAM,GAAK,MAAI,MAAM,EAAQ,GACvB,EAAK,MAAI,MAAM,EAAQ,GACvB,EAAc,EAA4B,EAAQ,EAAQ,EAAQ,EAAG,EAAI,GAE/E,GAAI,CAAC,EAAY,aAAc,MAAO,GAAmB,mBAEzD,GAAM,GAAS,EAAY,OAAO,OAAO,AAAC,GACxC,GAAe,EAAI,EAAI,MAAI,MAAM,EAAQ,KAG3C,MAAI,GAAO,SAAW,EACb,EAAmB,mBAGrB,EAAmB,eAAgB,GAAG,GAUxC,WACL,EACA,EACA,EACA,EACgB,CAChB,GAAM,GAAK,GAAG,GAAK,EAAG,IAAO,GAAG,GAAK,EAAG,IAAO,GAAG,GAAK,EAAG,IAAO,GAAG,GAAK,EAAG,IACtE,EAAI,EAAM,IAAG,GAAK,EAAG,IAAO,GAAG,GAAK,EAAE,IAAO,GAAG,GAAK,EAAG,IAAO,GAAG,GAAK,EAAE,KACzE,EACJ,EAAE,GAAK,EAAE,GACT,EAAE,GAAK,EAAE,GACT,EAAG,GAAK,EAAG,GACX,EAAG,GAAK,EAAG,GACX,EAAK,GAAE,GAAK,EAAG,GAAK,EAAE,GAAK,EAAG,IAC9B,EAAI,EAEA,EAAQ,EAAI,EAAI,EAAI,EAAI,EAE9B,GAAI,EAAQ,EACV,MAAO,GAAmB,WAG5B,GAAI,IAAU,EACZ,MAAO,GAAmB,WAG5B,GAAM,GAAI,KAAK,KAAK,GACd,EAAM,EAAC,EAAI,GAAM,GAAI,GACrB,EAAM,EAAC,EAAI,GAAM,GAAI,GAC3B,GAAK,GAAK,GAAK,EAAK,IAAO,GAAK,GAAK,EAAK,GACxC,MAAK,GAAK,GAAK,EAAK,GAAO,EAAK,GAAK,EAAK,EACjC,EAAmB,WAEnB,EAAmB,UAI9B,GAAM,GAAsB,GAC5B,MAAI,IAAK,GAAM,GAAM,GAAG,EAAQ,KAAK,MAAI,IAAI,EAAI,EAAI,IACjD,GAAK,GAAM,GAAM,GAAG,EAAQ,KAAK,MAAI,IAAI,EAAI,EAAI,IAE9C,EAAmB,eAAgB,GAAG,GAYxC,WACL,EACA,EACA,EACA,EACA,EACA,EAAW,EACK,CAEhB,GAAI,IAAO,GAAK,IAAO,GAAK,MAAI,QAAQ,EAAI,GAC1C,MAAO,GAAmB,mBAI5B,EAAK,EAAK,EAAI,EAAK,CAAC,EACpB,EAAK,EAAK,EAAI,EAAK,CAAC,EAGpB,EAAK,MAAI,IAAI,MAAI,QAAQ,EAAI,EAAQ,CAAC,GAAW,GACjD,EAAK,MAAI,IAAI,MAAI,QAAQ,EAAI,EAAQ,CAAC,GAAW,GAGjD,GAAM,GAAO,MAAI,IAAI,EAAI,GAEnB,EAAK,EAAK,GAAK,EAAK,GAAM,EAAK,EAAM,EAAK,GAAK,EAAK,GAAM,EAAK,EAC/D,EAAK,EAAI,EAAG,GAAK,EAAK,GAAM,EAAK,EAAM,EAAI,EAAG,GAAK,EAAK,GAAM,EAAK,EACnE,EAAK,EAAG,GAAK,EAAG,GAAM,EAAK,EAAM,EAAG,GAAK,EAAG,GAAM,EAAK,EAAK,EAG5D,EAAoB,GAGpB,EAAe,EAAI,EAAI,EAAI,EAAI,EAErC,GAAI,IAAiB,EAEnB,EAAQ,KAAK,CAAC,EAAI,EAAI,WACb,EAAe,EAAG,CAC3B,GAAM,GAAO,KAAK,KAAK,GAEvB,EAAQ,KAAM,EAAC,EAAI,GAAQ,EAAI,GAC/B,EAAQ,KAAM,EAAC,EAAI,GAAQ,EAAI,GAKjC,GAAM,GAAS,EACZ,OAAO,AAAC,GAAM,GAAK,GAAK,GAAK,GAC7B,IAAI,AAAC,GAAM,MAAI,IAAI,EAAQ,MAAI,IAAI,EAAI,MAAI,IAAI,MAAI,IAAI,EAAI,GAAK,MAChE,IAAI,AAAC,GAAM,MAAI,QAAQ,EAAG,EAAQ,IAErC,MAAO,GAAmB,eAAgB,GAAG,GASxC,YACL,EACA,EACA,EACkB,CAClB,MAAO,GAA2B,EAAQ,EAAI,GASzC,WACL,EACA,EACA,EACgB,CAChB,GAAM,GAAkB,GAExB,OAAS,GAAI,EAAG,EAAI,EAAO,OAAQ,IAAK,CACtC,GAAM,GAAM,EAAgC,EAAI,EAAI,EAAO,EAAI,GAAI,EAAO,IAE1E,AAAI,GACF,EAAI,KAAK,GAAG,EAAI,QAIpB,MAAI,GAAI,SAAW,EACV,EAAmB,mBAGrB,EAAmB,eAAgB,GAAG,GAQxC,WACL,EACA,EACA,EACgB,CAChB,GAAM,GAAkB,GAExB,OAAS,GAAI,EAAG,EAAI,EAAO,OAAS,EAAG,IAAK,CAC1C,GAAM,GAAM,EAAgC,EAAI,EAAI,EAAO,EAAI,GAAI,EAAO,EAAI,EAAO,SAErF,AAAI,GACF,EAAI,KAAK,GAAG,EAAI,QAIpB,MAAI,GAAI,SAAW,EACV,EAAmB,mBAGrB,EAAmB,eAAgB,GAAG,GAexC,WACL,EACA,EACA,EACA,EACA,EACkB,CAclB,MAAO,AAbmB,GAAkB,EAAO,EAAM,GAAU,OACjE,CAAC,EAAK,CAAC,EAAS,CAAC,EAAI,MAAS,CAC5B,GAAM,GAAe,EAAwB,EAAQ,EAAW,EAAI,GAEpE,MAAI,IACF,EAAI,KAAK,EAAmB,EAAS,GAAG,EAAa,SAGhD,GAET,IAGuB,OAAO,AAAC,GAAQ,EAAI,cAUxC,WACL,EACA,EACA,EACA,EACkB,CAclB,MAAO,AAbmB,GAAkB,EAAO,GAAM,OACvD,CAAC,EAAK,CAAC,EAAS,CAAC,EAAI,MAAS,CAC5B,GAAM,GAAe,EAAgC,EAAI,EAAI,EAAI,GAEjE,MAAI,IACF,EAAI,KAAK,EAAmB,EAAS,GAAG,EAAa,SAGhD,GAET,IAGuB,OAAO,AAAC,GAAQ,EAAI,cAUxC,WACL,EACA,EACA,EACA,EACkB,CAgBlB,MAAO,AAfmB,GAAkB,EAAQ,GAAO,OACzD,CAAC,EAAK,CAAC,EAAS,CAAC,EAAI,MAAS,CAC5B,GAAM,GAAgB,EAA8B,EAAQ,EAAO,EAAI,GAEvE,SAAI,KACF,GAAG,EAAc,IAAI,AAAC,GACpB,EAAmB,GAAG,KAAW,EAAI,UAAW,GAAG,EAAI,UAIpD,GAET,IAGuB,OAAO,AAAC,GAAQ,EAAI,cAYxC,WACL,EACA,EACA,EACA,EACA,EACA,EACkB,CAclB,MAAO,AAbmB,GAAkB,EAAO,GAAM,OACvD,CAAC,EAAK,CAAC,EAAS,CAAC,EAAI,MAAS,CAC5B,GAAM,GAAe,EAAwB,EAAQ,EAAQ,EAAO,EAAK,EAAI,GAE7E,MAAI,IACF,EAAI,KAAK,OAAK,GAAL,CAAmB,aAGvB,GAET,IAGuB,OAAO,AAAC,GAAQ,EAAI,cAUxC,WACL,EACA,EACA,EACA,EACkB,CAclB,MAAO,AAbmB,GAAkB,EAAO,GAAM,OACvD,CAAC,EAAK,CAAC,EAAS,CAAC,EAAI,MAAS,CAC5B,GAAM,GAAe,EAA2B,EAAI,EAAI,EAAG,GAE3D,MAAI,IACF,EAAI,KAAK,OAAK,GAAL,CAAmB,aAGvB,GAET,IAGuB,OAAO,AAAC,GAAQ,EAAI,cAYxC,WACL,EACA,EACA,EACA,EACA,EACA,EAAW,EACO,CAclB,MAAO,AAbmB,GAAkB,EAAO,GAAM,OACvD,CAAC,EAAK,CAAC,EAAS,CAAC,EAAI,MAAS,CAC5B,GAAM,GAAe,EAA4B,EAAI,EAAI,EAAG,EAAI,EAAI,GAEpE,MAAI,IACF,EAAI,KAAK,OAAK,GAAL,CAAmB,aAGvB,GAET,IAGuB,OAAO,AAAC,GAAQ,EAAI,cASxC,YACL,EACA,EACA,EACkB,CAClB,GAAM,CAAE,OAAM,OAAM,QAAO,UAAW,EACtC,MAAO,GAA4B,EAAO,EAAM,CAAC,EAAM,GAAO,CAAC,EAAO,IASjE,WACL,EACA,EACA,EACkB,CAclB,MAAO,AAbmB,GAAkB,EAAO,GAAM,OACvD,CAAC,EAAK,CAAC,EAAS,CAAC,EAAI,MAAS,CAC5B,GAAM,GAAe,EAA6B,EAAI,EAAI,GAE1D,MAAI,GAAa,cACf,EAAI,KAAK,EAAmB,EAAS,GAAG,EAAa,SAGhD,GAET,IAGuB,OAAO,AAAC,GAAQ,EAAI,cAQxC,WACL,EACA,EACA,EACkB,CAclB,MAAO,AAbmB,GAAkB,EAAO,GAAM,OACvD,CAAC,EAAK,CAAC,EAAS,CAAC,EAAI,MAAS,CAC5B,GAAM,GAAe,EAA4B,EAAI,EAAI,GAEzD,MAAI,GAAa,cACf,EAAI,KAAK,EAAmB,EAAS,GAAG,EAAa,SAGhD,GAET,IAGuB,OAAO,AAAC,GAAQ,EAAI,cAgBxC,WACL,EACA,EACA,EACA,EACA,EACA,EACgB,CAChB,MAAO,GAAwB,EAAI,EAAI,EAAQ,EAAQ,EAAO,GAYzD,WACL,EACA,EACA,EACA,EACA,EACA,EACkB,CAClB,MAAO,GAAsB,EAAO,EAAM,EAAQ,EAAQ,EAAO,GAW5D,YACL,EACA,EACA,EACA,EACA,EACkB,CAClB,GAAM,CAAE,OAAM,OAAM,QAAO,UAAW,EACtC,MAAO,GAAsB,EAAQ,EAAQ,EAAO,EAAK,CAAC,EAAM,GAAO,CAAC,EAAO,IAc1E,YACL,EACA,EACA,EACA,EACgB,CAChB,MAAO,GAA2B,EAAI,EAAI,EAAG,GAUxC,YACL,EACA,EACA,EACA,EACgB,CAChB,GAAI,GAAK,EAAG,GAAK,EAAG,GAClB,EAAK,EAAG,GAAK,EAAG,GAEZ,EAAI,KAAK,KAAK,EAAK,EAAK,EAAK,GACjC,EAAK,GAAI,EAAI,EAAK,EAAK,EAAK,GAAO,GAAI,GACvC,EAAI,KAAK,KAAK,EAAK,EAAK,EAAI,GAE9B,UAAM,EACN,GAAM,EAEC,EACL,eACA,CAAC,EAAG,GAAK,EAAK,EAAI,EAAK,EAAG,EAAG,GAAK,EAAK,EAAI,EAAK,GAChD,CAAC,EAAG,GAAK,EAAK,EAAI,EAAK,EAAG,EAAG,GAAK,EAAK,EAAI,EAAK,IAW7C,WACL,EACA,EACA,EACA,EACkB,CAClB,MAAO,GAAyB,EAAO,EAAM,EAAG,GAS3C,YAA+B,EAAa,EAAW,EAAoC,CAChG,GAAM,CAAE,OAAM,OAAM,QAAO,UAAW,EACtC,MAAO,GAAyB,EAAG,EAAG,CAAC,EAAM,GAAO,CAAC,EAAO,IAgBvD,YACL,EACA,EACA,EACA,EACA,EACA,EACgB,CAChB,MAAO,GAAoB,EAAO,EAAW,EAAQ,EAAI,EAAI,GAYxD,WACL,EACA,EACA,EACA,EAAW,EACX,EACA,EACgB,CAChB,MAAI,KAAO,EACF,EAA2B,EAAI,EAAI,EAAQ,GAG7C,EAA4B,EAAI,EAAI,EAAQ,EAAI,EAAI,GAYtD,WACL,EACA,EACA,EACA,EAAW,EACX,EACA,EACkB,CAClB,MAAI,KAAO,EACF,EAAyB,EAAO,EAAM,EAAQ,GAGhD,EAA0B,EAAO,EAAM,EAAQ,EAAI,EAAI,GAezD,WACL,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACgB,CAEhB,MAAO,GAAmB,mBAYrB,YACL,EACA,EACA,EACA,EACA,EACA,EACgB,CAChB,MAAO,GAAwB,EAAG,EAAI,EAAI,EAAU,EAAI,EAAI,EAAI,GAW3D,YACL,EACA,EACA,EACA,EACA,EACkB,CAClB,GAAM,CAAE,OAAM,OAAM,QAAO,UAAW,EACtC,MAAO,GAA0B,EAAG,EAAI,EAAI,EAAU,CAAC,EAAM,GAAO,CAAC,EAAO,IASvE,YACL,EACA,EACA,EACkB,CAClB,GAAM,CAAE,OAAM,OAAM,QAAO,UAAW,EACtC,MAAO,GAAsB,EAAQ,EAAW,CAAC,EAAM,GAAO,CAAC,EAAO,IASjE,WACL,EACA,EACA,EACkB,CAClB,GAAM,CAAE,OAAM,OAAM,QAAO,UAAW,EACtC,MAAO,GAA8B,EAAI,EAAI,CAAC,EAAM,GAAO,CAAC,EAAO,IAS9D,YACL,EACA,EACA,EACkB,CAClB,GAAM,CAAE,OAAM,OAAM,QAAO,UAAW,EACtC,MAAO,GAA4B,EAAO,EAAM,CAAC,EAAM,GAAO,CAAC,EAAO,IAQjE,YAA+B,EAAmB,EAAqC,CAC5F,MAAO,GACL,CAAC,EAAQ,KAAM,EAAQ,MACvB,CAAC,EAAQ,MAAO,EAAQ,QACxB,CAAC,EAAQ,KAAM,EAAQ,MACvB,CAAC,EAAQ,MAAO,EAAQ,SAYrB,YACL,EACA,EACA,EACA,EACA,EACkB,CAClB,GAAM,CAAE,OAAM,OAAM,QAAO,UAAW,EACtC,MAAO,GAAsB,EAAQ,EAAQ,EAAO,EAAK,CAAC,EAAM,GAAO,CAAC,EAAO,IAS1E,YAA+B,EAAkB,EAAa,EAA6B,CAChG,GAAM,CAAE,OAAM,OAAM,QAAO,UAAW,EACtC,MAAO,GAAyB,EAAG,EAAG,CAAC,EAAM,GAAO,CAAC,EAAO,IAWvD,YACL,EACA,EACA,EACA,EACA,EAAW,EACO,CAClB,GAAM,CAAE,OAAM,OAAM,QAAO,UAAW,EACtC,MAAO,GAA0B,EAAG,EAAI,EAAI,EAAU,CAAC,EAAM,GAAO,CAAC,EAAO,IAQvE,YAAiC,EAAkB,EAAsC,CAC9F,MAAO,GAAwB,EAAQ,GAQlC,YAAgC,EAAkB,EAAsC,CAC7F,MAAO,GAAuB,EAAQ,GAajC,YACL,EACA,EACA,EACgB,CAChB,MAAO,GAA6B,EAAI,EAAI,GASvC,YACL,EACA,EACA,EACkB,CAClB,MAAO,GAA2B,EAAO,EAAM,GAQ1C,WAAiC,EAAoB,EAAoC,CAC9F,MAAO,GACL,CAAC,EAAO,KAAM,EAAO,MACrB,CAAC,EAAO,MAAO,EAAO,QACtB,GAcG,YACL,EACA,EACA,EACgB,CAChB,MAAO,GAA6B,EAAI,EAAI,GASvC,YACL,EACA,EACA,EACkB,CAClB,MAAO,GAA2B,EAAO,EAAM,GAQ1C,WAAgC,EAAoB,EAAoC,CAC7F,MAAO,GACL,CAAC,EAAO,KAAM,EAAO,MACrB,CAAC,EAAO,MAAO,EAAO,QACtB,GAYG,YACL,EACA,EACA,EACkB,CAclB,MAAO,AAbmB,GAAqB,EAAQ,IAAM,OAC3D,CAAC,EAAK,CAAC,EAAI,GAAK,IAAM,CACpB,GAAM,GAAe,EAAwB,EAAQ,EAAW,EAAI,GAEpE,MAAI,IACF,EAAI,KAAK,EAAmB,EAAE,WAAY,GAAG,EAAa,SAGrD,GAET,IAGuB,OAAO,AAAC,GAAQ,EAAI,cAGxC,WAA8B,EAAoB,EAAS,GAAO,CACvE,GAAM,GAAW,GACjB,OAAS,GAAI,EAAG,EAAI,EAAO,OAAQ,IAAK,EAAS,KAAK,CAAC,EAAO,EAAI,GAAI,EAAO,KAC7E,MAAI,IAAQ,EAAS,KAAK,CAAC,EAAO,EAAO,OAAS,GAAI,EAAO,KACtD",
  "names": []
}
