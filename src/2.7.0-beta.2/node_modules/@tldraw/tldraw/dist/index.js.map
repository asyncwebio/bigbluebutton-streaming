{
  "version": 3,
  "sources": ["../src/index.ts", "../src/Tldraw.tsx", "../src/components/ContextMenu/ContextMenu.tsx", "../src/styles/stitches.config.ts", "../src/components/Primitives/Divider/Divider.tsx", "../src/components/Primitives/MenuContent/MenuContent.ts", "../src/components/Primitives/RowButton/RowButton.tsx", "../src/components/Primitives/Kbd/Kbd.tsx", "../src/components/Primitives/SmallIcon/SmallIcon.tsx", "../src/components/breakpoints.tsx", "../src/components/Primitives/ToolButton/ToolButton.tsx", "../src/components/Primitives/Tooltip/Tooltip.tsx", "../src/hooks/useFileSystem.ts", "../src/hooks/useFileSystemHandlers.ts", "../src/hooks/useKeyboardShortcuts.tsx", "../src/types.ts", "../src/hooks/useTldrawApp.tsx", "../src/hooks/useTranslation.ts", "../src/translations/translations.ts", "../src/hooks/useDialog.ts", "../src/components/ErrorFallback/ErrorFallback.tsx", "../src/components/FocusButton/FocusButton.tsx", "../src/components/Primitives/IconButton/IconButton.tsx", "../src/components/Loading/Loading.tsx", "../src/components/Primitives/AlertDialog/AlertDialog.tsx", "../src/components/Primitives/AlertDialog/FilenameDialog.tsx", "../src/components/Primitives/TextField/TextField.tsx", "../src/components/ToolsPanel/ToolsPanel.tsx", "../src/components/ToolsPanel/ActionButton.tsx", "../src/components/Primitives/DropdownMenu/DMItem.tsx", "../src/components/Primitives/DropdownMenu/DMCheckboxItem.tsx", "../src/components/preventEvent.ts", "../src/components/Primitives/DropdownMenu/DMContent.tsx", "../src/components/stopPropagation.ts", "../src/components/Primitives/DropdownMenu/DMDivider.tsx", "../src/components/Primitives/DropdownMenu/DMRadioItem.tsx", "../src/components/Primitives/DropdownMenu/DMSubMenu.tsx", "../src/components/Primitives/DropdownMenu/DMTriggerIcon.tsx", "../src/components/ToolsPanel/BackToContent.tsx", "../src/components/ToolsPanel/DeleteButton.tsx", "../src/components/Primitives/icons/BoxIcon.tsx", "../src/components/Primitives/icons/CircleIcon.tsx", "../src/components/Primitives/icons/DashDashedIcon.tsx", "../src/components/Primitives/icons/DashDottedIcon.tsx", "../src/components/Primitives/icons/DashDrawIcon.tsx", "../src/components/Primitives/icons/DashSolidIcon.tsx", "../src/components/Primitives/icons/TrashIcon.tsx", "../src/components/Primitives/icons/UndoIcon.tsx", "../src/components/Primitives/icons/SizeSmallIcon.tsx", "../src/components/Primitives/icons/SizeMediumIcon.tsx", "../src/components/Primitives/icons/SizeLargeIcon.tsx", "../src/components/Primitives/icons/EraserIcon.tsx", "../src/components/Primitives/icons/DiscordIcon.tsx", "../src/components/Primitives/icons/LineIcon.tsx", "../src/components/ToolsPanel/HelpPanel.tsx", "../src/components/TopPanel/LanguageMenu/LanguageMenu.tsx", "../src/components/ToolsPanel/KeyboardShortcutDialog.tsx", "../src/components/ToolsPanel/PrimaryTools.tsx", "../src/components/Primitives/Panel/Panel.tsx", "../src/components/ToolsPanel/ShapesMenu.tsx", "../src/components/ToolsPanel/StatusBar.tsx", "../src/components/TopPanel/TopPanel.tsx", "../src/components/TopPanel/Menu/Menu.tsx", "../src/components/TopPanel/PreferencesMenu/PreferencesMenu.tsx", "../src/components/TopPanel/MultiplayerMenu/MultiplayerMenu.tsx", "../src/components/Primitives/icons/MultiplayerIcon2.tsx", "../src/state/TLDR.ts", "../src/constants.ts", "../src/state/StateManager/copy.ts", "../src/state/shapes/ArrowUtil/ArrowUtil.tsx", "../src/state/shapes/TDShapeUtil.tsx", "../src/state/shapes/shared/getBoundsRectangle.ts", "../src/state/shapes/shared/getTextAlign.ts", "../src/state/shapes/shared/getTextSize.ts", "../src/state/shapes/shared/getTextSvgElement.ts", "../src/state/shapes/shared/LabelMask.tsx", "../src/state/shapes/shared/PolygonUtils.ts", "../src/state/shapes/shared/shape-styles.ts", "../src/state/shapes/shared/TextAreaUtils.ts", "../src/state/shapes/shared/TextLabel.tsx", "../src/state/shapes/shared/transformRectangle.ts", "../src/state/shapes/shared/transformSingleRectangle.ts", "../src/state/shapes/ArrowUtil/arrowHelpers.ts", "../src/state/shapes/ArrowUtil/components/CurvedArrow.tsx.tsx", "../src/state/shapes/ArrowUtil/components/ArrowHead.tsx", "../src/state/shapes/ArrowUtil/components/StraightArrow.tsx", "../src/state/shapes/DrawUtil/DrawUtil.tsx", "../src/state/shapes/DrawUtil/drawHelpers.ts", "../src/state/shapes/EllipseUtil/EllipseUtil.tsx", "../src/state/shapes/EllipseUtil/components/DashedEllipse.tsx", "../src/state/shapes/EllipseUtil/components/DrawEllipse.tsx", "../src/state/shapes/EllipseUtil/ellipseHelpers.ts", "../src/state/shapes/GroupUtil/GroupUtil.tsx", "../src/state/shapes/ImageUtil/ImageUtil.tsx", "../src/state/shapes/RectangleUtil/RectangleUtil.tsx", "../src/state/shapes/RectangleUtil/components/BindingIndicator.tsx", "../src/state/shapes/RectangleUtil/components/DashedRectangle.tsx", "../src/state/shapes/RectangleUtil/components/DrawRectangle.tsx", "../src/state/shapes/RectangleUtil/rectangleHelpers.ts", "../src/state/shapes/StickyUtil/StickyUtil.tsx", "../src/state/shapes/TextUtil/TextUtil.tsx", "../src/state/shapes/TriangleUtil/TriangleUtil.tsx", "../src/state/shapes/TriangleUtil/components/DashedTriangle.tsx", "../src/state/shapes/TriangleUtil/triangleHelpers.ts", "../src/state/shapes/TriangleUtil/components/DrawTriangle.tsx", "../src/state/shapes/TriangleUtil/components/TriangleBindingIndicator.tsx", "../src/state/shapes/VideoUtil/VideoUtil.tsx", "../src/state/shapes/index.ts", "../src/components/TopPanel/PageMenu/PageMenu.tsx", "../src/components/TopPanel/PageOptionsDialog/PageOptionsDialog.tsx", "../src/components/TopPanel/StyleMenu/StyleMenu.tsx", "../src/components/TopPanel/ZoomMenu/ZoomMenu.tsx", "../src/hooks/useCursor.ts", "../src/state/TldrawApp.ts", "../src/state/IdbClipboard.ts", "../src/state/StateManager/StateManager.ts", "../src/state/commands/alignShapes/alignShapes.ts", "../src/state/commands/changePage/changePage.ts", "../src/state/commands/createPage/createPage.ts", "../src/state/commands/shared/getIncrementedName.ts", "../src/state/commands/shared/removeShapesFromPage.ts", "../src/state/commands/createShapes/createShapes.ts", "../src/state/commands/deletePage/deletePage.ts", "../src/state/commands/deleteShapes/deleteShapes.ts", "../src/state/commands/distributeShapes/distributeShapes.ts", "../src/state/commands/duplicatePage/duplicatePage.ts", "../src/state/commands/duplicateShapes/duplicateShapes.ts", "../src/state/commands/flipShapes/flipShapes.ts", "../src/state/commands/groupShapes/groupShapes.ts", "../src/state/commands/moveShapesToPage/moveShapesToPage.ts", "../src/state/commands/movePage/movePage.ts", "../src/state/commands/reorderShapes/reorderShapes.ts", "../src/state/commands/renamePage/renamePage.ts", "../src/state/commands/resetBounds/resetBounds.ts", "../src/state/commands/rotateShapes/rotateShapes.ts", "../src/state/commands/stretchShapes/stretchShapes.ts", "../src/state/commands/styleShapes/styleShapes.ts", "../src/state/commands/toggleShapesDecoration/toggleShapesDecoration.ts", "../src/state/commands/toggleShapesProp/toggleShapesProp.ts", "../src/state/commands/translateShapes/translateShapes.ts", "../src/state/commands/ungroupShapes/ungroupShapes.ts", "../src/state/commands/updateShapes/updateShapes.ts", "../src/state/commands/setShapesProps/setShapesProps.ts", "../src/state/commands/insertContent/insertContent.ts", "../src/state/data/index.ts", "../src/state/data/migrate.ts", "../src/state/data/filesystem.ts", "../src/state/sessions/ArrowSession/ArrowSession.ts", "../src/state/sessions/BaseSession.ts", "../src/state/sessions/BrushSession/BrushSession.ts", "../src/state/sessions/DrawSession/DrawSession.ts", "../src/state/sessions/EditSession/EditSession.ts", "../src/state/sessions/EraseSession/EraseSession.ts", "../src/state/sessions/GridSession/GridSession.ts", "../src/state/sessions/HandleSession/HandleSession.ts", "../src/state/sessions/RotateSession/RotateSession.ts", "../src/state/sessions/TransformSession/TransformSession.ts", "../src/state/sessions/TransformSingleSession/TransformSingleSession.ts", "../src/state/sessions/TranslateSession/TranslateSession.ts", "../src/state/sessions/index.ts", "../src/state/tools/ArrowTool/ArrowTool.ts", "../src/state/tools/BaseTool.ts", "../src/state/tools/DrawTool/DrawTool.ts", "../src/state/tools/EllipseTool/EllipseTool.ts", "../src/state/tools/EraseTool/EraseTool.ts", "../src/state/tools/LineTool/LineTool.ts", "../src/state/tools/RectangleTool/RectangleTool.ts", "../src/state/tools/SelectTool/SelectTool.ts", "../src/state/tools/StickyTool/StickyTool.ts", "../src/state/tools/TextTool/TextTool.ts", "../src/state/tools/TriangleTool/TriangleTool.ts", "../src/state/tools/index.ts"],
  "sourcesContent": ["export * from './Tldraw'\nexport * from './types'\nexport * from './state/shapes'\nexport * from './state/TLDR'\nexport { TldrawApp } from './state'\nexport { useFileSystem } from './hooks'\n", "import '@fontsource/caveat-brush'\nimport '@fontsource/crimson-pro'\nimport '@fontsource/recursive'\nimport '@fontsource/source-code-pro'\nimport '@fontsource/source-sans-pro'\nimport { CursorComponent, Renderer } from '@tldraw/core'\nimport * as React from 'react'\nimport { ErrorBoundary as _Errorboundary } from 'react-error-boundary'\nimport { IntlProvider } from 'react-intl'\nimport { ContextMenu } from '~components/ContextMenu'\nimport { ErrorFallback } from '~components/ErrorFallback'\nimport { FocusButton } from '~components/FocusButton'\nimport { Loading } from '~components/Loading'\nimport { AlertDialog } from '~components/Primitives/AlertDialog'\nimport { ToolsPanel } from '~components/ToolsPanel'\nimport { TopPanel } from '~components/TopPanel'\nimport { GRID_SIZE } from '~constants'\nimport {\n  AlertDialogContext,\n  ContainerContext,\n  DialogState,\n  TldrawContext,\n  useKeyboardShortcuts,\n  useTldrawApp,\n  useTranslation,\n} from '~hooks'\nimport { useCursor } from '~hooks/useCursor'\nimport { TDCallbacks, TldrawApp } from '~state'\nimport { TLDR } from '~state/TLDR'\nimport { shapeUtils } from '~state/shapes'\nimport { dark, styled } from '~styles'\nimport { TDDocument, TDStatus } from '~types'\n\nconst ErrorBoundary = _Errorboundary as any\n\nexport interface TldrawProps extends TDCallbacks {\n  /**\n   * (optional) If provided, the component will load / persist state under this key.\n   */\n  id?: string\n\n  /**\n   * (optional) The document to load or update from.\n   */\n  document?: TDDocument\n\n  /**\n   * (optional) The current page id.\n   */\n  currentPageId?: string\n\n  /**\n   * (optional) Whether the editor should immediately receive focus. Defaults to true.\n   */\n  autofocus?: boolean\n\n  /**\n   * (optional) Whether to show the menu UI.\n   */\n  showMenu?: boolean\n\n  /**\n   * (optional) Whether to show the multiplayer menu.\n   */\n  showMultiplayerMenu?: boolean\n\n  /**\n   * (optional) Whether to show the pages UI.\n   */\n  showPages?: boolean\n\n  /**\n   * (optional) Whether to show the styles UI.\n   */\n  showStyles?: boolean\n\n  /**\n   * (optional) Whether to show the zoom UI.\n   */\n  showZoom?: boolean\n\n  /**\n   * (optional) Whether to show the tools UI.\n   */\n  showTools?: boolean\n\n  /**\n   * (optional) Whether to show the UI.\n   */\n  showUI?: boolean\n\n  /**\n   * (optional) Whether to the document should be read only.\n   */\n  readOnly?: boolean\n\n  /**\n   * (optional) Whether to to show the app's dark mode UI.\n   */\n  darkMode?: boolean\n\n  /**\n   * (optional) If provided, image/video componnets will be disabled.\n   *\n   * Warning: Keeping this enabled for multiplayer applications without provifing a storage\n   * bucket based solution will cause massive base64 string to be written to the liveblocks room.\n   */\n  disableAssets?: boolean\n\n  /**\n   * (optional) Custom components to override parts of the default UI.\n   */\n  components?: {\n    /**\n     * The component to render for multiplayer cursors.\n     */\n    Cursor?: CursorComponent\n  }\n\n  /**\n   * (optional) To hide cursors\n   */\n  hideCursors?: boolean\n}\n\nconst isSystemDarkMode = window.matchMedia\n  ? window.matchMedia('(prefers-color-scheme: dark)').matches\n  : false\n\nexport function Tldraw({\n  id,\n  document,\n  currentPageId,\n  autofocus = true,\n  showMenu = true,\n  showMultiplayerMenu = true,\n  showPages = true,\n  showTools = true,\n  showZoom = true,\n  showStyles = true,\n  showUI = true,\n  readOnly = false,\n  disableAssets = false,\n  darkMode = isSystemDarkMode,\n  components,\n  onMount,\n  onChange,\n  onChangePresence,\n  onNewProject,\n  onSaveProject,\n  onSaveProjectAs,\n  onOpenProject,\n  onOpenMedia,\n  onUndo,\n  onRedo,\n  onPersist,\n  onPatch,\n  onCommand,\n  onChangePage,\n  onAssetCreate,\n  onAssetDelete,\n  onAssetUpload,\n  onSessionStart,\n  onSessionEnd,\n  onExport,\n  hideCursors,\n}: TldrawProps) {\n  const [sId, setSId] = React.useState(id)\n\n  // Create a new app when the component mounts.\n  const [app, setApp] = React.useState(() => {\n    const app = new TldrawApp(id, {\n      onMount,\n      onChange,\n      onChangePresence,\n      onNewProject,\n      onSaveProject,\n      onSaveProjectAs,\n      onOpenProject,\n      onOpenMedia,\n      onUndo,\n      onRedo,\n      onPersist,\n      onPatch,\n      onCommand,\n      onChangePage,\n      onAssetDelete,\n      onAssetCreate,\n      onAssetUpload,\n      onSessionStart,\n      onSessionEnd,\n    })\n    return app\n  })\n\n  const [onCancel, setOnCancel] = React.useState<(() => void) | null>(null)\n  const [onYes, setOnYes] = React.useState<(() => void) | null>(null)\n  const [onNo, setOnNo] = React.useState<(() => void) | null>(null)\n  const [dialogState, setDialogState] = React.useState<DialogState | null>(null)\n\n  const openDialog = React.useCallback(\n    (dialogState: DialogState, onYes: () => void, onNo: () => void, onCancel: () => void) => {\n      setDialogState(() => dialogState)\n      setOnCancel(() => onCancel)\n      setOnYes(() => onYes)\n      setOnNo(() => onNo)\n    },\n    []\n  )\n\n  // Create a new app if the `id` prop changes.\n  React.useLayoutEffect(() => {\n    if (id === sId) return\n    const newApp = new TldrawApp(id, {\n      onMount,\n      onChange,\n      onChangePresence,\n      onNewProject,\n      onSaveProject,\n      onSaveProjectAs,\n      onOpenProject,\n      onOpenMedia,\n      onUndo,\n      onRedo,\n      onPersist,\n      onPatch,\n      onCommand,\n      onChangePage,\n      onAssetDelete,\n      onAssetCreate,\n      onAssetUpload,\n      onExport,\n      onSessionStart,\n      onSessionEnd,\n    })\n\n    setSId(id)\n\n    setApp(newApp)\n  }, [sId, id])\n\n  // Update the document if the `document` prop changes but the ids,\n  // are the same, or else load a new document if the ids are different.\n  React.useEffect(() => {\n    if (!document) return\n\n    if (document.id === app.document.id) {\n      app.updateDocument(document)\n    } else {\n      app.loadDocument(document)\n    }\n  }, [document, app])\n\n  // Disable assets when the `disableAssets` prop changes.\n  React.useEffect(() => {\n    app.setDisableAssets(disableAssets)\n  }, [app, disableAssets])\n\n  // Change the page when the `currentPageId` prop changes.\n  React.useEffect(() => {\n    if (!currentPageId) return\n    app.changePage(currentPageId)\n  }, [currentPageId, app])\n\n  // Toggle the app's readOnly mode when the `readOnly` prop changes.\n  React.useEffect(() => {\n    app.readOnly = readOnly\n    if (!readOnly) {\n      app.selectNone()\n      app.cancelSession()\n      app.setEditingId()\n    }\n  }, [app, readOnly])\n\n  // Toggle the app's darkMode when the `darkMode` prop changes.\n  React.useEffect(() => {\n    if (darkMode !== app.settings.isDarkMode) {\n      app.toggleDarkMode()\n    }\n  }, [app, darkMode])\n\n  // Update the app's callbacks when any callback changes.\n  React.useEffect(() => {\n    app.callbacks = {\n      onMount,\n      onChange,\n      onChangePresence,\n      onNewProject,\n      onSaveProject,\n      onSaveProjectAs,\n      onOpenProject,\n      onOpenMedia,\n      onUndo,\n      onRedo,\n      onPersist,\n      onPatch,\n      onCommand,\n      onChangePage,\n      onAssetDelete,\n      onAssetCreate,\n      onAssetUpload,\n      onExport,\n      onSessionStart,\n      onSessionEnd,\n    }\n  }, [\n    onMount,\n    onChange,\n    onChangePresence,\n    onNewProject,\n    onSaveProject,\n    onSaveProjectAs,\n    onOpenProject,\n    onOpenMedia,\n    onUndo,\n    onRedo,\n    onPersist,\n    onPatch,\n    onCommand,\n    onChangePage,\n    onAssetDelete,\n    onAssetCreate,\n    onAssetUpload,\n    onExport,\n    onSessionStart,\n    onSessionEnd,\n  ])\n\n  React.useLayoutEffect(() => {\n    if (typeof window === 'undefined') return\n    if (!window.document?.fonts) return\n\n    function refreshBoundingBoxes() {\n      app.refreshBoundingBoxes()\n    }\n    window.document.fonts.addEventListener('loadingdone', refreshBoundingBoxes)\n    return () => {\n      window.document.fonts.removeEventListener('loadingdone', refreshBoundingBoxes)\n    }\n  }, [app])\n\n  // Use the `key` to ensure that new selector hooks are made when the id changes\n  return (\n    <TldrawContext.Provider value={app}>\n      <AlertDialogContext.Provider\n        value={{ onYes, onCancel, onNo, dialogState, setDialogState, openDialog }}\n      >\n        <InnerTldraw\n          key={sId || 'Tldraw'}\n          id={sId}\n          autofocus={autofocus}\n          showPages={showPages}\n          showMenu={showMenu}\n          showMultiplayerMenu={showMultiplayerMenu}\n          showStyles={showStyles}\n          showZoom={showZoom}\n          showTools={showTools}\n          showUI={showUI}\n          readOnly={readOnly}\n          components={components}\n          hideCursors={hideCursors}\n        />\n      </AlertDialogContext.Provider>\n    </TldrawContext.Provider>\n  )\n}\n\ninterface InnerTldrawProps {\n  id?: string\n  autofocus: boolean\n  readOnly: boolean\n  showPages: boolean\n  showMenu: boolean\n  showMultiplayerMenu: boolean\n  showZoom: boolean\n  showStyles: boolean\n  showUI: boolean\n  showTools: boolean\n  components?: {\n    Cursor?: CursorComponent\n  }\n  hideCursors?: boolean\n}\n\nconst InnerTldraw = React.memo(function InnerTldraw({\n  id,\n  autofocus,\n  showPages,\n  showMenu,\n  showMultiplayerMenu,\n  showZoom,\n  showStyles,\n  showTools,\n  readOnly,\n  showUI,\n  components,\n  hideCursors,\n}: InnerTldrawProps) {\n  const app = useTldrawApp()\n  const [dialogContainer, setDialogContainer] = React.useState<any>(null)\n  const rWrapper = React.useRef<HTMLDivElement>(null)\n\n  const state = app.useStore()\n\n  const { document, settings, appState, room } = state\n\n  const isSelecting = state.appState.activeTool === 'select'\n\n  const page = document.pages[appState.currentPageId]\n  const pageState = document.pageStates[page.id]\n  const assets = document.assets\n  const { selectedIds } = pageState\n\n  const isHideBoundsShape =\n    selectedIds.length === 1 &&\n    page.shapes[selectedIds[0]] &&\n    TLDR.getShapeUtil(page.shapes[selectedIds[0]].type).hideBounds\n\n  const isHideResizeHandlesShape =\n    selectedIds.length === 1 &&\n    page.shapes[selectedIds[0]] &&\n    TLDR.getShapeUtil(page.shapes[selectedIds[0]].type).hideResizeHandles\n\n  // Custom rendering meta, with dark mode for shapes\n  const meta = React.useMemo(() => {\n    return { isDarkMode: settings.isDarkMode }\n  }, [settings.isDarkMode])\n\n  const showDashedBrush = settings.isCadSelectMode\n    ? !appState.selectByContain\n    : appState.selectByContain\n\n  // Custom theme, based on darkmode\n  const theme = React.useMemo(() => {\n    const { selectByContain } = appState\n    const { isDarkMode, isCadSelectMode } = settings\n\n    if (isDarkMode) {\n      const brushBase = isCadSelectMode\n        ? selectByContain\n          ? '69, 155, 255'\n          : '105, 209, 73'\n        : '180, 180, 180'\n      return {\n        brushFill: `rgba(${brushBase}, ${isCadSelectMode ? 0.08 : 0.05})`,\n        brushStroke: `rgba(${brushBase}, ${isCadSelectMode ? 0.5 : 0.25})`,\n        brushDashStroke: `rgba(${brushBase}, .6)`,\n        selected: 'rgba(38, 150, 255, 1.000)',\n        selectFill: 'rgba(38, 150, 255, 0.05)',\n        background: '#212529',\n        foreground: '#49555f',\n      }\n    }\n\n    const brushBase = isCadSelectMode ? (selectByContain ? '0, 89, 242' : '51, 163, 23') : '0,0,0'\n\n    return {\n      brushFill: `rgba(${brushBase}, ${isCadSelectMode ? 0.08 : 0.05})`,\n      brushStroke: `rgba(${brushBase}, ${isCadSelectMode ? 0.4 : 0.25})`,\n      brushDashStroke: `rgba(${brushBase}, .6)`,\n    }\n  }, [settings.isDarkMode, settings.isCadSelectMode, appState.selectByContain])\n\n  const isInSession = app.session !== undefined\n\n  // Hide bounds when not using the select tool, or when the only selected shape has handles\n  const hideBounds =\n    (isInSession && app.session?.constructor.name !== 'BrushSession') ||\n    !isSelecting ||\n    isHideBoundsShape ||\n    !!pageState.editingId\n\n  // Hide bounds when not using the select tool, or when in session\n  const hideHandles = isInSession || !isSelecting\n\n  // Hide indicators when not using the select tool, or when in session\n  const hideIndicators =\n    (isInSession && state.appState.status !== TDStatus.Brushing) || !isSelecting\n\n  const hideCloneHandles = isInSession || !isSelecting || pageState.camera.zoom < 0.2\n\n  const translation = useTranslation(settings.language)\n\n  // Put the theme on the body. This means that components with\n  // multiple editors cannot have different themes.\n  React.useLayoutEffect(() => {\n    const elm = rWrapper.current\n    if (!elm) return\n    if (settings.isDarkMode) {\n      elm.classList.add(dark)\n    } else {\n      elm.classList.remove(dark)\n    }\n  }, [settings.isDarkMode])\n\n  useCursor(rWrapper)\n\n  return (\n    <ContainerContext.Provider value={rWrapper}>\n      <IntlProvider locale={translation.locale} messages={translation.messages}>\n        <AlertDialog container={dialogContainer} />\n        <StyledLayout ref={rWrapper} tabIndex={-0}>\n          <Loading />\n          <OneOff focusableRef={rWrapper} autofocus={autofocus} />\n          <ContextMenu>\n            <ErrorBoundary FallbackComponent={ErrorFallback}>\n              <Renderer\n                id={id}\n                containerRef={rWrapper}\n                shapeUtils={shapeUtils}\n                page={page}\n                pageState={pageState}\n                assets={assets}\n                snapLines={appState.snapLines}\n                eraseLine={appState.eraseLine}\n                grid={GRID_SIZE}\n                users={room?.users}\n                userId={room?.userId}\n                theme={theme}\n                meta={meta}\n                components={components}\n                hideCursors={hideCursors}\n                hideBounds={hideBounds}\n                hideHandles={hideHandles}\n                hideResizeHandles={isHideResizeHandlesShape}\n                hideIndicators={hideIndicators}\n                hideBindingHandles={!settings.showBindingHandles}\n                hideCloneHandles={hideCloneHandles}\n                hideRotateHandles={!settings.showRotateHandles}\n                hideGrid={!settings.showGrid}\n                showDashedBrush={showDashedBrush}\n                performanceMode={app.session?.performanceMode}\n                onPinchStart={app.onPinchStart}\n                onPinchEnd={app.onPinchEnd}\n                onPinch={app.onPinch}\n                onPan={app.onPan}\n                onZoom={app.onZoom}\n                onPointerDown={app.onPointerDown}\n                onPointerMove={app.onPointerMove}\n                onPointerUp={app.onPointerUp}\n                onPointCanvas={app.onPointCanvas}\n                onDoubleClickCanvas={app.onDoubleClickCanvas}\n                onRightPointCanvas={app.onRightPointCanvas}\n                onDragCanvas={app.onDragCanvas}\n                onReleaseCanvas={app.onReleaseCanvas}\n                onPointShape={app.onPointShape}\n                onDoubleClickShape={app.onDoubleClickShape}\n                onRightPointShape={app.onRightPointShape}\n                onDragShape={app.onDragShape}\n                onHoverShape={app.onHoverShape}\n                onUnhoverShape={app.onUnhoverShape}\n                onReleaseShape={app.onReleaseShape}\n                onPointBounds={app.onPointBounds}\n                onDoubleClickBounds={app.onDoubleClickBounds}\n                onRightPointBounds={app.onRightPointBounds}\n                onDragBounds={app.onDragBounds}\n                onHoverBounds={app.onHoverBounds}\n                onUnhoverBounds={app.onUnhoverBounds}\n                onReleaseBounds={app.onReleaseBounds}\n                onPointBoundsHandle={app.onPointBoundsHandle}\n                onDoubleClickBoundsHandle={app.onDoubleClickBoundsHandle}\n                onRightPointBoundsHandle={app.onRightPointBoundsHandle}\n                onDragBoundsHandle={app.onDragBoundsHandle}\n                onHoverBoundsHandle={app.onHoverBoundsHandle}\n                onUnhoverBoundsHandle={app.onUnhoverBoundsHandle}\n                onReleaseBoundsHandle={app.onReleaseBoundsHandle}\n                onPointHandle={app.onPointHandle}\n                onDoubleClickHandle={app.onDoubleClickHandle}\n                onRightPointHandle={app.onRightPointHandle}\n                onDragHandle={app.onDragHandle}\n                onHoverHandle={app.onHoverHandle}\n                onUnhoverHandle={app.onUnhoverHandle}\n                onReleaseHandle={app.onReleaseHandle}\n                onError={app.onError}\n                onRenderCountChange={app.onRenderCountChange}\n                onShapeChange={app.onShapeChange}\n                onShapeBlur={app.onShapeBlur}\n                onShapeClone={app.onShapeClone}\n                onBoundsChange={app.updateBounds}\n                onKeyDown={app.onKeyDown}\n                onKeyUp={app.onKeyUp}\n                onDragOver={app.onDragOver}\n                onDrop={app.onDrop}\n              />\n            </ErrorBoundary>\n          </ContextMenu>\n          {showUI && (\n            <StyledUI ref={setDialogContainer}>\n              {settings.isFocusMode ? (\n                <FocusButton onSelect={app.toggleFocusMode} />\n              ) : (\n                <>\n                  <TopPanel\n                    readOnly={readOnly}\n                    showPages={showPages}\n                    showMenu={showMenu}\n                    showMultiplayerMenu={showMultiplayerMenu}\n                    showStyles={showStyles}\n                    showZoom={showZoom}\n                  />\n                  <StyledSpacer />\n                  {showTools && !readOnly && <ToolsPanel />}\n                </>\n              )}\n            </StyledUI>\n          )}\n        </StyledLayout>\n      </IntlProvider>\n    </ContainerContext.Provider>\n  )\n})\n\nconst OneOff = React.memo(function OneOff({\n  focusableRef,\n  autofocus,\n}: {\n  autofocus?: boolean\n  focusableRef: React.RefObject<HTMLDivElement>\n}) {\n  useKeyboardShortcuts(focusableRef)\n\n  React.useEffect(() => {\n    if (autofocus) {\n      focusableRef.current?.focus()\n    }\n  }, [autofocus])\n\n  return null\n})\n\nconst StyledLayout = styled('div', {\n  position: 'absolute',\n  height: '100%',\n  width: '100%',\n  minHeight: 0,\n  minWidth: 0,\n  maxHeight: '100%',\n  maxWidth: '100%',\n  overflow: 'hidden',\n  boxSizing: 'border-box',\n  outline: 'none',\n\n  '& .tl-container': {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    height: '100%',\n    width: '100%',\n    zIndex: 1,\n  },\n\n  '& input, textarea, button, select, label, button': {\n    webkitTouchCallout: 'none',\n    webkitUserSelect: 'none',\n    '-webkit-tap-highlight-color': 'transparent',\n    'tap-highlight-color': 'transparent',\n  },\n})\n\nconst StyledUI = styled('div', {\n  position: 'absolute',\n  top: 0,\n  left: 0,\n  height: '100%',\n  width: '100%',\n  padding: '8px 8px 0 8px',\n  display: 'flex',\n  alignItems: 'flex-start',\n  justifyContent: 'flex-start',\n  pointerEvents: 'none',\n  zIndex: 2,\n  '& > *': {\n    pointerEvents: 'all',\n  },\n})\n\nconst StyledSpacer = styled('div', {\n  flexGrow: 2,\n})\n", "import * as RadixContextMenu from '@radix-ui/react-context-menu'\nimport {\n  AlignBottomIcon,\n  AlignCenterHorizontallyIcon,\n  AlignCenterVerticallyIcon,\n  AlignLeftIcon,\n  AlignRightIcon,\n  AlignTopIcon,\n  SpaceEvenlyHorizontallyIcon,\n  SpaceEvenlyVerticallyIcon,\n  StretchHorizontallyIcon,\n  StretchVerticallyIcon,\n} from '@radix-ui/react-icons'\nimport * as React from 'react'\nimport { FormattedMessage, useIntl } from 'react-intl'\nimport { Divider } from '~components/Primitives/Divider'\nimport { MenuContent } from '~components/Primitives/MenuContent'\nimport { RowButton, RowButtonProps } from '~components/Primitives/RowButton'\nimport { ToolButton, ToolButtonProps } from '~components/Primitives/ToolButton'\nimport { useContainer, useTldrawApp } from '~hooks'\nimport { styled } from '~styles'\nimport { AlignType, DistributeType, StretchType, TDExportType, TDSnapshot } from '~types'\n\nconst numberOfSelectedIdsSelector = (s: TDSnapshot) => {\n  return s.document.pageStates[s.appState.currentPageId].selectedIds.length\n}\n\nconst isDebugModeSelector = (s: TDSnapshot) => {\n  return s.settings.isDebugMode\n}\n\nconst hasGroupSelectedSelector = (s: TDSnapshot) => {\n  return s.document.pageStates[s.appState.currentPageId].selectedIds.some(\n    (id) => s.document.pages[s.appState.currentPageId].shapes[id].children !== undefined\n  )\n}\n\nconst preventDefault = (e: Event) => e.stopPropagation()\n\ninterface ContextMenuProps {\n  onBlur?: React.FocusEventHandler\n  children: React.ReactNode\n}\n\nexport const _ContextMenu = ({ onBlur, children }: ContextMenuProps) => {\n  const container = useContainer()\n\n  return (\n    <RadixContextMenu.Root dir=\"ltr\">\n      <RadixContextMenu.Trigger dir=\"ltr\">{children}</RadixContextMenu.Trigger>\n      <RadixContextMenu.Portal container={container.current}>\n        <RadixContextMenu.Content\n          onEscapeKeyDown={preventDefault}\n          tabIndex={-1}\n          onBlur={onBlur}\n          asChild\n        >\n          <MenuContent id=\"TD-ContextMenu\">\n            <InnerMenu />\n          </MenuContent>\n        </RadixContextMenu.Content>\n      </RadixContextMenu.Portal>\n    </RadixContextMenu.Root>\n  )\n}\n\nconst InnerMenu = React.memo(function InnerMenu() {\n  const app = useTldrawApp()\n  const intl = useIntl()\n  const numberOfSelectedIds = app.useStore(numberOfSelectedIdsSelector)\n  const isDebugMode = app.useStore(isDebugModeSelector)\n  const hasGroupSelected = app.useStore(hasGroupSelectedSelector)\n\n  const handleFlipHorizontal = React.useCallback(() => {\n    app.flipHorizontal()\n  }, [app])\n\n  const handleFlipVertical = React.useCallback(() => {\n    app.flipVertical()\n  }, [app])\n\n  const handleDuplicate = React.useCallback(() => {\n    app.duplicate()\n  }, [app])\n\n  const handleLock = React.useCallback(() => {\n    app.toggleLocked()\n  }, [app])\n\n  const handleGroup = React.useCallback(() => {\n    app.group()\n  }, [app])\n\n  const handleMoveToBack = React.useCallback(() => {\n    app.moveToBack()\n  }, [app])\n\n  const handleMoveBackward = React.useCallback(() => {\n    app.moveBackward()\n  }, [app])\n\n  const handleMoveForward = React.useCallback(() => {\n    app.moveForward()\n  }, [app])\n\n  const handleMoveToFront = React.useCallback(() => {\n    app.moveToFront()\n  }, [app])\n\n  const handleDelete = React.useCallback(() => {\n    app.delete()\n  }, [app])\n\n  const handleCut = React.useCallback(() => {\n    app.cut()\n  }, [app])\n\n  const handleCopy = React.useCallback(() => {\n    app.copy()\n  }, [app])\n\n  const handlePaste = React.useCallback(() => {\n    app.paste()\n  }, [app])\n\n  const handleCopySVG = React.useCallback(() => {\n    app.copyImage(TDExportType.SVG, { scale: 1, quality: 1, transparentBackground: false })\n  }, [app])\n\n  const handleCopyPNG = React.useCallback(() => {\n    app.copyImage(TDExportType.PNG, { scale: 2, quality: 1, transparentBackground: true })\n  }, [app])\n\n  const handleUndo = React.useCallback(() => {\n    app.undo()\n  }, [app])\n\n  const handleRedo = React.useCallback(() => {\n    app.redo()\n  }, [app])\n\n  const handleExportPNG = React.useCallback(async () => {\n    app.exportImage(TDExportType.PNG, { scale: 2, quality: 1 })\n  }, [app])\n\n  const handleExportJPG = React.useCallback(async () => {\n    app.exportImage(TDExportType.JPG, { scale: 2, quality: 1 })\n  }, [app])\n\n  const handleExportWEBP = React.useCallback(async () => {\n    app.exportImage(TDExportType.WEBP, { scale: 2, quality: 1 })\n  }, [app])\n\n  const handleExportSVG = React.useCallback(async () => {\n    app.exportImage(TDExportType.SVG, { scale: 1, quality: 1 })\n  }, [app])\n\n  const handleCopyJSON = React.useCallback(async () => {\n    app.copyJson()\n  }, [app])\n\n  const handleExportJSON = React.useCallback(async () => {\n    app.exportJson()\n  }, [app])\n\n  const hasSelection = numberOfSelectedIds > 0\n  const hasTwoOrMore = numberOfSelectedIds > 1\n  const hasThreeOrMore = numberOfSelectedIds > 2\n\n  return (\n    <>\n      {hasSelection ? (\n        <>\n          <CMRowButton onClick={handleDuplicate} kbd=\"#D\" id=\"TD-ContextMenu-Duplicate\">\n            <FormattedMessage id=\"duplicate\" />\n          </CMRowButton>\n          <CMRowButton onClick={handleFlipHorizontal} kbd=\"\u21E7H\" id=\"TD-ContextMenu-Flip_Horizontal\">\n            <FormattedMessage id=\"flip.horizontal\" />\n          </CMRowButton>\n          <CMRowButton onClick={handleFlipVertical} kbd=\"\u21E7V\" id=\"TD-ContextMenu-Flip_Vertical\">\n            <FormattedMessage id=\"flip.vertical\" />\n          </CMRowButton>\n          <CMRowButton onClick={handleLock} kbd=\"#\u21E7L\" id=\"TD-ContextMenu- Lock_Unlock\">\n            <FormattedMessage id=\"lock\" /> / <FormattedMessage id=\"unlock\" />\n          </CMRowButton>\n          {(hasTwoOrMore || hasGroupSelected) && <Divider />}\n          {hasTwoOrMore && (\n            <CMRowButton onClick={handleGroup} kbd=\"#G\" id=\"TD-ContextMenu-Group\">\n              <FormattedMessage id=\"group\" />\n            </CMRowButton>\n          )}\n          {hasGroupSelected && (\n            <CMRowButton onClick={handleGroup} kbd=\"#G\" id=\"TD-ContextMenu-Ungroup\">\n              <FormattedMessage id=\"ungroup\" />\n            </CMRowButton>\n          )}\n          <Divider />\n          <ContextMenuSubMenu label={intl.formatMessage({ id: 'move' })} id=\"TD-ContextMenu-Move\">\n            <CMRowButton onClick={handleMoveToFront} kbd=\"\u21E7]\" id=\"TD-ContextMenu-Move-To_Front\">\n              <FormattedMessage id=\"to.front\" />\n            </CMRowButton>\n            <CMRowButton onClick={handleMoveForward} kbd=\"]\" id=\"TD-ContextMenu-Move-Forward\">\n              <FormattedMessage id=\"forward\" />\n            </CMRowButton>\n            <CMRowButton onClick={handleMoveBackward} kbd=\"[\" id=\"TD-ContextMenu-Move-Backward\">\n              <FormattedMessage id=\"backward\" />\n            </CMRowButton>\n            <CMRowButton onClick={handleMoveToBack} kbd=\"\u21E7[\" id=\"TD-ContextMenu-Move-To_Back\">\n              <FormattedMessage id=\"back\" />\n            </CMRowButton>\n          </ContextMenuSubMenu>\n          <MoveToPageMenu />\n          {hasTwoOrMore && (\n            <AlignDistributeSubMenu hasTwoOrMore={hasTwoOrMore} hasThreeOrMore={hasThreeOrMore} />\n          )}\n          <Divider />\n          <CMRowButton onClick={handleCut} kbd=\"#X\" id=\"TD-ContextMenu-Cut\">\n            <FormattedMessage id=\"cut\" />\n          </CMRowButton>\n          <CMRowButton onClick={handleCopy} kbd=\"#C\" id=\"TD-ContextMenu-Copy\">\n            <FormattedMessage id=\"copy\" />\n          </CMRowButton>\n          <CMRowButton onClick={handlePaste} kbd=\"#V\" id=\"TD-ContextMenu-Paste\">\n            <FormattedMessage id=\"paste\" />\n          </CMRowButton>\n          <Divider />\n          <ContextMenuSubMenu\n            label={`${intl.formatMessage({ id: 'copy.as' })}...`}\n            size=\"small\"\n            id=\"TD-ContextMenu-Copy-As\"\n          >\n            <CMRowButton onClick={handleCopySVG} id=\"TD-ContextMenu-Copy-as-SVG\">\n              SVG\n            </CMRowButton>\n            <CMRowButton onClick={handleCopyPNG} id=\"TD-ContextMenu-Copy-As-PNG\">\n              PNG\n            </CMRowButton>\n            {isDebugMode && (\n              <CMRowButton onClick={handleCopyJSON} id=\"TD-ContextMenu-Copy_as_JSON\">\n                JSON\n              </CMRowButton>\n            )}\n          </ContextMenuSubMenu>\n          <ContextMenuSubMenu\n            label={`${intl.formatMessage({ id: 'export.as' })}...`}\n            size=\"small\"\n            id=\"TD-ContextMenu-Export\"\n          >\n            <CMRowButton onClick={handleExportSVG} id=\"TD-ContextMenu-Export-SVG\">\n              SVG\n            </CMRowButton>\n            <CMRowButton onClick={handleExportPNG} id=\"TD-ContextMenu-Export-PNG\">\n              PNG\n            </CMRowButton>\n            <CMRowButton onClick={handleExportJPG} id=\"TD-ContextMenu-Export-JPG\">\n              JPG\n            </CMRowButton>\n            <CMRowButton onClick={handleExportWEBP} id=\"TD-ContextMenu-Export-WEBP\">\n              WEBP\n            </CMRowButton>\n            {isDebugMode && (\n              <CMRowButton onClick={handleExportJSON} id=\"TD-ContextMenu-Export-JSON\">\n                JSON\n              </CMRowButton>\n            )}\n          </ContextMenuSubMenu>\n          <Divider />\n          <CMRowButton onClick={handleDelete} kbd=\"\u232B\" id=\"TD-ContextMenu-Delete\">\n            <FormattedMessage id=\"delete\" />\n          </CMRowButton>\n        </>\n      ) : (\n        <>\n          <CMRowButton onClick={handlePaste} kbd=\"#V\" id=\"TD-ContextMenu-Paste\">\n            <FormattedMessage id=\"paste\" />\n          </CMRowButton>\n          <CMRowButton onClick={handleUndo} kbd=\"#Z\" id=\"TD-ContextMenu-Undo\">\n            <FormattedMessage id=\"undo\" />\n          </CMRowButton>\n          <CMRowButton onClick={handleRedo} kbd=\"#\u21E7Z\" id=\"TD-ContextMenu-Redo\">\n            <FormattedMessage id=\"redo\" />\n          </CMRowButton>\n        </>\n      )}\n    </>\n  )\n})\n\n/* ---------- Align and Distribute Sub Menu --------- */\n\nfunction AlignDistributeSubMenu({\n  hasThreeOrMore,\n}: {\n  hasTwoOrMore: boolean\n  hasThreeOrMore: boolean\n}) {\n  const app = useTldrawApp()\n\n  const alignTop = React.useCallback(() => {\n    app.align(AlignType.Top)\n  }, [app])\n\n  const alignCenterVertical = React.useCallback(() => {\n    app.align(AlignType.CenterVertical)\n  }, [app])\n\n  const alignBottom = React.useCallback(() => {\n    app.align(AlignType.Bottom)\n  }, [app])\n\n  const stretchVertically = React.useCallback(() => {\n    app.stretch(StretchType.Vertical)\n  }, [app])\n\n  const distributeVertically = React.useCallback(() => {\n    app.distribute(DistributeType.Vertical)\n  }, [app])\n\n  const alignLeft = React.useCallback(() => {\n    app.align(AlignType.Left)\n  }, [app])\n\n  const alignCenterHorizontal = React.useCallback(() => {\n    app.align(AlignType.CenterHorizontal)\n  }, [app])\n\n  const alignRight = React.useCallback(() => {\n    app.align(AlignType.Right)\n  }, [app])\n\n  const stretchHorizontally = React.useCallback(() => {\n    app.stretch(StretchType.Horizontal)\n  }, [app])\n\n  const distributeHorizontally = React.useCallback(() => {\n    app.distribute(DistributeType.Horizontal)\n  }, [app])\n\n  const container = useContainer()\n\n  return (\n    <RadixContextMenu.Sub>\n      <CMSubTriggerButton id=\"TD-ContextMenu-Align-Distribute-Trigger\">\n        <FormattedMessage id=\"align.distribute\" />\n      </CMSubTriggerButton>\n      <RadixContextMenu.Portal container={container.current}>\n        <RadixContextMenu.SubContent asChild sideOffset={4} alignOffset={-2}>\n          <StyledGridContent numberOfSelected={hasThreeOrMore ? 'threeOrMore' : 'twoOrMore'}>\n            <CMIconButton onClick={alignLeft} id=\"TD-ContextMenu-Align_Distribute-AlignLeft\">\n              <AlignLeftIcon />\n            </CMIconButton>\n            <CMIconButton\n              onClick={alignCenterHorizontal}\n              id=\"TD-ContextMenu-Align_Distribute-AlignCenterHorizontal\"\n            >\n              <AlignCenterHorizontallyIcon />\n            </CMIconButton>\n            <CMIconButton onClick={alignRight} id=\"TD-ContextMenu-Align_Distribute-AlignRight\">\n              <AlignRightIcon />\n            </CMIconButton>\n            <CMIconButton\n              onClick={stretchHorizontally}\n              id=\"TD-ContextMenu-Align_Distribute-StretchHorizontal\"\n            >\n              <StretchHorizontallyIcon />\n            </CMIconButton>\n            {hasThreeOrMore && (\n              <CMIconButton\n                onClick={distributeHorizontally}\n                id=\"TD-ContextMenu-Align_Distribute-SpaceEvenlyHorizontal\"\n              >\n                <SpaceEvenlyHorizontallyIcon />\n              </CMIconButton>\n            )}\n            <CMIconButton onClick={alignTop} id=\"TD-ContextMenu-Align_Distribute-AlignTop\">\n              <AlignTopIcon />\n            </CMIconButton>\n            <CMIconButton\n              onClick={alignCenterVertical}\n              id=\"TD-ContextMenu-Align_Distribute-AlignCenterVertical\"\n            >\n              <AlignCenterVerticallyIcon />\n            </CMIconButton>\n            <CMIconButton onClick={alignBottom} id=\"TD-ContextMenu-Align_Distribute-AlignBottom\">\n              <AlignBottomIcon />\n            </CMIconButton>\n            <CMIconButton\n              onClick={stretchVertically}\n              id=\"TD-ContextMenu-Align_Distribute-StretchVertical\"\n            >\n              <StretchVerticallyIcon />\n            </CMIconButton>\n            {hasThreeOrMore && (\n              <CMIconButton\n                onClick={distributeVertically}\n                id=\"TD-ContextMenu-Align_Distribute-SpaceEvenlyVertical\"\n              >\n                <SpaceEvenlyVerticallyIcon />\n              </CMIconButton>\n            )}\n            <CMArrow offset={13} />\n          </StyledGridContent>\n        </RadixContextMenu.SubContent>\n      </RadixContextMenu.Portal>\n    </RadixContextMenu.Sub>\n  )\n}\n\nconst StyledGridContent = styled(MenuContent, {\n  display: 'grid',\n  variants: {\n    numberOfSelected: {\n      threeOrMore: {\n        gridTemplateColumns: 'repeat(5, auto)',\n      },\n      twoOrMore: {\n        gridTemplateColumns: 'repeat(4, auto)',\n      },\n    },\n  },\n})\n\n/* -------------- Move to Page Sub Menu ------------- */\n\nconst currentPageIdSelector = (s: TDSnapshot) => s.appState.currentPageId\nconst documentPagesSelector = (s: TDSnapshot) => s.document.pages\n\nfunction MoveToPageMenu() {\n  const app = useTldrawApp()\n  const currentPageId = app.useStore(currentPageIdSelector)\n  const documentPages = app.useStore(documentPagesSelector)\n\n  const sorted = Object.values(documentPages)\n    .sort((a, b) => (a.childIndex || 0) - (b.childIndex || 0))\n    .filter((a) => a.id !== currentPageId)\n\n  const container = useContainer()\n\n  if (sorted.length === 0) return null\n\n  return (\n    <RadixContextMenu.Sub>\n      <CMSubTriggerButton>\n        <FormattedMessage id=\"move.to.page\" />\n      </CMSubTriggerButton>\n      <RadixContextMenu.Portal container={container.current}>\n        <RadixContextMenu.SubContent sideOffset={4} alignOffset={-2} asChild>\n          <MenuContent>\n            {sorted.map(({ id, name }, i) => (\n              <CMRowButton\n                key={id}\n                disabled={id === currentPageId}\n                onClick={() => app.moveToPage(id)}\n              >\n                {name || `Page ${i}`}\n              </CMRowButton>\n            ))}\n            <CMArrow offset={13} />\n          </MenuContent>\n        </RadixContextMenu.SubContent>\n      </RadixContextMenu.Portal>\n    </RadixContextMenu.Sub>\n  )\n}\n\n/* --------------------- Submenu -------------------- */\n\nexport interface ContextMenuSubMenuProps {\n  label: string\n  size?: 'small'\n  children: React.ReactNode\n  id?: string\n}\n\nexport function ContextMenuSubMenu({ children, label, size, id }: ContextMenuSubMenuProps) {\n  const container = useContainer()\n  return (\n    <RadixContextMenu.Sub>\n      <CMSubTriggerButton>{label}</CMSubTriggerButton>\n      <RadixContextMenu.Portal container={container.current}>\n        <RadixContextMenu.SubContent sideOffset={4} alignOffset={-2} asChild>\n          <MenuContent size={size}>\n            {children}\n            <CMArrow offset={13} />\n          </MenuContent>\n        </RadixContextMenu.SubContent>\n      </RadixContextMenu.Portal>\n    </RadixContextMenu.Sub>\n  )\n}\n\n/* ---------------------- Arrow --------------------- */\n\nconst CMArrow = styled(RadixContextMenu.ContextMenuArrow, {\n  fill: '$panel',\n})\n\n/* ------------------- IconButton ------------------- */\n\nfunction CMIconButton({ onSelect, ...rest }: ToolButtonProps) {\n  return (\n    <RadixContextMenu.ContextMenuItem dir=\"ltr\" onSelect={onSelect} asChild>\n      <ToolButton {...rest} />\n    </RadixContextMenu.ContextMenuItem>\n  )\n}\n\n/* -------------------- RowButton ------------------- */\n\nconst CMRowButton = ({ id, ...rest }: RowButtonProps) => {\n  return (\n    <RadixContextMenu.ContextMenuItem asChild id={id}>\n      <RowButton {...rest} />\n    </RadixContextMenu.ContextMenuItem>\n  )\n}\n\n/* ----------------- Trigger Button ----------------- */\n\nexport const CMSubTriggerButton = ({ id, ...rest }: RowButtonProps) => {\n  return (\n    <RadixContextMenu.SubTrigger asChild id={id}>\n      <RowButton hasArrow {...rest} />\n    </RadixContextMenu.SubTrigger>\n  )\n}\n\nexport const ContextMenu = React.memo(_ContextMenu)\n", "import { createStitches, defaultThemeMap } from '@stitches/react'\n\nconst { styled, createTheme } = createStitches({\n  themeMap: {\n    ...defaultThemeMap,\n  },\n  theme: {\n    colors: {\n      bounds: 'rgba(65, 132, 244, 1.000)',\n      boundsBg: 'rgba(65, 132, 244, 0.05)',\n      hover: '#ececec',\n      overlay: 'rgba(0, 0, 0, 0.15)',\n      overlayContrast: 'rgba(255, 255, 255, 0.15)',\n      panel: '#fefefe',\n      panelContrast: '#ffffff',\n      selected: 'rgba(66, 133, 244, 1.000)',\n      selectedContrast: '#fefefe',\n      text: '#333333',\n      tooltip: '#1d1d1d',\n      tooltipContrast: '#ffffff',\n      warn: 'rgba(255, 100, 100, 1)',\n      canvas: 'rgb(248, 249, 250)',\n    },\n    shadows: {\n      2: '0px 1px 1px rgba(0, 0, 0, 0.14)',\n      3: '0px 2px 3px rgba(0, 0, 0, 0.14)',\n      4: '0px 4px 5px -1px rgba(0, 0, 0, 0.14)',\n      8: '0px 12px 17px rgba(0, 0, 0, 0.14)',\n      12: '0px 12px 17px rgba(0, 0, 0, 0.14)',\n      24: '0px 24px 38px rgba(0, 0, 0, 0.14)',\n      key: '1px 1px rgba(0,0,0,1)',\n      panel: `0px 0px 16px -1px rgba(0, 0, 0, 0.05), \n        0px 0px 16px -8px rgba(0, 0, 0, 0.05), \n        0px 0px 16px -12px rgba(0, 0, 0, 0.12),\n        0px 0px 2px 0px rgba(0, 0, 0, 0.08)`,\n    },\n    space: {\n      0: '2px',\n      1: '3px',\n      2: '4px',\n      3: '8px',\n      4: '12px',\n      5: '16px',\n      6: '32px',\n      7: '48px',\n    },\n    fontSizes: {\n      0: '10px',\n      1: '12px',\n      2: '13px',\n      3: '16px',\n      4: '18px',\n    },\n    fonts: {\n      ui: '\"Recursive\", system-ui, sans-serif',\n      body: '\"Recursive\", system-ui, sans-serif',\n      mono: '\"Recursive Mono\", monospace',\n    },\n    fontWeights: {},\n    lineHeights: {},\n    letterSpacings: {},\n    sizes: {},\n    borderWidths: {\n      0: '$1',\n    },\n    borderStyles: {},\n    radii: {\n      0: '2px',\n      1: '4px',\n      2: '8px',\n      3: '12px',\n      4: '16px',\n    },\n    zIndices: {},\n    transitions: {},\n  },\n  media: {\n    micro: '(max-width: 370px)',\n    sm: '(min-width: 640px)',\n    md: '(min-width: 768px)',\n    lg: '(min-width: 1024px)',\n  },\n  utils: {\n    zStrokeWidth: () => (value: number | number[]) => {\n      if (Array.isArray(value)) {\n        return {\n          strokeWidth: `calc(${value[0]}px / var(--camera-zoom))`,\n        }\n      }\n\n      return {\n        strokeWidth: `calc(${value}px / var(--camera-zoom))`,\n      }\n    },\n  },\n})\n\nexport const dark = createTheme({\n  colors: {\n    bounds: 'rgba(38, 150, 255, 1.000)',\n    boundsBg: 'rgba(38, 150, 255, 0.05)',\n    hover: '#444A50',\n    overlay: 'rgba(0, 0, 0, 0.15)',\n    overlayContrast: 'rgba(255, 255, 255, 0.15)',\n    panel: '#363D44',\n    panelContrast: '#49555f',\n    selected: 'rgba(38, 150, 255, 1.000)',\n    selectedContrast: '#fefefe',\n    text: '#f8f9fa',\n    tooltip: '#1d1d1d',\n    tooltipContrast: '#ffffff',\n    canvas: '#212529',\n  },\n  shadows: {\n    2: '0px 1px 1px rgba(0, 0, 0, 0.24)',\n    3: '0px 2px 3px rgba(0, 0, 0, 0.24)',\n    4: '0px 4px 5px -1px rgba(0, 0, 0, 0.24)',\n    8: '0px 12px 17px rgba(0, 0, 0, 0.24)',\n    12: '0px 12px 17px rgba(0, 0, 0, 0.24)',\n    24: '0px 24px 38px rgba(0, 0, 0, 0.24)',\n    panel: `0px 0px 16px -1px rgba(0, 0, 0, 0.05), \n      0px 0px 16px -8px rgba(0, 0, 0, 0.09), \n      0px 0px 16px -12px rgba(0, 0, 0, 0.2)`,\n  },\n})\n\nexport { styled }\n", "import { styled } from '~styles'\n\nexport const Divider = styled('hr', {\n  height: 0,\n  paddingTop: 1,\n  width: 'calc(100%+8px)',\n  backgroundColor: '$hover',\n  border: 'none',\n  margin: '$2 -4px',\n})\n", "import { styled } from '~styles'\n\nexport const MenuContent = styled('div', {\n  position: 'relative',\n  overflow: 'hidden',\n  userSelect: 'none',\n  display: 'flex',\n  flexDirection: 'column',\n  zIndex: 99997,\n  minWidth: 180,\n  pointerEvents: 'all',\n  backgroundColor: '$panel',\n  border: '1px solid $panelContrast',\n  boxShadow: '$panel',\n  padding: '$2 $2',\n  borderRadius: '$3',\n  font: '$ui',\n  maxHeight: '100vh',\n  overflowY: 'auto',\n  overflowX: 'hidden',\n  '&::webkit-scrollbar': {\n    display: 'none',\n  },\n  '-ms-overflow-style': 'none' /* for Internet Explorer, Edge */,\n  scrollbarWidth: 'none',\n  variants: {\n    size: {\n      small: {\n        minWidth: 72,\n      },\n    },\n    overflow: {\n      true: {\n        maxHeight: '60vh',\n      },\n    },\n  },\n})\n", "import { ItemIndicator } from '@radix-ui/react-dropdown-menu'\nimport { CheckIcon, ChevronRightIcon } from '@radix-ui/react-icons'\nimport * as React from 'react'\nimport { Kbd } from '~components/Primitives/Kbd'\nimport { SmallIcon } from '~components/Primitives/SmallIcon'\nimport { breakpoints } from '~components/breakpoints'\nimport { styled } from '~styles'\n\nexport interface RowButtonProps {\n  onClick?: React.MouseEventHandler<HTMLButtonElement>\n  children: React.ReactNode\n  disabled?: boolean\n  kbd?: string\n  variant?: 'wide' | 'styleMenu'\n  isActive?: boolean\n  isWarning?: boolean\n  hasIndicator?: boolean\n  hasArrow?: boolean\n  id?: string\n}\n\nexport const RowButton = React.forwardRef<HTMLButtonElement, RowButtonProps>(\n  (\n    {\n      onClick,\n      isActive = false,\n      isWarning = false,\n      hasIndicator = false,\n      hasArrow = false,\n      disabled = false,\n      variant,\n      kbd,\n      children,\n      ...rest\n    },\n    ref\n  ) => {\n    return (\n      <StyledRowButton\n        ref={ref}\n        bp={breakpoints}\n        isWarning={isWarning}\n        isActive={isActive}\n        disabled={disabled}\n        onClick={onClick}\n        variant={variant}\n        {...rest}\n      >\n        <StyledRowButtonInner>\n          {children}\n          {kbd ? <Kbd variant=\"menu\">{kbd}</Kbd> : undefined}\n          {hasIndicator && (\n            <ItemIndicator dir=\"ltr\">\n              <SmallIcon>\n                <CheckIcon />\n              </SmallIcon>\n            </ItemIndicator>\n          )}\n          {hasArrow && (\n            <SmallIcon>\n              <ChevronRightIcon />\n            </SmallIcon>\n          )}\n        </StyledRowButtonInner>\n      </StyledRowButton>\n    )\n  }\n)\n\nconst StyledRowButtonInner = styled('div', {\n  height: '100%',\n  width: '100%',\n  backgroundColor: '$panel',\n  borderRadius: '$2',\n  display: 'flex',\n  gap: '$1',\n  flexDirection: 'row',\n  alignItems: 'center',\n  padding: '0 $3',\n  justifyContent: 'space-between',\n  border: '1px solid transparent',\n\n  '& svg': {\n    position: 'relative',\n    stroke: '$overlay',\n    strokeWidth: 1,\n    zIndex: 1,\n  },\n\n  [`& > ${SmallIcon}`]: {\n    paddingLeft: '$3',\n  },\n})\n\nexport const StyledRowButton = styled('button', {\n  position: 'relative',\n  width: '100%',\n  background: 'none',\n  border: 'none',\n  cursor: 'pointer',\n  height: 32,\n  minHeight: 32,\n  outline: 'none',\n  color: '$text',\n  fontFamily: '$ui',\n  fontWeight: 400,\n  fontSize: '$1',\n  borderRadius: 4,\n  userSelect: 'none',\n  margin: 0,\n  padding: '0 0',\n\n  '&[data-disabled]': {\n    opacity: 0.3,\n  },\n\n  '&:disabled': {\n    opacity: 0.3,\n  },\n\n  [`&:focus:not(:disabled) ${StyledRowButtonInner}`]: {\n    backgroundColor: '$hover',\n  },\n\n  '& a': {\n    textDecoration: 'none',\n    color: '$text',\n  },\n\n  variants: {\n    bp: {\n      mobile: {},\n      small: {},\n    },\n    variant: {\n      styleMenu: {\n        margin: '$1 0 $1 0',\n      },\n      wide: {\n        gridColumn: '1 / span 4',\n      },\n    },\n    size: {\n      icon: {\n        padding: '4px ',\n        width: 'auto',\n      },\n    },\n    isWarning: {\n      true: {\n        color: '$warn',\n      },\n    },\n    isActive: {\n      true: {\n        backgroundColor: '$hover',\n      },\n      false: {},\n    },\n  },\n})\n", "import { Utils } from '@tldraw/core'\nimport * as React from 'react'\nimport { styled } from '~styles'\n\n/* -------------------------------------------------- */\n/*                  Keyboard Shortcut                 */\n/* -------------------------------------------------- */\n\nconst commandKey = () => (Utils.isDarwin() ? '\u2318' : 'Ctrl')\n\nexport function Kbd({ variant, children }: { variant: 'tooltip' | 'menu'; children: string }) {\n  return (\n    <StyledKbd variant={variant}>\n      {children.split('').map((k, i) => {\n        return <span key={i}>{k.replace('#', commandKey())}</span>\n      })}\n    </StyledKbd>\n  )\n}\n\nexport const StyledKbd = styled('kbd', {\n  marginLeft: '$3',\n  textShadow: '$2',\n  textAlign: 'center',\n  fontSize: '$0',\n  fontFamily: '$ui',\n  color: '$text',\n  background: 'none',\n  fontWeight: 400,\n  gap: '$1',\n  display: 'flex',\n  alignItems: 'center',\n\n  '& > span': {\n    padding: '$0',\n    borderRadius: '$0',\n    display: 'flex',\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n\n  variants: {\n    variant: {\n      tooltip: {\n        '& > span': {\n          color: '$tooltipContrast',\n          background: '$overlayContrast',\n          boxShadow: '$key',\n          width: '20px',\n          height: '20px',\n        },\n      },\n      menu: {},\n    },\n  },\n})\n", "import { styled } from '~styles'\n\nexport const SmallIcon = styled('div', {\n  height: '100%',\n  borderRadius: '4px',\n  marginRight: '1px',\n  width: 'fit-content',\n  display: 'grid',\n  alignItems: 'center',\n  justifyContent: 'center',\n  outline: 'none',\n  border: 'none',\n  pointerEvents: 'all',\n  cursor: 'pointer',\n  color: 'currentColor',\n\n  '& svg': {\n    height: 16,\n    width: 16,\n    strokeWidth: 1,\n  },\n\n  '& > *': {\n    gridRow: 1,\n    gridColumn: 1,\n  },\n})\n", "/* -------------------------------------------------- */\n/*                     Breakpoints                    */\n/* -------------------------------------------------- */\n\nexport const breakpoints: any = {\n  '@initial': 'mobile',\n  '@micro': 'micro',\n  '@sm': 'small',\n  '@md': 'medium',\n  '@lg': 'large',\n}\n", "import * as React from 'react'\nimport { Tooltip } from '~components/Primitives/Tooltip'\nimport { breakpoints } from '~components/breakpoints'\nimport { useTldrawApp } from '~hooks'\nimport { styled } from '~styles'\n\nexport interface ToolButtonProps {\n  onClick?: () => void\n  onSelect?: () => void\n  onDoubleClick?: () => void\n  disabled?: boolean\n  isActive?: boolean\n  isToolLocked?: boolean\n  variant?: 'icon' | 'text' | 'circle' | 'primary'\n  children: React.ReactNode\n  id?: string\n  onKeyDown?: React.KeyboardEventHandler<HTMLButtonElement>\n}\n\nexport const ToolButton = React.forwardRef<HTMLButtonElement, ToolButtonProps>(\n  (\n    {\n      onSelect,\n      onClick,\n      onDoubleClick,\n      variant,\n      children,\n      isToolLocked = false,\n      disabled = false,\n      isActive = false,\n      onKeyDown,\n      id,\n      ...rest\n    },\n    ref\n  ) => {\n    return (\n      <StyledToolButton\n        ref={ref}\n        isActive={isActive}\n        variant={variant}\n        onClick={onClick}\n        disabled={disabled}\n        onPointerDown={onSelect}\n        onDoubleClick={onDoubleClick}\n        onKeyDown={onKeyDown}\n        bp={breakpoints}\n        id={id}\n        {...rest}\n      >\n        <StyledToolButtonInner>{children}</StyledToolButtonInner>\n        {isToolLocked && <ToolLockIndicator />}\n      </StyledToolButton>\n    )\n  }\n)\n\n/* ------------------ With Tooltip ------------------ */\n\ninterface ToolButtonWithTooltipProps extends ToolButtonProps {\n  label: string\n  isLocked?: boolean\n  kbd?: string\n}\n\nexport function ToolButtonWithTooltip({\n  label,\n  kbd,\n  isLocked,\n  ...rest\n}: ToolButtonWithTooltipProps) {\n  const app = useTldrawApp()\n\n  const handleDoubleClick = React.useCallback(() => {\n    app.toggleToolLock()\n  }, [])\n\n  const handleKeyDown = React.useCallback((e: React.KeyboardEvent<HTMLButtonElement>) => {\n    if (e.key === ' ' && app.isForcePanning) {\n      e.preventDefault()\n    }\n  }, [])\n\n  return (\n    <Tooltip label={label[0].toUpperCase() + label.slice(1)} kbd={kbd}>\n      <ToolButton\n        {...rest}\n        variant=\"primary\"\n        isToolLocked={isLocked && rest.isActive}\n        onDoubleClick={handleDoubleClick}\n        onKeyDown={handleKeyDown}\n        aria-label={label[0].toUpperCase() + label.slice(1)}\n      />\n    </Tooltip>\n  )\n}\n\nexport const StyledToolButtonInner = styled('div', {\n  position: 'relative',\n  height: '100%',\n  width: '100%',\n  backgroundColor: '$panel',\n  borderRadius: '$2',\n  margin: '0',\n  display: 'flex',\n  alignItems: 'center',\n  justifyContent: 'center',\n  fontFamily: '$ui',\n  color: 'inherit',\n  userSelect: 'none',\n  boxSizing: 'border-box',\n  border: '1px solid transparent',\n  '-webkit-tap-highlight-color': 'transparent',\n  'tap-highlight-color': 'transparent',\n})\n\nexport const StyledToolButton = styled('button', {\n  position: 'relative',\n  color: '$text',\n  fontSize: '$0',\n  background: 'none',\n  margin: '0',\n  padding: '$2',\n  display: 'flex',\n  alignItems: 'center',\n  justifyContent: 'center',\n  outline: 'none',\n  cursor: 'pointer',\n  pointerEvents: 'all',\n  height: '40px',\n  width: '40px',\n  border: '1px solid $panel',\n  '-webkit-tap-highlight-color': 'transparent',\n  'tap-highlight-color': 'transparent',\n\n  [`&:disabled ${StyledToolButtonInner}`]: {\n    opacity: 0.618,\n  },\n\n  variants: {\n    variant: {\n      primary: {\n        marginTop: '0',\n      },\n      icon: {\n        [`& ${StyledToolButtonInner}`]: {\n          display: 'grid',\n          '& > *': {\n            gridRow: 1,\n            gridColumn: 1,\n          },\n        },\n      },\n      text: {\n        width: 'auto',\n        [`& ${StyledToolButtonInner}`]: {\n          fontSize: '$1',\n          padding: '0 $3',\n          gap: '$3',\n        },\n      },\n      circle: {\n        padding: 0,\n        height: 32,\n        width: 32,\n        border: 'none',\n        [`& ${StyledToolButtonInner}`]: {\n          border: '1px solid $panelContrast',\n          borderRadius: '100%',\n          boxShadow: '$panel',\n        },\n        [`& ${StyledToolButtonInner} > svg`]: {\n          width: 14,\n          height: 14,\n        },\n      },\n    },\n    isActive: {\n      true: {},\n      false: {},\n    },\n    bp: {\n      mobile: {\n        padding: 0,\n      },\n      small: {},\n    },\n  },\n  compoundVariants: [\n    {\n      variant: 'primary',\n      bp: 'mobile',\n      css: {\n        height: 40,\n        width: 36,\n        [`& ${StyledToolButtonInner} > svg`]: {\n          width: 16,\n          height: 16,\n        },\n      },\n    },\n    {\n      variant: 'primary',\n      bp: 'small',\n      css: {\n        height: '44px',\n        width: '44px',\n        [`& ${StyledToolButtonInner} > svg`]: {\n          width: 20,\n          height: 20,\n        },\n      },\n    },\n    {\n      isActive: true,\n      css: {\n        [`${StyledToolButtonInner}`]: {\n          backgroundColor: '$selected',\n          color: '$selectedContrast',\n        },\n      },\n    },\n    {\n      isActive: false,\n      bp: 'small',\n      css: {\n        [`&:hover:not(:disabled) ${StyledToolButtonInner}`]: {\n          backgroundColor: '$hover',\n        },\n        [`&:focus:not(:disabled) ${StyledToolButtonInner}`]: {\n          backgroundColor: '$hover',\n        },\n      },\n    },\n  ],\n})\n\nconst ToolLockIndicator = styled('div', {\n  position: 'absolute',\n  width: 10,\n  height: 10,\n  backgroundColor: '$selected',\n  borderRadius: '100%',\n  bottom: -2,\n  border: '2px solid $panel',\n  zIndex: 100,\n})\n", "import * as RadixTooltip from '@radix-ui/react-tooltip'\nimport * as React from 'react'\nimport { Kbd } from '~components/Primitives/Kbd'\nimport { styled } from '~styles'\n\n/* -------------------------------------------------- */\n/*                       Tooltip                      */\n/* -------------------------------------------------- */\n\ninterface TooltipProps {\n  children: React.ReactNode\n  label: string\n  kbd?: string\n  id?: string\n  side?: 'bottom' | 'left' | 'right' | 'top'\n}\n\nexport function Tooltip({ children, label, kbd: kbdProp, id, side = 'top' }: TooltipProps) {\n  return (\n    <span id={id}>\n      <RadixTooltip.Provider>\n        <RadixTooltip.Root>\n          <RadixTooltip.Trigger dir=\"ltr\" asChild={true}>\n            <span>{children}</span>\n          </RadixTooltip.Trigger>\n          <StyledContent dir=\"ltr\" side={side} sideOffset={8}>\n            {label}\n            {kbdProp ? <Kbd variant=\"tooltip\">{kbdProp}</Kbd> : null}\n            <StyledArrow />\n          </StyledContent>\n        </RadixTooltip.Root>\n      </RadixTooltip.Provider>\n    </span>\n  )\n}\n\nconst StyledContent = styled(RadixTooltip.Content, {\n  borderRadius: 3,\n  padding: '$3 $3 $3 $3',\n  fontSize: '$1',\n  backgroundColor: '$tooltip',\n  color: '$tooltipContrast',\n  boxShadow: '$3',\n  display: 'flex',\n  alignItems: 'center',\n  fontFamily: '$ui',\n  userSelect: 'none',\n})\n\nconst StyledArrow = styled(RadixTooltip.Arrow, {\n  fill: '$tooltip',\n  margin: '0 8px',\n})\n", "import * as React from 'react'\nimport type { TldrawApp } from '~state'\nimport { DialogState } from './useDialog'\n\nexport function useFileSystem() {\n  const onNewProject = React.useCallback(\n    async (\n      app: TldrawApp,\n      openDialog: (\n        dialogState: DialogState,\n        onYes: () => Promise<void>,\n        onNo: () => Promise<void>,\n        onCancel: () => Promise<void>\n      ) => void\n    ) => {\n      openDialog(\n        app.fileSystemHandle ? 'saveFirstTime' : 'saveAgain',\n        async () => {\n          // user pressed yes\n          try {\n            await app.saveProject()\n            app.newProject()\n          } catch (e) {\n            // noop\n          }\n        },\n        async () => {\n          // user pressed no\n          app.newProject()\n        },\n        async () => {\n          // user pressed cancel\n        }\n      )\n    },\n    []\n  )\n\n  const onOpenProject = React.useCallback(\n    async (\n      app: TldrawApp,\n      openDialog: (\n        dialogState: DialogState,\n        onYes: () => Promise<void>,\n        onNo: () => Promise<void>,\n        onCancel: () => Promise<void>\n      ) => void\n    ) => {\n      openDialog(\n        app.fileSystemHandle ? 'saveFirstTime' : 'saveAgain',\n        async () => {\n          // user pressed yes\n          try {\n            await app.saveProject()\n            await app.openProject()\n          } catch (e) {\n            // noop\n          }\n        },\n        async () => {\n          // user pressed no\n          app.openProject()\n        },\n        async () => {\n          // user pressed cancel\n        }\n      )\n    },\n    []\n  )\n\n  const onSaveProject = React.useCallback((app: TldrawApp) => {\n    app.saveProject()\n  }, [])\n\n  const onSaveProjectAs = React.useCallback((app: TldrawApp) => {\n    app.saveProjectAs()\n  }, [])\n\n  const onOpenMedia = React.useCallback(async (app: TldrawApp) => {\n    app.openAsset?.()\n  }, [])\n\n  return {\n    onNewProject,\n    onSaveProject,\n    onSaveProjectAs,\n    onOpenProject,\n    onOpenMedia,\n  }\n}\n", "import * as React from 'react'\nimport { useDialog, useTldrawApp } from '~hooks'\n\nexport function useFileSystemHandlers() {\n  const app = useTldrawApp()\n\n  const { openDialog } = useDialog()\n\n  const onNewProject = React.useCallback(\n    async (e?: React.MouseEvent | React.KeyboardEvent | KeyboardEvent) => {\n      if (e && app.callbacks.onOpenProject) e.preventDefault()\n      app.callbacks.onNewProject?.(app, openDialog)\n    },\n    [app, openDialog]\n  )\n\n  const onSaveProject = React.useCallback(\n    (e?: React.MouseEvent | React.KeyboardEvent | KeyboardEvent) => {\n      if (e && app.callbacks.onOpenProject) e.preventDefault()\n      app.callbacks.onSaveProject?.(app)\n    },\n    [app]\n  )\n\n  const onSaveProjectAs = React.useCallback(\n    (e?: React.MouseEvent | React.KeyboardEvent | KeyboardEvent) => {\n      if (e && app.callbacks.onOpenProject) e.preventDefault()\n      app.callbacks.onSaveProjectAs?.(app)\n    },\n    [app]\n  )\n\n  const onOpenProject = React.useCallback(\n    async (e?: React.MouseEvent | React.KeyboardEvent | KeyboardEvent) => {\n      if (e && app.callbacks.onOpenProject) e.preventDefault()\n      app.callbacks.onOpenProject?.(app, openDialog)\n    },\n    [app, openDialog]\n  )\n\n  const onOpenMedia = React.useCallback(\n    async (e?: React.MouseEvent | React.KeyboardEvent | KeyboardEvent) => {\n      if (e && app.callbacks.onOpenMedia) e.preventDefault()\n      app.callbacks.onOpenMedia?.(app)\n    },\n    [app]\n  )\n\n  return {\n    onNewProject,\n    onSaveProject,\n    onSaveProjectAs,\n    onOpenProject,\n    onOpenMedia,\n  }\n}\n", "import * as React from 'react'\nimport { useHotkeys } from 'react-hotkeys-hook'\nimport { useFileSystemHandlers, useTldrawApp } from '~hooks'\nimport { AlignStyle, TDShapeType } from '~types'\n\nexport function useKeyboardShortcuts(ref: React.RefObject<HTMLDivElement>) {\n  const app = useTldrawApp()\n\n  const canHandleEvent = React.useCallback(\n    (ignoreMenus = false) => {\n      const elm = ref.current\n      if (ignoreMenus && (app.isMenuOpen || app.settings.keepStyleMenuOpen)) return true\n      elm?.focus()\n      return elm && (document.activeElement === elm || elm.contains(document.activeElement))\n    },\n    [ref]\n  )\n\n  React.useEffect(() => {\n    if (!app) return\n\n    const handleCut = (e: ClipboardEvent) => {\n      if (!canHandleEvent(true)) return\n\n      if (app.readOnly) {\n        app.copy(undefined, e)\n        return\n      }\n\n      app.cut(undefined, e)\n    }\n\n    const handleCopy = (e: ClipboardEvent) => {\n      if (!canHandleEvent(true)) return\n\n      app.copy(undefined, e)\n    }\n\n    const handlePaste = (e: ClipboardEvent) => {\n      if (!canHandleEvent(true)) return\n      if (app.readOnly) return\n\n      app.paste(undefined, e)\n    }\n\n    document.addEventListener('cut', handleCut)\n    document.addEventListener('copy', handleCopy)\n    document.addEventListener('paste', handlePaste)\n    return () => {\n      document.removeEventListener('cut', handleCut)\n      document.removeEventListener('copy', handleCopy)\n      document.removeEventListener('paste', handlePaste)\n    }\n  }, [app])\n\n  /* ---------------------- Tools --------------------- */\n\n  useHotkeys(\n    'v,1',\n    () => {\n      if (!canHandleEvent(true)) return\n      app.selectTool('select')\n    },\n    [app, ref.current]\n  )\n\n  useHotkeys(\n    'd,p,2',\n    () => {\n      if (!canHandleEvent(true)) return\n      app.selectTool(TDShapeType.Draw)\n    },\n    undefined,\n    [app]\n  )\n\n  useHotkeys(\n    'e,3',\n    () => {\n      if (!canHandleEvent(true)) return\n      app.selectTool('erase')\n    },\n    undefined,\n    [app]\n  )\n\n  useHotkeys(\n    'r,4',\n    () => {\n      if (!canHandleEvent(true)) return\n      app.selectTool(TDShapeType.Rectangle)\n    },\n    undefined,\n    [app]\n  )\n\n  useHotkeys(\n    'o,5',\n    () => {\n      if (!canHandleEvent(true)) return\n      app.selectTool(TDShapeType.Ellipse)\n    },\n    undefined,\n    [app]\n  )\n\n  useHotkeys(\n    'g,6',\n    () => {\n      if (!canHandleEvent()) return\n      app.selectTool(TDShapeType.Triangle)\n    },\n    undefined,\n    [app]\n  )\n\n  useHotkeys(\n    'l,7',\n    () => {\n      if (!canHandleEvent(true)) return\n      app.selectTool(TDShapeType.Line)\n    },\n    undefined,\n    [app]\n  )\n\n  useHotkeys(\n    'a,8',\n    () => {\n      if (!canHandleEvent(true)) return\n      app.selectTool(TDShapeType.Arrow)\n    },\n    undefined,\n    [app]\n  )\n\n  useHotkeys(\n    't,9',\n    () => {\n      if (!canHandleEvent(true)) return\n      app.selectTool(TDShapeType.Text)\n    },\n    undefined,\n    [app]\n  )\n\n  useHotkeys(\n    's,0',\n    () => {\n      if (!canHandleEvent(true)) return\n      app.selectTool(TDShapeType.Sticky)\n    },\n    undefined,\n    [app]\n  )\n\n  /* ---------------------- Misc ---------------------- */\n\n  // Dark Mode\n\n  useHotkeys(\n    'ctrl+shift+d,\u2318+shift+d',\n    (e) => {\n      if (!canHandleEvent(true)) return\n      app.toggleDarkMode()\n      e.preventDefault()\n    },\n    undefined,\n    [app]\n  )\n\n  // Focus Mode\n\n  useHotkeys(\n    'ctrl+.,\u2318+.',\n    () => {\n      if (!canHandleEvent(true)) return\n      app.toggleFocusMode()\n    },\n    undefined,\n    [app]\n  )\n\n  useHotkeys(\n    'ctrl+shift+g,\u2318+shift+g',\n    () => {\n      if (!canHandleEvent(true)) return\n      app.toggleGrid()\n    },\n    undefined,\n    [app]\n  )\n\n  // File System\n\n  const { onNewProject, onOpenProject, onSaveProject, onSaveProjectAs, onOpenMedia } =\n    useFileSystemHandlers()\n\n  useHotkeys(\n    'ctrl+n,\u2318+n',\n    (e) => {\n      e.preventDefault()\n      if (!canHandleEvent()) return\n      onNewProject(e)\n    },\n    undefined,\n    [app]\n  )\n  useHotkeys(\n    'ctrl+s,\u2318+s',\n    (e) => {\n      if (!canHandleEvent()) return\n\n      onSaveProject(e)\n    },\n    undefined,\n    [app]\n  )\n\n  useHotkeys(\n    'ctrl+shift+s,\u2318+shift+s',\n    (e) => {\n      if (!canHandleEvent()) return\n\n      onSaveProjectAs(e)\n    },\n    undefined,\n    [app]\n  )\n  useHotkeys(\n    'ctrl+o,\u2318+o',\n    (e) => {\n      if (!canHandleEvent()) return\n\n      onOpenProject(e)\n    },\n    undefined,\n    [app]\n  )\n  useHotkeys(\n    'ctrl+u,\u2318+u',\n    (e) => {\n      if (!canHandleEvent()) return\n      onOpenMedia(e)\n    },\n    undefined,\n    [app]\n  )\n\n  // Undo Redo\n\n  useHotkeys(\n    '\u2318+z,ctrl+z',\n    (e) => {\n      e.preventDefault()\n      if (!canHandleEvent(true)) return\n\n      if (app.session) {\n        app.cancelSession()\n      } else {\n        app.undo()\n      }\n    },\n    undefined,\n    [app]\n  )\n\n  useHotkeys(\n    'ctrl+shift+z,\u2318+shift+z',\n    () => {\n      if (!canHandleEvent(true)) return\n\n      if (app.session) {\n        app.cancelSession()\n      } else {\n        app.redo()\n      }\n    },\n    undefined,\n    [app]\n  )\n\n  // Undo Redo\n\n  useHotkeys(\n    '\u2318+u,ctrl+u',\n    () => {\n      if (!canHandleEvent()) return\n      app.undoSelect()\n    },\n    undefined,\n    [app]\n  )\n\n  useHotkeys(\n    'ctrl+shift-u,\u2318+shift+u',\n    () => {\n      if (!canHandleEvent()) return\n      app.redoSelect()\n    },\n    undefined,\n    [app]\n  )\n\n  /* -------------------- Commands -------------------- */\n\n  // Camera\n\n  useHotkeys(\n    'ctrl+=,\u2318+=,ctrl+num_add,\u2318+num_add',\n    (e) => {\n      if (!canHandleEvent(true)) return\n      app.zoomIn()\n      e.preventDefault()\n    },\n    undefined,\n    [app]\n  )\n\n  useHotkeys(\n    'ctrl+-,\u2318+-,ctrl+num_subtract,\u2318+num_subtract',\n    (e) => {\n      if (!canHandleEvent(true)) return\n\n      app.zoomOut()\n      e.preventDefault()\n    },\n    undefined,\n    [app]\n  )\n\n  useHotkeys(\n    'shift+0,ctrl+numpad_0,\u2318+numpad_0',\n    () => {\n      if (!canHandleEvent(true)) return\n      app.resetZoom()\n    },\n    undefined,\n    [app]\n  )\n\n  useHotkeys(\n    'shift+1',\n    () => {\n      if (!canHandleEvent(true)) return\n      app.zoomToFit()\n    },\n    undefined,\n    [app]\n  )\n\n  useHotkeys(\n    'shift+2',\n    () => {\n      if (!canHandleEvent(true)) return\n      app.zoomToSelection()\n    },\n    undefined,\n    [app]\n  )\n\n  // Duplicate\n\n  useHotkeys(\n    'ctrl+d,\u2318+d',\n    (e) => {\n      if (!canHandleEvent()) return\n\n      app.duplicate()\n      e.preventDefault()\n    },\n    undefined,\n    [app]\n  )\n\n  // Flip\n\n  useHotkeys(\n    'shift+h',\n    () => {\n      if (!canHandleEvent(true)) return\n      app.flipHorizontal()\n    },\n    undefined,\n    [app]\n  )\n\n  useHotkeys(\n    'shift+v',\n    () => {\n      if (!canHandleEvent(true)) return\n      app.flipVertical()\n    },\n    undefined,\n    [app]\n  )\n\n  // Cancel\n\n  useHotkeys(\n    'escape',\n    () => {\n      if (!canHandleEvent(true)) return\n\n      app.cancel()\n    },\n    undefined,\n    [app]\n  )\n\n  // Delete\n\n  useHotkeys(\n    'backspace,del',\n    () => {\n      if (!canHandleEvent()) return\n      app.delete()\n    },\n    undefined,\n    [app]\n  )\n\n  // Select All\n\n  useHotkeys(\n    '\u2318+a,ctrl+a',\n    () => {\n      if (!canHandleEvent(true)) return\n      app.selectAll()\n    },\n    undefined,\n    [app]\n  )\n\n  // Nudge\n\n  useHotkeys(\n    'up',\n    () => {\n      if (!canHandleEvent()) return\n      app.nudge([0, -1], false)\n    },\n    undefined,\n    [app]\n  )\n\n  useHotkeys(\n    'right',\n    () => {\n      if (!canHandleEvent()) return\n      app.nudge([1, 0], false)\n    },\n    undefined,\n    [app]\n  )\n\n  useHotkeys(\n    'down',\n    () => {\n      if (!canHandleEvent()) return\n      app.nudge([0, 1], false)\n    },\n    undefined,\n    [app]\n  )\n\n  useHotkeys(\n    'left',\n    () => {\n      if (!canHandleEvent()) return\n      app.nudge([-1, 0], false)\n    },\n    undefined,\n    [app]\n  )\n\n  useHotkeys(\n    'shift+up',\n    () => {\n      if (!canHandleEvent()) return\n      app.nudge([0, -1], true)\n    },\n    undefined,\n    [app]\n  )\n\n  useHotkeys(\n    'shift+right',\n    () => {\n      if (!canHandleEvent()) return\n      app.nudge([1, 0], true)\n    },\n    undefined,\n    [app]\n  )\n\n  useHotkeys(\n    'shift+down',\n    () => {\n      if (!canHandleEvent()) return\n      app.nudge([0, 1], true)\n    },\n    undefined,\n    [app]\n  )\n\n  useHotkeys(\n    'shift+left',\n    () => {\n      if (!canHandleEvent()) return\n      app.nudge([-1, 0], true)\n    },\n    undefined,\n    [app]\n  )\n\n  useHotkeys(\n    '\u2318+shift+l,ctrl+shift+l',\n    () => {\n      if (!canHandleEvent()) return\n      app.toggleLocked()\n    },\n    undefined,\n    [app]\n  )\n\n  // Copy, Cut & Paste\n\n  // useHotkeys(\n  //   '\u2318+c,ctrl+c',\n  //   () => {\n  //     if (!canHandleEvent()) return\n  //     app.copy()\n  //   },\n  //   undefined,\n  //   [app]\n  // )\n\n  useHotkeys(\n    '\u2318+shift+c,ctrl+shift+c',\n    (e) => {\n      if (!canHandleEvent()) return\n\n      app.copySvg()\n      e.preventDefault()\n    },\n    undefined,\n    [app]\n  )\n\n  // useHotkeys(\n  //   '\u2318+x,ctrl+x',\n  //   () => {\n  //     if (!canHandleEvent()) return\n  //     app.cut()\n  //   },\n  //   undefined,\n  //   [app]\n  // )\n\n  // useHotkeys(\n  //   '\u2318+v,ctrl+v',\n  //   () => {\n  //     if (!canHandleEvent()) return\n\n  //     app.paste()\n  //   },\n  //   undefined,\n  //   [app]\n  // )\n\n  // Group & Ungroup\n\n  useHotkeys(\n    '\u2318+g,ctrl+g',\n    (e) => {\n      if (!canHandleEvent()) return\n\n      app.group()\n      e.preventDefault()\n    },\n    undefined,\n    [app]\n  )\n\n  useHotkeys(\n    '\u2318+shift+g,ctrl+shift+g',\n    (e) => {\n      if (!canHandleEvent()) return\n\n      app.ungroup()\n      e.preventDefault()\n    },\n    undefined,\n    [app]\n  )\n\n  // Move\n\n  useHotkeys(\n    '[',\n    () => {\n      if (!canHandleEvent(true)) return\n      app.moveBackward()\n    },\n    undefined,\n    [app]\n  )\n\n  useHotkeys(\n    ']',\n    () => {\n      if (!canHandleEvent(true)) return\n      app.moveForward()\n    },\n    undefined,\n    [app]\n  )\n\n  useHotkeys(\n    'shift+[',\n    () => {\n      if (!canHandleEvent(true)) return\n      app.moveToBack()\n    },\n    undefined,\n    [app]\n  )\n\n  useHotkeys(\n    'shift+]',\n    () => {\n      if (!canHandleEvent(true)) return\n      app.moveToFront()\n    },\n    undefined,\n    [app]\n  )\n\n  useHotkeys(\n    'ctrl+shift+backspace,\u2318+shift+backspace',\n    (e) => {\n      if (!canHandleEvent()) return\n      if (app.settings.isDebugMode) {\n        app.resetDocument()\n      }\n      e.preventDefault()\n    },\n    undefined,\n    [app]\n  )\n\n  // Text Align\n\n  useHotkeys(\n    'alt+command+l,alt+ctrl+l',\n    (e) => {\n      if (!canHandleEvent(true)) return\n      app.style({ textAlign: AlignStyle.Start })\n      e.preventDefault()\n    },\n    undefined,\n    [app]\n  )\n\n  useHotkeys(\n    'alt+command+t,alt+ctrl+t',\n    (e) => {\n      if (!canHandleEvent(true)) return\n      app.style({ textAlign: AlignStyle.Middle })\n      e.preventDefault()\n    },\n    undefined,\n    [app]\n  )\n\n  useHotkeys(\n    'alt+command+r,alt+ctrl+r',\n    (e) => {\n      if (!canHandleEvent(true)) return\n      app.style({ textAlign: AlignStyle.End })\n      e.preventDefault()\n    },\n    undefined,\n    [app]\n  )\n}\n", "import type {\n  TLAsset,\n  TLBinding,\n  TLBoundsCorner,\n  TLBoundsEdge,\n  TLBoundsEventHandler,\n  TLBoundsHandleEventHandler,\n  TLCanvasEventHandler,\n  TLHandle,\n  TLKeyboardEventHandler,\n  TLPage,\n  TLPageState,\n  TLPinchEventHandler,\n  TLPointerEventHandler,\n  TLShape,\n  TLShapeBlurHandler,\n  TLShapeCloneHandler,\n  TLSnapLine,\n  TLUser,\n  TLWheelEventHandler,\n} from '@tldraw/core'\nimport { TDLanguage } from '~translations'\n\n/* -------------------------------------------------- */\n/*                         App                        */\n/* -------------------------------------------------- */\n\n// A base class for all classes that handle events from the Renderer,\n// including TDApp and all Tools.\nexport class TDEventHandler {\n  onPinchStart?: TLPinchEventHandler\n  onPinchEnd?: TLPinchEventHandler\n  onPinch?: TLPinchEventHandler\n  onKeyDown?: TLKeyboardEventHandler\n  onKeyUp?: TLKeyboardEventHandler\n  onPointerMove?: TLPointerEventHandler\n  onPointerUp?: TLPointerEventHandler\n  onPan?: TLWheelEventHandler\n  onZoom?: TLWheelEventHandler\n  onPointerDown?: TLPointerEventHandler\n  onPointCanvas?: TLCanvasEventHandler\n  onDoubleClickCanvas?: TLCanvasEventHandler\n  onRightPointCanvas?: TLCanvasEventHandler\n  onDragCanvas?: TLCanvasEventHandler\n  onReleaseCanvas?: TLCanvasEventHandler\n  onPointShape?: TLPointerEventHandler\n  onDoubleClickShape?: TLPointerEventHandler\n  onRightPointShape?: TLPointerEventHandler\n  onDragShape?: TLPointerEventHandler\n  onHoverShape?: TLPointerEventHandler\n  onUnhoverShape?: TLPointerEventHandler\n  onReleaseShape?: TLPointerEventHandler\n  onPointBounds?: TLBoundsEventHandler\n  onDoubleClickBounds?: TLBoundsEventHandler\n  onRightPointBounds?: TLBoundsEventHandler\n  onDragBounds?: TLBoundsEventHandler\n  onHoverBounds?: TLBoundsEventHandler\n  onUnhoverBounds?: TLBoundsEventHandler\n  onReleaseBounds?: TLBoundsEventHandler\n  onPointBoundsHandle?: TLBoundsHandleEventHandler\n  onDoubleClickBoundsHandle?: TLBoundsHandleEventHandler\n  onRightPointBoundsHandle?: TLBoundsHandleEventHandler\n  onDragBoundsHandle?: TLBoundsHandleEventHandler\n  onHoverBoundsHandle?: TLBoundsHandleEventHandler\n  onUnhoverBoundsHandle?: TLBoundsHandleEventHandler\n  onReleaseBoundsHandle?: TLBoundsHandleEventHandler\n  onPointHandle?: TLPointerEventHandler\n  onDoubleClickHandle?: TLPointerEventHandler\n  onRightPointHandle?: TLPointerEventHandler\n  onDragHandle?: TLPointerEventHandler\n  onHoverHandle?: TLPointerEventHandler\n  onUnhoverHandle?: TLPointerEventHandler\n  onReleaseHandle?: TLPointerEventHandler\n  onShapeBlur?: TLShapeBlurHandler\n  onShapeClone?: TLShapeCloneHandler\n}\n\nexport type TDDockPosition = 'bottom' | 'left' | 'right' | 'top'\n\n// The shape of the TldrawApp's React (zustand) store\nexport interface TDSnapshot {\n  settings: {\n    isCadSelectMode: boolean\n    isDarkMode: boolean\n    isDebugMode: boolean\n    isPenMode: boolean\n    isReadonlyMode: boolean\n    isZoomSnap: boolean\n    keepStyleMenuOpen: boolean\n    nudgeDistanceSmall: number\n    nudgeDistanceLarge: number\n    isFocusMode: boolean\n    isSnapping: boolean\n    showRotateHandles: boolean\n    showBindingHandles: boolean\n    showCloneHandles: boolean\n    showGrid: boolean\n    language: TDLanguage\n    dockPosition: TDDockPosition\n    exportBackground: TDExportBackground\n  }\n  appState: {\n    currentStyle: ShapeStyles\n    currentPageId: string\n    hoveredId?: string\n    activeTool: TDToolType\n    isToolLocked: boolean\n    isEmptyCanvas: boolean\n    isMenuOpen: boolean\n    status: string\n    snapLines: TLSnapLine[]\n    eraseLine: number[][]\n    isLoading: boolean\n    disableAssets: boolean\n    selectByContain?: boolean\n  }\n  document: TDDocument\n  room?: {\n    id: string\n    userId: string\n    users: Record<string, TDUser>\n  }\n}\n\nexport type TldrawPatch = Patch<TDSnapshot>\n\nexport type TldrawCommand = Command<TDSnapshot>\n\n// The shape of the files stored in JSON\nexport interface TDFile {\n  name: string\n  fileHandle: FileSystemFileHandle | null\n  document: TDDocument\n  assets: Record<string, unknown>\n}\n\n// The shape of the Tldraw document\nexport interface TDDocument {\n  id: string\n  name: string\n  version: number\n  pages: Record<string, TDPage>\n  pageStates: Record<string, TLPageState>\n  assets: TDAssets\n}\n\n// The shape of a single page in the Tldraw document\nexport type TDPage = TLPage<TDShape, TDBinding>\n\n// A partial of a TDPage, used for commands / patches\nexport type PagePartial = {\n  shapes: Patch<TDPage['shapes']>\n  bindings: Patch<TDPage['bindings']>\n}\n\n// The meta information passed to TDShapeUtil components\nexport interface TDMeta {\n  isDarkMode: boolean\n}\n\n// The type of info given to shapes when transforming\nexport interface TransformInfo<T extends TLShape> {\n  type: TLBoundsEdge | TLBoundsCorner\n  initialShape: T\n  scaleX: number\n  scaleY: number\n  transformOrigin: number[]\n}\n\n// The status of a TDUser\nexport enum TDUserStatus {\n  Idle = 'idle',\n  Connecting = 'connecting',\n  Connected = 'connected',\n  Disconnected = 'disconnected',\n}\n\n// A TDUser, for multiplayer rooms\nexport interface TDUser extends TLUser {\n  activeShapes: TDShape[]\n  status: TDUserStatus\n  session?: boolean\n}\n\nexport type Theme = 'dark' | 'light'\n\nexport enum SessionType {\n  Transform = 'transform',\n  Translate = 'translate',\n  TransformSingle = 'transformSingle',\n  Brush = 'brush',\n  Arrow = 'arrow',\n  Draw = 'draw',\n  Erase = 'erase',\n  Rotate = 'rotate',\n  Handle = 'handle',\n  Grid = 'grid',\n  Edit = 'edit',\n}\n\nexport enum TDStatus {\n  Idle = 'idle',\n  PointingHandle = 'pointingHandle',\n  PointingBounds = 'pointingBounds',\n  PointingBoundsHandle = 'pointingBoundsHandle',\n  TranslatingLabel = 'translatingLabel',\n  TranslatingHandle = 'translatingHandle',\n  Translating = 'translating',\n  Transforming = 'transforming',\n  Rotating = 'rotating',\n  Pinching = 'pinching',\n  Brushing = 'brushing',\n  Creating = 'creating',\n  EditingText = 'editing-text',\n}\n\nexport type TDToolType =\n  | 'select'\n  | 'erase'\n  | TDShapeType.Text\n  | TDShapeType.Draw\n  | TDShapeType.Ellipse\n  | TDShapeType.Rectangle\n  | TDShapeType.Triangle\n  | TDShapeType.Line\n  | TDShapeType.Arrow\n  | TDShapeType.Sticky\n\nexport type Easing =\n  | 'linear'\n  | 'easeInQuad'\n  | 'easeOutQuad'\n  | 'easeInOutQuad'\n  | 'easeInCubic'\n  | 'easeOutCubic'\n  | 'easeInOutCubic'\n  | 'easeInQuart'\n  | 'easeOutQuart'\n  | 'easeInOutQuart'\n  | 'easeInQuint'\n  | 'easeOutQuint'\n  | 'easeInOutQuint'\n  | 'easeInSine'\n  | 'easeOutSine'\n  | 'easeInOutSine'\n  | 'easeInExpo'\n  | 'easeOutExpo'\n  | 'easeInOutExpo'\n\nexport enum MoveType {\n  Backward = 'backward',\n  Forward = 'forward',\n  ToFront = 'toFront',\n  ToBack = 'toBack',\n}\n\nexport enum AlignType {\n  Top = 'top',\n  CenterVertical = 'centerVertical',\n  Bottom = 'bottom',\n  Left = 'left',\n  CenterHorizontal = 'centerHorizontal',\n  Right = 'right',\n}\n\nexport enum StretchType {\n  Horizontal = 'horizontal',\n  Vertical = 'vertical',\n}\n\nexport enum DistributeType {\n  Horizontal = 'horizontal',\n  Vertical = 'vertical',\n}\n\nexport enum FlipType {\n  Horizontal = 'horizontal',\n  Vertical = 'vertical',\n}\n\n/* -------------------------------------------------- */\n/*                       Shapes                       */\n/* -------------------------------------------------- */\n\nexport enum TDShapeType {\n  Sticky = 'sticky',\n  Ellipse = 'ellipse',\n  Rectangle = 'rectangle',\n  Triangle = 'triangle',\n  Draw = 'draw',\n  Arrow = 'arrow',\n  Line = 'line',\n  Text = 'text',\n  Group = 'group',\n  Image = 'image',\n  Video = 'video',\n}\n\nexport enum Decoration {\n  Arrow = 'arrow',\n}\n\nexport interface TDBaseShape extends TLShape {\n  style: ShapeStyles\n  type: TDShapeType\n  label?: string\n  handles?: Record<string, TDHandle>\n}\n\nexport interface DrawShape extends TDBaseShape {\n  type: TDShapeType.Draw\n  points: number[][]\n  isComplete: boolean\n}\n\n// The extended handle (used for arrows)\nexport interface TDHandle extends TLHandle {\n  canBind?: boolean\n  bindingId?: string\n}\n\nexport interface RectangleShape extends TDBaseShape {\n  type: TDShapeType.Rectangle\n  size: number[]\n  label?: string\n  labelPoint?: number[]\n}\n\nexport interface EllipseShape extends TDBaseShape {\n  type: TDShapeType.Ellipse\n  radius: number[]\n  label?: string\n  labelPoint?: number[]\n}\n\nexport interface TriangleShape extends TDBaseShape {\n  type: TDShapeType.Triangle\n  size: number[]\n  label?: string\n  labelPoint?: number[]\n}\n\n// The shape created with the arrow tool\nexport interface ArrowShape extends TDBaseShape {\n  type: TDShapeType.Arrow\n  bend: number\n  handles: {\n    start: TDHandle\n    bend: TDHandle\n    end: TDHandle\n  }\n  decorations?: {\n    start?: Decoration\n    end?: Decoration\n    middle?: Decoration\n  }\n  label?: string\n  labelPoint?: number[]\n}\n\nexport interface ArrowBinding extends TLBinding {\n  handleId: keyof ArrowShape['handles']\n  distance: number\n  point: number[]\n}\n\nexport type TDBinding = ArrowBinding\n\nexport interface ImageShape extends TDBaseShape {\n  type: TDShapeType.Image\n  size: number[]\n  assetId: string\n}\n\nexport interface VideoShape extends TDBaseShape {\n  type: TDShapeType.Video\n  size: number[]\n  assetId: string\n  isPlaying: boolean\n  currentTime: number\n}\n\n// The shape created by the text tool\nexport interface TextShape extends TDBaseShape {\n  type: TDShapeType.Text\n  text: string\n}\n\n// The shape created by the sticky tool\nexport interface StickyShape extends TDBaseShape {\n  type: TDShapeType.Sticky\n  size: number[]\n  text: string\n}\n\n// The shape created when multiple shapes are grouped\nexport interface GroupShape extends TDBaseShape {\n  type: TDShapeType.Group\n  size: number[]\n  children: string[]\n}\n\n// A union of all shapes\nexport type TDShape =\n  | RectangleShape\n  | EllipseShape\n  | TriangleShape\n  | DrawShape\n  | ArrowShape\n  | TextShape\n  | GroupShape\n  | StickyShape\n  | ImageShape\n  | VideoShape\n\n/* ------------------ Shape Styles ------------------ */\n\nexport enum ColorStyle {\n  White = 'white',\n  LightGray = 'lightGray',\n  Gray = 'gray',\n  Black = 'black',\n  Green = 'green',\n  Cyan = 'cyan',\n  Blue = 'blue',\n  Indigo = 'indigo',\n  Violet = 'violet',\n  Red = 'red',\n  Orange = 'orange',\n  Yellow = 'yellow',\n}\n\nexport enum SizeStyle {\n  Small = 'small',\n  Medium = 'medium',\n  Large = 'large',\n}\n\nexport enum DashStyle {\n  Draw = 'draw',\n  Solid = 'solid',\n  Dashed = 'dashed',\n  Dotted = 'dotted',\n}\n\nexport enum FontSize {\n  Small = 'small',\n  Medium = 'medium',\n  Large = 'large',\n  ExtraLarge = 'extraLarge',\n}\n\nexport enum AlignStyle {\n  Start = 'start',\n  Middle = 'middle',\n  End = 'end',\n  Justify = 'justify',\n}\n\nexport enum FontStyle {\n  Script = 'script',\n  Sans = 'sans',\n  Serif = 'serif',\n  Mono = 'mono',\n}\n\nexport type ShapeStyles = {\n  color: ColorStyle\n  size: SizeStyle\n  dash: DashStyle\n  font?: FontStyle\n  textAlign?: AlignStyle\n  isFilled?: boolean\n  scale?: number\n}\n\nexport enum TDAssetType {\n  Image = 'image',\n  Video = 'video',\n}\n\nexport interface TDImageAsset extends TLAsset {\n  type: TDAssetType.Image\n  fileName: string\n  src: string\n  size: number[]\n}\n\nexport interface TDVideoAsset extends TLAsset {\n  type: TDAssetType.Video\n  fileName: string\n  src: string\n  size: number[]\n}\n\nexport type TDAsset = TDImageAsset | TDVideoAsset\n\nexport type TDAssets = Record<string, TDAsset>\n\n/* -------------------------------------------------- */\n/*                    Export                          */\n/* -------------------------------------------------- */\n\nexport enum TDExportType {\n  PNG = 'png',\n  JPG = 'jpeg',\n  WEBP = 'webp',\n  SVG = 'svg',\n  JSON = 'json',\n}\n\nexport interface TDExport {\n  name: string\n  type: string\n  blob: Blob\n}\n\nexport enum TDExportBackground {\n  Transparent = 'transparent',\n  Auto = 'auto',\n  Light = 'light',\n  Dark = 'dark',\n}\n\n/* -------------------------------------------------- */\n/*                    Type Helpers                    */\n/* -------------------------------------------------- */\n\nexport type ParametersExceptFirst<F> = F extends (arg0: any, ...rest: infer R) => any ? R : never\n\nexport type ExceptFirst<T extends unknown[]> = T extends [any, ...infer U] ? U : never\n\nexport type ExceptFirstTwo<T extends unknown[]> = T extends [any, any, ...infer U] ? U : never\n\nexport type PropsOfType<U> = {\n  [K in keyof TDShape]: TDShape[K] extends any ? (TDShape[K] extends U ? K : never) : never\n}[keyof TDShape]\n\nexport type Difference<A, B, C = A> = A extends B ? never : C\n\nexport type Intersection<A, B, C = A> = A extends B ? C : never\n\nexport type FilteredKeys<T, U> = {\n  [P in keyof T]: T[P] extends U ? P : never\n}[keyof T]\n\nexport type RequiredKeys<T> = {\n  [K in keyof T]-?: Difference<Record<string, unknown>, Pick<T, K>, K>\n}[keyof T]\n\nexport type MembersWithRequiredKey<T, U> = {\n  [P in keyof T]: Intersection<U, RequiredKeys<T[P]>, T[P]>\n}[keyof T]\n\nexport type MappedByType<U extends string, T extends { type: U }> = {\n  [P in T['type']]: T extends any ? (P extends T['type'] ? T : never) : never\n}\n\nexport type ShapesWithProp<U> = MembersWithRequiredKey<MappedByType<TDShapeType, TDShape>, U>\n\nexport type Patch<T> = Partial<{ [P in keyof T]: Patch<T[P]> }>\n\nexport interface Command<T extends { [key: string]: any }> {\n  id?: string\n  before: Patch<T>\n  after: Patch<T>\n}\n\nexport interface FileWithHandle extends File {\n  handle?: FileSystemFileHandle\n}\n\nexport interface FileWithDirectoryHandle extends File {\n  directoryHandle?: FileSystemDirectoryHandle\n}\n\n// The following typings implement the relevant parts of the File System Access\n// API. This can be removed once the specification reaches the Candidate phase\n// and is implemented as part of microsoft/TSJS-lib-generator.\n\nexport interface FileSystemHandlePermissionDescriptor {\n  mode?: 'read' | 'readwrite'\n}\n\nexport interface FileSystemHandle {\n  readonly kind: 'file' | 'directory'\n  readonly name: string\n\n  isSameEntry: (other: FileSystemHandle) => Promise<boolean>\n\n  queryPermission: (descriptor?: FileSystemHandlePermissionDescriptor) => Promise<PermissionState>\n  requestPermission: (descriptor?: FileSystemHandlePermissionDescriptor) => Promise<PermissionState>\n}\n", "import * as React from 'react'\nimport type { TldrawApp } from '~state'\n\nexport const TldrawContext = React.createContext<TldrawApp>({} as TldrawApp)\n\nconst useForceUpdate = () => {\n  const [_state, setState] = React.useState(0)\n  React.useEffect(() => setState(1))\n}\n\nexport function useTldrawApp() {\n  const context = React.useContext(TldrawContext)\n  return context\n}\n\nexport const ContainerContext = React.createContext({} as React.RefObject<HTMLDivElement>)\n\nexport function useContainer() {\n  const context = React.useContext(ContainerContext)\n  useForceUpdate()\n  return context\n}\n", "import * as React from 'react'\nimport { TDLanguage, getTranslation } from '~translations'\n\nexport function useTranslation(locale?: TDLanguage) {\n  return React.useMemo(() => {\n    return getTranslation(locale ?? navigator.language.split(/[-_]/)[0])\n  }, [locale])\n}\n", "import ar from './ar.json'\nimport da from './da.json'\nimport de from './de.json'\nimport en from './en.json'\nimport es from './es.json'\nimport fa from './fa.json'\nimport fr from './fr.json'\nimport he from './he.json'\nimport it from './it.json'\nimport ja from './ja.json'\nimport ko_kr from './ko-kr.json'\nimport ku from './ku.json'\nimport main from './main.json'\nimport my from \"./my.json\"\nimport ne from './ne.json'\nimport no from './no.json'\nimport pl from './pl.json'\nimport pt_br from './pt-br.json'\nimport pt_pt from './pt-pt.json'\nimport ru from './ru.json'\nimport sv from './sv.json'\nimport te from './te.json'\nimport th from './th.json'\nimport tr from './tr.json'\nimport uk from './uk.json'\nimport zh_cn from './zh-cn.json'\nimport zh_tw from './zh-tw.json'\n\n// The default language (english) must have a value for every message.\n// Other languages may have missing messages. If the application finds\n// a missing message for the current language, it will use the english\n// translation instead.\n\nexport const TRANSLATIONS: TDTranslations = [\n  { locale: 'ar', label: '\u0639\u0631\u0628\u064A', messages: ar },\n  { locale: 'da', label: 'Danish', messages: da },\n  { locale: 'de', label: 'Deutsch', messages: de },\n  { locale: 'en', label: 'English', messages: en },\n  { locale: 'es', label: 'Espa\u00F1ol', messages: es },\n  { locale: 'fa', label: '\u0641\u0627\u0631\u0633\u06CC', messages: fa },\n  { locale: 'fr', label: 'Fran\u00E7ais', messages: fr },\n  { locale: 'he', label: '\u05E2\u05D1\u05E8\u05D9\u05EA', messages: he },\n  { locale: 'it', label: 'Italiano', messages: it },\n  { locale: 'ja', label: '\u65E5\u672C\u8A9E', messages: ja },\n  { locale: 'ko-kr', label: '\uD55C\uAD6D\uC5B4', messages: ko_kr },\n  { locale: 'my', label: '\u1019\u103C\u1014\u103A\u1019\u102C\u1005\u102C', messages: my},\n  { locale: 'ne', label: '\u0928\u0947\u092A\u093E\u0932\u0940', messages: ne },\n  { locale: 'no', label: 'Norwegian', messages: no },\n  { locale: 'pl', label: 'Polski', messages: pl },\n  { locale: 'pt', label: 'Portugu\u00EAs - Europeu', messages: pt_pt },\n  { locale: 'pt-br', label: 'Portugu\u00EAs - Brasil', messages: pt_br },\n  { locale: 'ru', label: 'Russian', messages: ru },\n  { locale: 'sv', label: 'Svenska', messages: sv },\n  { locale: 'te', label: '\u0C24\u0C46\u0C32\u0C41\u0C17\u0C41', messages: te },\n  { locale: 'tr', label: 'T\u00FCrk\u00E7e', messages: tr },\n  { locale: 'uk', label: 'Ukrainian', messages: uk },\n  { locale: 'zh-ch', label: '\u7B80\u4F53\u4E2D\u6587', messages: zh_cn },\n  { locale: 'zh-tw', label: '\u7E41\u9AD4\u4E2D\u6587 (\u53F0\u7063)', messages: zh_tw },\n  { locale: 'th', label: '\u0E20\u0E32\u0E29\u0E32\u0E44\u0E17\u0E22', messages: th },\n  { locale: 'ku', label: '\u06A9\u0648\u0631\u062F\u06CC', messages: ku },\n]\n\n/* ----------------- (do not change) ---------------- */\n\nTRANSLATIONS.sort((a, b) => (a.locale < b.locale ? -1 : 1))\n\nexport type TDTranslation = {\n  readonly locale: string\n  readonly label: string\n  readonly messages: Partial<typeof main>\n}\n\nexport type TDTranslations = TDTranslation[]\n\nexport type TDLanguage = TDTranslations[number]['locale']\n\nexport function getTranslation(locale: TDLanguage): TDTranslation {\n  const translation = TRANSLATIONS.find((t) => t.locale === locale)\n\n  return {\n    locale,\n    label: translation?.label ?? locale,\n    messages: {\n      ...main,\n      ...translation?.messages,\n    },\n  }\n}\n", "import * as React from 'react'\n\nexport type DialogState = 'saveFirstTime' | 'saveAgain'\n\ninterface AlertDialogProps {\n  dialogState: DialogState | null\n  setDialogState: (dialogState: DialogState | null) => void\n  onYes: (() => void) | null\n  onNo: (() => void) | null\n  onCancel: (() => void) | null\n  openDialog: (\n    dialogState: DialogState,\n    onYes: () => void,\n    onNo: () => void,\n    onCancel: () => void\n  ) => void\n}\n\nexport const AlertDialogContext = React.createContext<AlertDialogProps>({} as AlertDialogProps)\n\nexport const useDialog = () => {\n  const context = React.useContext(AlertDialogContext)\n  if (!context) throw new Error('useCtx must be inside a Provider with a value')\n  return context\n}\n", "import * as React from 'react'\nimport { FallbackProps } from 'react-error-boundary'\nimport { Divider } from '~components/Primitives/Divider'\nimport { RowButton } from '~components/Primitives/RowButton'\nimport { useTldrawApp } from '~hooks'\nimport { styled } from '~styles'\n\nexport function ErrorFallback({ error, resetErrorBoundary }: FallbackProps): any {\n  const app = useTldrawApp()\n\n  const refreshPage = () => {\n    window.location.reload()\n    resetErrorBoundary()\n  }\n\n  const copyError = () => {\n    const textarea = document.createElement('textarea')\n    textarea.value = error.message\n    document.body.appendChild(textarea)\n    textarea.select()\n    document.execCommand('copy')\n    textarea.remove()\n  }\n\n  const downloadBackup = () => {\n    app.saveProjectAs()\n  }\n\n  const resetDocument = () => {\n    app.resetDocument()\n    resetErrorBoundary()\n  }\n\n  return (\n    <Container>\n      <InnerContainer>\n        <div>We've encountered an error!</div>\n        <pre>\n          <code>{error.message}</code>\n        </pre>\n        <Buttons>\n          <RowButton onClick={copyError}>Copy Error</RowButton>\n          <RowButton onClick={refreshPage}>Refresh Page</RowButton>\n        </Buttons>\n        <Divider />\n        <p>\n          Keep getting this error?{' '}\n          <a onClick={downloadBackup} title=\"Download your project\">\n            Download your project\n          </a>{' '}\n          as a backup and then{' '}\n          <a onClick={resetDocument} title=\"Reset the document\">\n            reset the document\n          </a>\n          .\n        </p>\n      </InnerContainer>\n    </Container>\n  )\n}\n\nconst Container = styled('div', {\n  position: 'absolute',\n  top: 0,\n  left: 0,\n  width: '100%',\n  height: '100%',\n  display: 'flex',\n  alignItems: 'center',\n  justifyContent: 'center',\n  backgroundColor: '$canvas',\n})\n\nconst InnerContainer = styled('div', {\n  backgroundColor: '$panel',\n  border: '1px solid $panelContrast',\n  padding: '$5',\n  borderRadius: 8,\n  boxShadow: '$panel',\n  maxWidth: 320,\n  color: '$text',\n  fontFamily: '$ui',\n  fontSize: '$2',\n  textAlign: 'center',\n  display: 'flex',\n  flexDirection: 'column',\n  gap: '$3',\n  '& > pre': {\n    marginTop: '$3',\n    marginBottom: '$3',\n    textAlign: 'left',\n    whiteSpace: 'pre-wrap',\n    backgroundColor: '$hover',\n    padding: '$4',\n    borderRadius: '$2',\n    fontFamily: '\"Menlo\", \"Monaco\", monospace',\n    fontWeight: 500,\n  },\n  '& p': {\n    fontFamily: '$body',\n    lineHeight: 1.7,\n    padding: '$5',\n    margin: 0,\n  },\n  '& a': {\n    color: '$text',\n    cursor: 'pointer',\n    textDecoration: 'underline',\n  },\n  '& hr': {\n    marginLeft: '-$5',\n    marginRight: '-$5',\n  },\n})\n\nconst Buttons = styled('div', {\n  display: 'flex',\n  '& > button > div': {\n    justifyContent: 'center',\n    textAlign: 'center',\n  },\n})\n", "import { DotFilledIcon } from '@radix-ui/react-icons'\nimport * as React from 'react'\nimport { IconButton } from '~components/Primitives/IconButton/IconButton'\nimport { styled } from '~styles'\n\ninterface FocusButtonProps {\n  onSelect: () => void\n}\n\nexport function FocusButton({ onSelect }: FocusButtonProps) {\n  return (\n    <StyledButtonContainer>\n      <IconButton onClick={onSelect}>\n        <DotFilledIcon />\n      </IconButton>\n    </StyledButtonContainer>\n  )\n}\n\nconst StyledButtonContainer = styled('div', {\n  opacity: 1,\n  zIndex: 100,\n  backgroundColor: 'transparent',\n\n  '& svg': {\n    color: '$text',\n  },\n\n  '&:hover svg': {\n    color: '$text',\n  },\n})\n", "import { styled } from '~styles'\n\nexport const IconButton = styled('button', {\n  position: 'relative',\n  height: '32px',\n  width: '32px',\n  backgroundColor: '$panel',\n  borderRadius: '4px',\n  padding: '0',\n  margin: '0',\n  outline: 'none',\n  border: 'none',\n  pointerEvents: 'all',\n  fontSize: '$0',\n  color: '$text',\n  cursor: 'pointer',\n  display: 'grid',\n  alignItems: 'center',\n  justifyContent: 'center',\n\n  '& > *': {\n    gridRow: 1,\n    gridColumn: 1,\n  },\n\n  '&:disabled': {\n    opacity: '0.5',\n  },\n\n  '& > span': {\n    width: '100%',\n    height: '100%',\n    display: 'flex',\n    alignItems: 'center',\n  },\n\n  variants: {\n    bp: {\n      mobile: {\n        backgroundColor: 'transparent',\n      },\n      small: {\n        '&:hover:not(:disabled)': {\n          backgroundColor: '$hover',\n        },\n      },\n    },\n    size: {\n      small: {\n        height: 32,\n        width: 32,\n        '& svg:nth-of-type(1)': {\n          height: '16px',\n          width: '16px',\n        },\n      },\n      medium: {\n        height: 44,\n        width: 44,\n        '& svg:nth-of-type(1)': {\n          height: '18px',\n          width: '18px',\n        },\n      },\n      large: {\n        height: 44,\n        width: 44,\n        '& svg:nth-of-type(1)': {\n          height: '20px',\n          width: '20px',\n        },\n      },\n    },\n    isActive: {\n      true: {\n        color: '$selected',\n      },\n    },\n  },\n})\n", "import * as React from 'react'\nimport { FormattedMessage } from 'react-intl'\nimport { useTldrawApp } from '~hooks'\nimport { styled } from '~styles'\nimport type { TDSnapshot } from '~types'\n\nconst loadingSelector = (s: TDSnapshot) => s.appState.isLoading\n\nexport function Loading() {\n  const app = useTldrawApp()\n  const isLoading = app.useStore(loadingSelector)\n\n  return (\n    <StyledLoadingPanelContainer hidden={!isLoading}>\n      <FormattedMessage id=\"loading\" values={{ dots: '...' }} />\n    </StyledLoadingPanelContainer>\n  )\n}\n\nconst StyledLoadingPanelContainer = styled('div', {\n  position: 'absolute',\n  top: 0,\n  left: '50%',\n  transform: `translate(-50%, 0)`,\n  borderBottomLeftRadius: '12px',\n  borderBottomRightRadius: '12px',\n  padding: '8px 16px',\n  fontFamily: 'var(--fonts-ui)',\n  fontSize: 'var(--fontSizes-1)',\n  boxShadow: 'var(--shadows-panel)',\n  backgroundColor: 'white',\n  zIndex: 200,\n  pointerEvents: 'none',\n  '& > div > *': {\n    pointerEvents: 'all',\n  },\n  variants: {\n    transform: {\n      hidden: {\n        transform: `translate(-50%, 100%)`,\n      },\n      visible: {\n        transform: `translate(-50%, 0%)`,\n      },\n    },\n  },\n})\n", "import * as AlertDialogPrimitive from '@radix-ui/react-alert-dialog'\nimport * as React from 'react'\nimport { FormattedMessage, useIntl } from 'react-intl'\nimport { DialogState, useDialog } from '~hooks'\nimport { styled } from '~styles'\n\ninterface ContentProps {\n  children: React.ReactNode\n  onClose?: () => void\n  container: any\n}\n\nfunction Content({ children, onClose, container }: ContentProps) {\n  const handleKeyDown = (event: React.KeyboardEvent) => {\n    switch (event.key) {\n      case 'Escape':\n        onClose?.()\n        break\n    }\n  }\n  return (\n    <AlertDialogPrimitive.Portal container={container}>\n      <StyledOverlay />\n      <StyledContent onKeyDown={handleKeyDown}>{children}</StyledContent>\n    </AlertDialogPrimitive.Portal>\n  )\n}\n\nconst StyledDescription = styled(AlertDialogPrimitive.Description, {\n  marginBottom: 20,\n  color: '$text',\n  fontSize: '$2',\n  lineHeight: 1.5,\n  textAlign: 'center',\n  maxWidth: '62%',\n  minWidth: 0,\n  alignSelf: 'center',\n})\n\nexport const AlertDialogRoot = AlertDialogPrimitive.Root\nexport const AlertDialogContent = Content\nexport const AlertDialogDescription = StyledDescription\nexport const AlertDialogAction = AlertDialogPrimitive.Action\nexport const AlertDialogCancel = AlertDialogPrimitive.Cancel\n\nexport const AlertDialog = ({ container }: { container: any }) => {\n  const { setDialogState, dialogState, onCancel, onNo, onYes } = useDialog()\n  const intl = useIntl()\n  const descriptions: Record<DialogState, string> = {\n    saveFirstTime: intl.formatMessage({ id: 'dialog.save.firsttime' }),\n    saveAgain: intl.formatMessage({ id: 'dialog.save.again' }),\n  }\n\n  return (\n    <AlertDialogRoot open={dialogState !== null}>\n      <AlertDialogContent onClose={() => setDialogState(null)} container={container}>\n        {dialogState && (\n          <AlertDialogDescription>{descriptions[dialogState]}</AlertDialogDescription>\n        )}\n        <div\n          style={{\n            width: '100%',\n            gap: '$6',\n            display: 'flex',\n            justifyContent: 'space-between',\n          }}\n        >\n          {onCancel && (\n            <AlertDialogCancel asChild>\n              <Button\n                css={{ color: '$text' }}\n                onClick={() => {\n                  onCancel()\n                  setDialogState(null)\n                }}\n              >\n                <FormattedMessage id=\"dialog.cancel\" />\n              </Button>\n            </AlertDialogCancel>\n          )}\n          <div style={{ flexShrink: 0 }}>\n            {onNo && (\n              <AlertDialogAction asChild>\n                <Button\n                  onClick={() => {\n                    onNo()\n                    setDialogState(null)\n                  }}\n                >\n                  <FormattedMessage id=\"dialog.no\" />\n                </Button>\n              </AlertDialogAction>\n            )}\n            {onYes && (\n              <AlertDialogAction asChild>\n                <Button\n                  css={{ backgroundColor: '#2F80ED', color: 'White' }}\n                  onClick={() => {\n                    onYes()\n                    setDialogState(null)\n                  }}\n                >\n                  <FormattedMessage id=\"dialog.yes\" />\n                </Button>\n              </AlertDialogAction>\n            )}\n          </div>\n        </div>\n      </AlertDialogContent>\n    </AlertDialogRoot>\n  )\n}\n\nconst StyledOverlay = styled(AlertDialogPrimitive.Overlay, {\n  position: 'fixed',\n  inset: 0,\n  backgroundColor: 'rgba(0, 0, 0, .15)',\n  pointerEvents: 'all',\n})\n\nexport const StyledDialogOverlay = styled(AlertDialogPrimitive.Overlay, {\n  backgroundColor: 'rgba(0, 0, 0, .15)',\n  position: 'absolute',\n  pointerEvents: 'all',\n  inset: 0,\n})\n\nconst StyledContent = styled(AlertDialogPrimitive.Content, {\n  position: 'fixed',\n  font: '$ui',\n  top: '50%',\n  left: '50%',\n  transform: 'translate(-50%, -50%)',\n  width: 'max-content',\n  padding: '$3',\n  pointerEvents: 'all',\n  backgroundColor: '$panel',\n  borderRadius: '$3',\n  display: 'flex',\n  flexDirection: 'column',\n  justifyContent: 'center',\n  fontFamily: '$ui',\n  border: '1px solid $panelContrast',\n  boxShadow: '$panel',\n})\n\nexport const Button = styled('button', {\n  all: 'unset',\n  display: 'inline-flex',\n  alignItems: 'center',\n  justifyContent: 'center',\n  borderRadius: '$2',\n  padding: '0 15px',\n  fontSize: '$1',\n  lineHeight: 1,\n  fontWeight: 'normal',\n  height: 36,\n  color: '$text',\n  cursor: 'pointer',\n  minWidth: 48,\n})\n", "import * as Dialog from '@radix-ui/react-alert-dialog'\nimport { Pencil1Icon } from '@radix-ui/react-icons'\nimport * as React from 'react'\nimport { FormattedMessage, useIntl } from 'react-intl'\nimport { useContainer, useTldrawApp } from '~hooks'\nimport { styled } from '~styles'\nimport { TextField } from '../TextField'\nimport { Button } from './AlertDialog'\n\ninterface FilenameDialogProps {\n  isOpen: boolean\n  onClose: () => void\n}\n\nexport const FilenameDialog = ({ isOpen, onClose }: FilenameDialogProps) => {\n  const app = useTldrawApp()\n  const container = useContainer()\n  const intl = useIntl()\n  const [filename, setFilename] = React.useState(app.document.name)\n\n  const handleChange = React.useCallback((event: React.ChangeEvent<HTMLInputElement>) => {\n    const value = event.target.value.trimStart()\n    setFilename(value)\n  }, [])\n\n  function stopPropagation(e: React.KeyboardEvent<HTMLDivElement>) {\n    e.stopPropagation()\n  }\n\n  const handleTextFieldKeyDown = React.useCallback((e: React.KeyboardEvent<HTMLInputElement>) => {\n    switch (e.key) {\n      case 'Enter': {\n        app.saveProjectAs(filename)\n        onClose()\n        break\n      }\n      case 'Escape': {\n        onClose()\n        break\n      }\n    }\n  }, [])\n\n  return (\n    <Dialog.Root open={isOpen}>\n      <Dialog.Portal container={container.current}>\n        <StyledDialogOverlay onPointerDown={onClose} />\n        <StyledDialogContent dir=\"ltr\" onKeyDown={stopPropagation} onKeyUp={stopPropagation}>\n          <Input\n            placeholder={intl.formatMessage({ id: 'enter.file.name' })}\n            value={filename}\n            onChange={handleChange}\n            onKeyDown={handleTextFieldKeyDown}\n            icon={<Pencil1Icon />}\n          />\n          <ActionWrapper>\n            <Dialog.Action asChild>\n              <Button onClick={onClose}>\n                <FormattedMessage id=\"cancel\" />\n              </Button>\n            </Dialog.Action>\n            <Dialog.Action asChild>\n              <Button\n                css={{ backgroundColor: '#2F80ED', color: 'White' }}\n                onClick={() => {\n                  // Remove the file extension if the user entered it\n                  const name = filename.trim().replace(/\\.tldr$/, '')\n                  app.saveProjectAs(name)\n                  onClose()\n                }}\n              >\n                <FormattedMessage id=\"save\" />\n              </Button>\n            </Dialog.Action>\n          </ActionWrapper>\n        </StyledDialogContent>\n      </Dialog.Portal>\n    </Dialog.Root>\n  )\n}\nconst StyledDialogContent = styled(Dialog.Content, {\n  position: 'absolute',\n  top: '50%',\n  left: '50%',\n  transform: 'translate(-50%, -50%)',\n  minWidth: 300,\n  maxWidth: 'fit-content',\n  maxHeight: '85vh',\n  marginTop: '-5vh',\n  pointerEvents: 'all',\n  backgroundColor: '$panel',\n  padding: '$3',\n  borderRadius: '$2',\n  font: '$ui',\n  zIndex: 999999,\n  '&:focus': {\n    outline: 'none',\n  },\n})\n\nconst StyledDialogOverlay = styled(Dialog.Overlay, {\n  backgroundColor: 'rgba(0, 0, 0, .15)',\n  position: 'absolute',\n  pointerEvents: 'all',\n  inset: 0,\n  zIndex: 999998,\n})\n\nconst ActionWrapper = styled('div', {\n  width: '100%',\n  display: 'flex',\n  alignItems: 'center',\n  gap: 8,\n  justifyContent: 'flex-end',\n  marginTop: 10,\n})\n\nconst Input = styled(TextField, {\n  background: '$hover',\n})\n", "import * as React from 'react'\nimport { SmallIcon } from '~components/Primitives/SmallIcon'\nimport { styled } from '~styles'\n\nexport interface TextFieldProps extends React.HTMLProps<HTMLInputElement> {\n  icon?: React.ReactElement\n}\n\nexport const TextField = React.forwardRef<HTMLInputElement, TextFieldProps>(\n  ({ icon, ...rest }, ref) => {\n    return (\n      <StyledInputWrapper>\n        <StyledInput {...rest} ref={ref} />\n        {icon ? <StyledInputIcon>{icon}</StyledInputIcon> : null}\n      </StyledInputWrapper>\n    )\n  }\n)\n\nconst StyledInputWrapper = styled('div', {\n  position: 'relative',\n  width: '100%',\n  height: 'min-content',\n})\n\nconst StyledInput = styled('input', {\n  color: '$text',\n  border: 'none',\n  textAlign: 'left',\n  width: '100%',\n  paddingLeft: '$3',\n  paddingRight: '$6',\n  backgroundColor: '$background',\n\n  height: '32px',\n  outline: 'none',\n  fontFamily: '$ui',\n  fontSize: '$1',\n  '&:focus': {\n    backgroundColor: '$hover',\n  },\n  borderRadius: '$2',\n})\n\nconst StyledInputIcon = styled(SmallIcon, {\n  top: 0,\n  right: 0,\n  position: 'absolute',\n  paddingLeft: '$3',\n  paddingRight: '$3',\n  pointerEvents: 'none',\n  color: '$text',\n})\n", "import * as React from 'react'\nimport { breakpoints } from '~components/breakpoints'\nimport { useTldrawApp } from '~hooks'\nimport { styled } from '~styles'\nimport type { TDSnapshot } from '~types'\nimport { ActionButton } from './ActionButton'\nimport { BackToContent } from './BackToContent'\nimport { DeleteButton } from './DeleteButton'\nimport { HelpPanel } from './HelpPanel'\nimport { PrimaryTools } from './PrimaryTools'\nimport { StatusBar } from './StatusBar'\n\nconst isDebugModeSelector = (s: TDSnapshot) => s.settings.isDebugMode\nconst dockPositionState = (s: TDSnapshot) => s.settings.dockPosition\n\ninterface ToolsPanelProps {\n  onBlur?: React.FocusEventHandler\n}\n\nexport const ToolsPanel = React.memo(function ToolsPanel({ onBlur }: ToolsPanelProps) {\n  const app = useTldrawApp()\n  const side = app.useStore(dockPositionState)\n  const isDebugMode = app.useStore(isDebugModeSelector)\n\n  return (\n    <>\n      <StyledToolsPanelContainer side={side} onBlur={onBlur} bp={breakpoints} debug={isDebugMode}>\n        <StyledCenterWrap id=\"TD-Tools\">\n          <BackToContent />\n          <StyledPrimaryTools\n            orientation={side === 'bottom' || side === 'top' ? 'horizontal' : 'vertical'}\n          >\n            <ActionButton />\n            <PrimaryTools />\n            <DeleteButton />\n          </StyledPrimaryTools>\n        </StyledCenterWrap>\n      </StyledToolsPanelContainer>\n      <HelpPanel />\n      {isDebugMode && (\n        <StyledStatusWrap>\n          <StatusBar />\n        </StyledStatusWrap>\n      )}\n    </>\n  )\n})\n\nconst StyledToolsPanelContainer = styled('div', {\n  position: 'absolute',\n  width: '100%',\n  minWidth: 0,\n  maxWidth: '100%',\n  height: 64,\n  gap: '$4',\n  display: 'flex',\n  justifyContent: 'center',\n  alignItems: 'center',\n  zIndex: 200,\n  overflow: 'hidden',\n  pointerEvents: 'none',\n  '& > div > *': {\n    pointerEvents: 'all',\n  },\n  variants: {\n    debug: {\n      true: {},\n      false: {},\n    },\n    bp: {\n      mobile: {},\n      small: {},\n      medium: {},\n      large: {},\n    },\n    side: {\n      top: {\n        width: '100%',\n        height: 64,\n        left: 0,\n        right: 0,\n        top: 45,\n      },\n      right: { width: 64, height: '100%', top: 0, right: 0 },\n      bottom: {\n        width: '100%',\n        left: 0,\n        right: 0,\n        bottom: 4,\n      },\n      left: { width: 64, height: '100%', left: 0 },\n    },\n  },\n  compoundVariants: [\n    {\n      side: 'top',\n      bp: 'large',\n      css: {\n        top: 0,\n      },\n    },\n    {\n      side: 'bottom',\n      debug: true,\n      css: {\n        bottom: 44,\n      },\n    },\n  ],\n})\n\nconst StyledCenterWrap = styled('div', {\n  display: 'flex',\n  width: 'fit-content',\n  height: 'fit-content',\n  alignItems: 'center',\n  justifyContent: 'center',\n  flexDirection: 'column',\n  gap: '$4',\n})\n\nconst StyledStatusWrap = styled('div', {\n  position: 'absolute',\n  bottom: '0px',\n  left: '0px',\n  right: '0px',\n  height: '40px',\n  width: '100%',\n  maxWidth: '100%',\n})\n\nconst StyledPrimaryTools = styled('div', {\n  position: 'relative',\n  display: 'flex',\n  alignItems: 'center',\n  height: 'fit-content',\n  gap: '$3',\n  variants: {\n    orientation: {\n      horizontal: {\n        flexDirection: 'row',\n      },\n      vertical: {\n        flexDirection: 'column',\n      },\n    },\n  },\n})\n", "import * as DropdownMenu from '@radix-ui/react-dropdown-menu'\nimport {\n  AlignBottomIcon,\n  AlignCenterHorizontallyIcon,\n  AlignCenterVerticallyIcon,\n  AlignLeftIcon,\n  AlignRightIcon,\n  AlignTopIcon,\n  AngleIcon,\n  ArrowDownIcon,\n  ArrowUpIcon,\n  AspectRatioIcon,\n  BoxIcon,\n  CopyIcon,\n  DotsHorizontalIcon,\n  GroupIcon,\n  LockClosedIcon,\n  LockOpen1Icon,\n  PinBottomIcon,\n  PinTopIcon,\n  RotateCounterClockwiseIcon,\n  SpaceEvenlyHorizontallyIcon,\n  SpaceEvenlyVerticallyIcon,\n  StretchHorizontallyIcon,\n  StretchVerticallyIcon,\n} from '@radix-ui/react-icons'\nimport * as React from 'react'\nimport { useIntl } from 'react-intl'\nimport { Divider } from '~components/Primitives/Divider'\nimport { DMContent } from '~components/Primitives/DropdownMenu'\nimport { ToolButton } from '~components/Primitives/ToolButton'\nimport { Tooltip } from '~components/Primitives/Tooltip/Tooltip'\nimport { useTldrawApp } from '~hooks'\nimport { styled } from '~styles'\nimport { AlignType, DistributeType, StretchType, TDSnapshot } from '~types'\n\nconst dockPositionState = (s: TDSnapshot) => s.settings.dockPosition\n\nconst selectedShapesCountSelector = (s: TDSnapshot) =>\n  s.document.pageStates[s.appState.currentPageId].selectedIds.length\n\nconst isAllLockedSelector = (s: TDSnapshot) => {\n  const page = s.document.pages[s.appState.currentPageId]\n  const { selectedIds } = s.document.pageStates[s.appState.currentPageId]\n  return selectedIds.every((id) => page.shapes[id].isLocked)\n}\n\nconst isAllAspectLockedSelector = (s: TDSnapshot) => {\n  const page = s.document.pages[s.appState.currentPageId]\n  const { selectedIds } = s.document.pageStates[s.appState.currentPageId]\n  return selectedIds.every((id) => page.shapes[id].isAspectRatioLocked)\n}\n\nconst isAllGroupedSelector = (s: TDSnapshot) => {\n  const page = s.document.pages[s.appState.currentPageId]\n  const selectedShapes = s.document.pageStates[s.appState.currentPageId].selectedIds.map(\n    (id) => page.shapes[id]\n  )\n\n  return selectedShapes.every(\n    (shape) =>\n      shape.children !== undefined ||\n      (shape.parentId === selectedShapes[0].parentId &&\n        selectedShapes[0].parentId !== s.appState.currentPageId)\n  )\n}\n\nconst hasSelectionSelector = (s: TDSnapshot) => {\n  const { selectedIds } = s.document.pageStates[s.appState.currentPageId]\n  return selectedIds.length > 0\n}\n\nconst hasMultipleSelectionSelector = (s: TDSnapshot) => {\n  const { selectedIds } = s.document.pageStates[s.appState.currentPageId]\n  return selectedIds.length > 1\n}\n\nexport function ActionButton() {\n  const app = useTldrawApp()\n  const intl = useIntl()\n\n  const isAllLocked = app.useStore(isAllLockedSelector)\n\n  const isAllAspectLocked = app.useStore(isAllAspectLockedSelector)\n\n  const isAllGrouped = app.useStore(isAllGroupedSelector)\n\n  const hasSelection = app.useStore(hasSelectionSelector)\n\n  const hasMultipleSelection = app.useStore(hasMultipleSelectionSelector)\n\n  const selectedShapesCount = app.useStore(selectedShapesCountSelector)\n\n  const dockPosition = app.useStore(dockPositionState)\n\n  const hasTwoOrMore = selectedShapesCount > 1\n\n  const hasThreeOrMore = selectedShapesCount > 2\n\n  const handleRotate = React.useCallback(() => {\n    app.rotate()\n  }, [app])\n\n  const handleDuplicate = React.useCallback(() => {\n    app.duplicate()\n  }, [app])\n\n  const handleToggleLocked = React.useCallback(() => {\n    app.toggleLocked()\n  }, [app])\n\n  const handleToggleAspectRatio = React.useCallback(() => {\n    app.toggleAspectRatioLocked()\n  }, [app])\n\n  const handleGroup = React.useCallback(() => {\n    app.group()\n  }, [app])\n\n  const handleMoveToBack = React.useCallback(() => {\n    app.moveToBack()\n  }, [app])\n\n  const handleMoveBackward = React.useCallback(() => {\n    app.moveBackward()\n  }, [app])\n\n  const handleMoveForward = React.useCallback(() => {\n    app.moveForward()\n  }, [app])\n\n  const handleMoveToFront = React.useCallback(() => {\n    app.moveToFront()\n  }, [app])\n\n  const handleResetAngle = React.useCallback(() => {\n    app.setShapeProps({ rotation: 0 })\n  }, [app])\n\n  const alignTop = React.useCallback(() => {\n    app.align(AlignType.Top)\n  }, [app])\n\n  const alignCenterVertical = React.useCallback(() => {\n    app.align(AlignType.CenterVertical)\n  }, [app])\n\n  const alignBottom = React.useCallback(() => {\n    app.align(AlignType.Bottom)\n  }, [app])\n\n  const stretchVertically = React.useCallback(() => {\n    app.stretch(StretchType.Vertical)\n  }, [app])\n\n  const distributeVertically = React.useCallback(() => {\n    app.distribute(DistributeType.Vertical)\n  }, [app])\n\n  const alignLeft = React.useCallback(() => {\n    app.align(AlignType.Left)\n  }, [app])\n\n  const alignCenterHorizontal = React.useCallback(() => {\n    app.align(AlignType.CenterHorizontal)\n  }, [app])\n\n  const alignRight = React.useCallback(() => {\n    app.align(AlignType.Right)\n  }, [app])\n\n  const stretchHorizontally = React.useCallback(() => {\n    app.stretch(StretchType.Horizontal)\n  }, [app])\n\n  const distributeHorizontally = React.useCallback(() => {\n    app.distribute(DistributeType.Horizontal)\n  }, [app])\n\n  const handleMenuOpenChange = React.useCallback(\n    (open: boolean) => {\n      app.setMenuOpen(open)\n    },\n    [app]\n  )\n\n  const contentSide = dockPosition === 'bottom' || dockPosition === 'top' ? 'top' : dockPosition\n\n  return (\n    <DropdownMenu.Root dir=\"ltr\" onOpenChange={handleMenuOpenChange}>\n      <DropdownMenu.Trigger dir=\"ltr\" asChild id=\"TD-Tools-Dots\">\n        <ToolButton aria-label={intl.formatMessage({ id: 'shape.options' })} variant=\"circle\">\n          <DotsHorizontalIcon />\n        </ToolButton>\n      </DropdownMenu.Trigger>\n      <DMContent sideOffset={16} side={contentSide}>\n        <>\n          <ButtonsRow>\n            <Tooltip label={intl.formatMessage({ id: 'duplicate' })} kbd={`#D`} id=\"TD-Tools-Copy\">\n              <ToolButton\n                aria-label={intl.formatMessage({ id: 'duplicate' })}\n                disabled={!hasSelection}\n                onClick={handleDuplicate}\n              >\n                <CopyIcon />\n              </ToolButton>\n            </Tooltip>\n            <Tooltip label={intl.formatMessage({ id: 'rotate' })} id=\"TD-Tools-Rotate\">\n              <ToolButton\n                aria-label={intl.formatMessage({ id: 'rotate' })}\n                disabled={!hasSelection}\n                onClick={handleRotate}\n              >\n                <RotateCounterClockwiseIcon />\n              </ToolButton>\n            </Tooltip>\n            <Tooltip\n              label={intl.formatMessage({ id: isAllLocked ? 'unlock' : 'lock' })}\n              kbd={`#L`}\n              id=\"TD-Tools-Lock\"\n            >\n              <ToolButton\n                aria-label={intl.formatMessage({ id: isAllLocked ? 'unlock' : 'lock' })}\n                disabled={!hasSelection}\n                onClick={handleToggleLocked}\n              >\n                {isAllLocked ? <LockClosedIcon /> : <LockOpen1Icon />}\n              </ToolButton>\n            </Tooltip>\n            <Tooltip\n              label={intl.formatMessage({\n                id: isAllAspectLocked ? 'unlock.aspect.ratio' : 'lock.aspect.ratio',\n              })}\n              id=\"TD-Tools-AspectRatio\"\n            >\n              <ToolButton\n                aria-label={intl.formatMessage({\n                  id: isAllAspectLocked ? 'unlock.aspect.ratio' : 'lock.aspect.ratio',\n                })}\n                disabled={!hasSelection}\n                onClick={handleToggleAspectRatio}\n              >\n                {isAllAspectLocked ? <AspectRatioIcon /> : <BoxIcon />}\n              </ToolButton>\n            </Tooltip>\n            <Tooltip label={intl.formatMessage({ id: 'group' })} kbd={`#G`} id=\"TD-Tools-Group\">\n              <ToolButton\n                aria-label={intl.formatMessage({ id: 'group' })}\n                disabled={!hasSelection || (!isAllGrouped && !hasMultipleSelection)}\n                onClick={handleGroup}\n              >\n                <GroupIcon />\n              </ToolButton>\n            </Tooltip>\n          </ButtonsRow>\n          <ButtonsRow>\n            <Tooltip\n              label={intl.formatMessage({ id: 'move.to.back' })}\n              kbd={`#\u21E7[`}\n              id=\"TD-Tools-PinBottom\"\n            >\n              <ToolButton\n                aria-label={intl.formatMessage({ id: 'move.to.back' })}\n                disabled={!hasSelection}\n                onClick={handleMoveToBack}\n              >\n                <PinBottomIcon />\n              </ToolButton>\n            </Tooltip>\n            <Tooltip\n              label={intl.formatMessage({ id: 'move.backward' })}\n              kbd={`#[`}\n              id=\"TD-Tools-ArrowDown\"\n            >\n              <ToolButton\n                aria-label={intl.formatMessage({ id: 'move.backward' })}\n                disabled={!hasSelection}\n                onClick={handleMoveBackward}\n              >\n                <ArrowDownIcon />\n              </ToolButton>\n            </Tooltip>\n            <Tooltip\n              label={intl.formatMessage({ id: 'move.forward' })}\n              kbd={`#]`}\n              id=\"TD-Tools-ArrowUp\"\n            >\n              <ToolButton\n                aria-label={intl.formatMessage({ id: 'move.forward' })}\n                disabled={!hasSelection}\n                onClick={handleMoveForward}\n              >\n                <ArrowUpIcon />\n              </ToolButton>\n            </Tooltip>\n            <Tooltip\n              label={intl.formatMessage({ id: 'move.to.front' })}\n              kbd={`#\u21E7]`}\n              id=\"TD-Tools-PinTop\"\n            >\n              <ToolButton\n                aria-label={intl.formatMessage({ id: 'move.to.front' })}\n                disabled={!hasSelection}\n                onClick={handleMoveToFront}\n              >\n                <PinTopIcon />\n              </ToolButton>\n            </Tooltip>\n            <Tooltip label={intl.formatMessage({ id: 'reset.angle' })} id=\"TD-Tools-ResetAngle\">\n              <ToolButton\n                aria-label={intl.formatMessage({ id: 'reset.angle' })}\n                disabled={!hasSelection}\n                onClick={handleResetAngle}\n              >\n                <AngleIcon />\n              </ToolButton>\n            </Tooltip>\n          </ButtonsRow>\n          <Divider />\n          <ButtonsRow>\n            <Tooltip label={intl.formatMessage({ id: 'align.left' })} id=\"TD-Tools-AlignLeft\">\n              <ToolButton\n                aria-label={intl.formatMessage({ id: 'align.left' })}\n                disabled={!hasTwoOrMore}\n                onClick={alignLeft}\n              >\n                <AlignLeftIcon />\n              </ToolButton>\n            </Tooltip>\n            <Tooltip\n              label={intl.formatMessage({ id: 'align.center.x' })}\n              id=\"TD-Tools-AlignCenterHorizontal\"\n            >\n              <ToolButton\n                aria-label={intl.formatMessage({ id: 'align.center.x' })}\n                disabled={!hasTwoOrMore}\n                onClick={alignCenterHorizontal}\n              >\n                <AlignCenterHorizontallyIcon />\n              </ToolButton>\n            </Tooltip>\n            <Tooltip label={intl.formatMessage({ id: 'align.right' })} id=\"TD-Tools-AlignRight\">\n              <ToolButton\n                aria-label={intl.formatMessage({ id: 'align.right' })}\n                disabled={!hasTwoOrMore}\n                onClick={alignRight}\n              >\n                <AlignRightIcon />\n              </ToolButton>\n            </Tooltip>\n            <Tooltip\n              label={intl.formatMessage({ id: 'stretch.x' })}\n              id=\"TD-Tools-StretchHorizontal\"\n            >\n              <ToolButton\n                aria-label={intl.formatMessage({ id: 'stretch.x' })}\n                disabled={!hasTwoOrMore}\n                onClick={stretchHorizontally}\n              >\n                <StretchHorizontallyIcon />\n              </ToolButton>\n            </Tooltip>\n            <Tooltip\n              label={intl.formatMessage({ id: 'distribute.x' })}\n              id=\"TD-Tools-SpaceEvenlyHorizontal\"\n            >\n              <ToolButton\n                aria-label={intl.formatMessage({ id: 'distribute.x' })}\n                disabled={!hasThreeOrMore}\n                onClick={distributeHorizontally}\n              >\n                <SpaceEvenlyHorizontallyIcon />\n              </ToolButton>\n            </Tooltip>\n          </ButtonsRow>\n          <ButtonsRow>\n            <Tooltip label={intl.formatMessage({ id: 'align.top' })} id=\"TD-Tools-AlignTop\">\n              <ToolButton\n                aria-label={intl.formatMessage({ id: 'align.top' })}\n                disabled={!hasTwoOrMore}\n                onClick={alignTop}\n              >\n                <AlignTopIcon />\n              </ToolButton>\n            </Tooltip>\n            <Tooltip\n              label={intl.formatMessage({ id: 'align.center.y' })}\n              id=\"TD-Tools-AlignCenterVertical\"\n            >\n              <ToolButton\n                aria-label={intl.formatMessage({ id: 'align.center.y' })}\n                disabled={!hasTwoOrMore}\n                onClick={alignCenterVertical}\n              >\n                <AlignCenterVerticallyIcon />\n              </ToolButton>\n            </Tooltip>\n            <Tooltip label={intl.formatMessage({ id: 'align.bottom' })} id=\"TD-Tools-AlignBottom\">\n              <ToolButton\n                aria-label={intl.formatMessage({ id: 'align.bottom' })}\n                disabled={!hasTwoOrMore}\n                onClick={alignBottom}\n              >\n                <AlignBottomIcon />\n              </ToolButton>\n            </Tooltip>\n            <Tooltip label={intl.formatMessage({ id: 'stretch.y' })} id=\"TD-Tools-StretchVertical\">\n              <ToolButton\n                aria-label={intl.formatMessage({ id: 'stretch.y' })}\n                disabled={!hasTwoOrMore}\n                onClick={stretchVertically}\n              >\n                <StretchVerticallyIcon />\n              </ToolButton>\n            </Tooltip>\n            <Tooltip\n              label={intl.formatMessage({ id: 'distribute.y' })}\n              id=\"TD-Tools-SpaceEvenlyVertical\"\n            >\n              <ToolButton\n                aria-label={intl.formatMessage({ id: 'distribute.y' })}\n                disabled={!hasThreeOrMore}\n                onClick={distributeVertically}\n              >\n                <SpaceEvenlyVerticallyIcon />\n              </ToolButton>\n            </Tooltip>\n          </ButtonsRow>\n        </>\n      </DMContent>\n    </DropdownMenu.Root>\n  )\n}\n\nexport const ButtonsRow = styled('div', {\n  position: 'relative',\n  display: 'flex',\n  width: '100%',\n  background: 'none',\n  border: 'none',\n  cursor: 'pointer',\n  outline: 'none',\n  alignItems: 'center',\n  justifyContent: 'flex-start',\n  padding: 0,\n})\n", "import { Item } from '@radix-ui/react-dropdown-menu'\nimport * as React from 'react'\nimport { RowButton, RowButtonProps } from '~components/Primitives/RowButton'\n\nexport function DMItem({\n  onSelect,\n  id,\n  ...rest\n}: RowButtonProps & { onSelect?: (event: Event) => void; id?: string }) {\n  return (\n    <Item dir=\"ltr\" asChild onSelect={onSelect} id={id}>\n      <RowButton {...rest} />\n    </Item>\n  )\n}\n", "import { CheckboxItem } from '@radix-ui/react-dropdown-menu'\nimport * as React from 'react'\nimport { RowButton, RowButtonProps } from '~components/Primitives/RowButton'\nimport { preventEvent } from '~components/preventEvent'\n\ninterface DMCheckboxItemProps {\n  checked: boolean\n  disabled?: boolean\n  onCheckedChange: (isChecked: boolean) => void\n  children: React.ReactNode\n  variant?: RowButtonProps['variant']\n  kbd?: string\n  id?: string\n}\n\nexport function DMCheckboxItem({\n  checked,\n  disabled = false,\n  variant,\n  onCheckedChange,\n  kbd,\n  id,\n  children,\n}: DMCheckboxItemProps) {\n  return (\n    <CheckboxItem\n      dir=\"ltr\"\n      onSelect={preventEvent}\n      onCheckedChange={onCheckedChange}\n      checked={checked}\n      disabled={disabled}\n      asChild\n      id={id}\n    >\n      <RowButton kbd={kbd} variant={variant} hasIndicator>\n        {children}\n      </RowButton>\n    </CheckboxItem>\n  )\n}\n", "export const preventEvent = (e: Event) => e.preventDefault()\n", "import * as DropdownMenu from '@radix-ui/react-dropdown-menu'\nimport * as React from 'react'\nimport { MenuContent } from '~components/Primitives/MenuContent'\nimport { stopPropagation } from '~components/stopPropagation'\nimport { useContainer } from '~hooks'\nimport { styled } from '~styles/stitches.config'\n\nexport interface DMContentProps {\n  variant?: 'menu' | 'horizontal'\n  align?: 'start' | 'center' | 'end'\n  alignOffset?: number\n  sideOffset?: number\n  children: React.ReactNode\n  overflow?: boolean\n  id?: string\n  side?: 'top' | 'left' | 'right' | 'bottom' | undefined\n}\n\nexport function DMContent({\n  sideOffset = 4,\n  alignOffset = 0,\n  children,\n  align,\n  variant,\n  id,\n  overflow = false,\n  side = 'bottom',\n}: DMContentProps) {\n  const container = useContainer()\n\n  return (\n    <DropdownMenu.Portal container={container.current} dir=\"ltr\">\n      <DropdownMenu.Content\n        align={align}\n        alignOffset={alignOffset}\n        sideOffset={sideOffset}\n        onEscapeKeyDown={stopPropagation}\n        asChild\n        id={id}\n        side={side}\n      >\n        <StyledContent variant={variant} overflow={overflow}>\n          {children}\n        </StyledContent>\n      </DropdownMenu.Content>\n    </DropdownMenu.Portal>\n  )\n}\n\nexport const StyledContent = styled(MenuContent, {\n  width: 'fit-content',\n  height: 'fit-content',\n  minWidth: 0,\n  maxHeight: '100vh',\n  overflowY: 'auto',\n  overflowX: 'hidden',\n  '&::webkit-scrollbar': {\n    display: 'none',\n  },\n  '-ms-overflow-style': 'none' /* for Internet Explorer, Edge */,\n  scrollbarWidth: 'none',\n  variants: {\n    variant: {\n      horizontal: {\n        flexDirection: 'row',\n      },\n      menu: {\n        minWidth: 128,\n      },\n    },\n    overflow: {\n      true: {\n        maxHeight: '60vh',\n      },\n    },\n  },\n})\n", "import type React from 'react'\n\nexport const stopPropagation = (e: KeyboardEvent | React.SyntheticEvent<any, Event>) =>\n  e.stopPropagation()\n", "import { Separator } from '@radix-ui/react-dropdown-menu'\nimport { styled } from '~styles/stitches.config'\n\nexport const DMDivider = styled(Separator, {\n  backgroundColor: '$hover',\n  height: 1,\n  marginTop: '$2',\n  marginRight: '-$2',\n  marginBottom: '$2',\n  marginLeft: '-$2',\n})\n", "import { RadioItem } from '@radix-ui/react-dropdown-menu'\nimport { styled } from '~styles/stitches.config'\n\nexport const DMRadioItem = styled(RadioItem, {\n  height: '32px',\n  width: '32px',\n  backgroundColor: '$panel',\n  borderRadius: '4px',\n  padding: '0',\n  margin: '0',\n  display: 'flex',\n  alignItems: 'center',\n  justifyContent: 'center',\n  outline: 'none',\n  border: 'none',\n  pointerEvents: 'all',\n  cursor: 'pointer',\n\n  variants: {\n    isActive: {\n      true: {\n        backgroundColor: '$selected',\n        color: 'white',\n      },\n      false: {},\n    },\n    bp: {\n      mobile: {},\n      small: {},\n    },\n  },\n\n  compoundVariants: [\n    {\n      isActive: false,\n      bp: 'small',\n      css: {\n        '&:focus': {\n          backgroundColor: '$hover',\n        },\n        '&:hover:not(:disabled)': {\n          backgroundColor: '$hover',\n        },\n      },\n    },\n  ],\n})\n", "import { Arrow, Sub, SubContent, SubTrigger } from '@radix-ui/react-dropdown-menu'\nimport * as React from 'react'\nimport { MenuContent } from '~components/Primitives/MenuContent'\nimport { RowButton } from '~components/Primitives/RowButton'\n\nexport interface DMSubMenuProps {\n  label: string\n  size?: 'small'\n  disabled?: boolean\n  children: React.ReactNode\n  overflow?: boolean\n  id?: string\n}\n\nexport function DMSubMenu({\n  children,\n  size,\n  overflow = false,\n  disabled = false,\n  label,\n  id,\n}: DMSubMenuProps) {\n  return (\n    <Sub key={id}>\n      <SubTrigger dir=\"ltr\" asChild>\n        <RowButton disabled={disabled} hasArrow>\n          {label}\n        </RowButton>\n      </SubTrigger>\n      <SubContent asChild sideOffset={4} alignOffset={-4}>\n        <MenuContent size={size} overflow={overflow}>\n          {children}\n          <Arrow offset={13} />\n        </MenuContent>\n      </SubContent>\n    </Sub>\n  )\n}\n", "import { Trigger } from '@radix-ui/react-dropdown-menu'\nimport * as React from 'react'\nimport { ToolButton, ToolButtonProps } from '~components/Primitives/ToolButton'\n\ninterface DMTriggerIconProps extends ToolButtonProps {\n  children: React.ReactNode\n  id?: string\n}\n\nexport function DMTriggerIcon({ id, children, ...rest }: DMTriggerIconProps) {\n  return (\n    <Trigger asChild id={id}>\n      <ToolButton {...rest}>{children}</ToolButton>\n    </Trigger>\n  )\n}\n", "import * as React from 'react'\nimport { FormattedMessage } from 'react-intl'\nimport { MenuContent } from '~components/Primitives/MenuContent'\nimport { RowButton } from '~components/Primitives/RowButton'\nimport { useTldrawApp } from '~hooks'\nimport { styled } from '~styles'\nimport type { TDSnapshot } from '~types'\n\nconst isEmptyCanvasSelector = (s: TDSnapshot) => {\n  return (\n    s.appState.isEmptyCanvas &&\n    Object.keys(s.document.pages[s.appState.currentPageId].shapes).length > 0\n  )\n}\n\nconst isDebugModeSelector = (s: TDSnapshot) => s.settings.isDebugMode\nconst dockPositionState = (s: TDSnapshot) => s.settings.dockPosition\n\nexport const BackToContent = React.memo(function BackToContent() {\n  const app = useTldrawApp()\n\n  const isEmptyCanvas = app.useStore(isEmptyCanvasSelector)\n  const dockPosition = app.useStore(dockPositionState)\n  const isDebugMode = app.useStore(isDebugModeSelector)\n\n  const style = {\n    bottom:\n      dockPosition === 'bottom' && isDebugMode\n        ? 120\n        : dockPosition === 'bottom'\n        ? 80\n        : isDebugMode\n        ? 60\n        : 20,\n    left: '50%',\n    transform: 'translate(-50%,0)',\n  }\n\n  if (!isEmptyCanvas) return null\n\n  return (\n    <BackToContentContainer id=\"TD-Tools-Back_to_content\" style={{ ...style }}>\n      <RowButton onClick={app.zoomToContent}>\n        <FormattedMessage id=\"zoom.to.content\" />\n      </RowButton>\n    </BackToContentContainer>\n  )\n})\n\nconst BackToContentContainer = styled(MenuContent, {\n  pointerEvents: 'all',\n  width: 'fit-content',\n  minWidth: 0,\n  position: 'fixed',\n  bottom: 0,\n})\n", "import * as React from 'react'\nimport { useIntl } from 'react-intl'\nimport { ToolButton } from '~components/Primitives/ToolButton'\nimport { Tooltip } from '~components/Primitives/Tooltip'\nimport { TrashIcon } from '~components/Primitives/icons'\nimport { useTldrawApp } from '~hooks'\n\nexport function DeleteButton() {\n  const app = useTldrawApp()\n  const intl = useIntl()\n\n  const handleDelete = React.useCallback(() => {\n    app.delete()\n  }, [app])\n\n  const hasSelection = app.useStore(\n    (s) =>\n      s.appState.status === 'idle' &&\n      s.document.pageStates[s.appState.currentPageId].selectedIds.length > 0\n  )\n\n  return (\n    <Tooltip label={intl.formatMessage({ id: 'delete' })} kbd=\"\u232B\" id=\"TD-Delete\">\n      <ToolButton\n        aria-label={intl.formatMessage({ id: 'delete' })}\n        variant=\"circle\"\n        disabled={!hasSelection}\n        onSelect={handleDelete}\n      >\n        <TrashIcon />\n      </ToolButton>\n    </Tooltip>\n  )\n}\n", "import * as React from 'react'\n\nexport function BoxIcon({\n  fill = 'none',\n  stroke = 'currentColor',\n  strokeWidth = 2,\n}: {\n  fill?: string\n  stroke?: string\n  strokeWidth?: number\n}) {\n  return (\n    <svg\n      width=\"24\"\n      height=\"24\"\n      viewBox=\"0 0 24 24\"\n      stroke={stroke}\n      strokeWidth={strokeWidth}\n      fill={fill}\n      xmlns=\"http://www.w3.org/2000/svg\"\n    >\n      <rect x=\"4\" y=\"4\" width=\"16\" height=\"16\" rx=\"2\" />\n    </svg>\n  )\n}\n", "import * as React from 'react'\n\nexport function CircleIcon(\n  props: Pick<React.SVGProps<SVGSVGElement>, 'strokeWidth' | 'stroke' | 'fill'> & {\n    size: number\n  }\n) {\n  const { size = 16, ...rest } = props\n  return (\n    <svg width={24} height={24} {...rest}>\n      <circle cx={12} cy={12} r={size / 2} />\n    </svg>\n  )\n}\n", "import * as React from 'react'\n\nexport function DashDashedIcon() {\n  return (\n    <svg width=\"24\" height=\"24\" stroke=\"currentColor\" xmlns=\"http://www.w3.org/2000/svg\">\n      <circle\n        cx={12}\n        cy={12}\n        r={8}\n        fill=\"none\"\n        strokeWidth={2.5}\n        strokeLinecap=\"round\"\n        strokeDasharray={50.26548 * 0.1}\n      />\n    </svg>\n  )\n}\n", "import * as React from 'react'\n\nconst dottedDasharray = `${50.26548 * 0.025} ${50.26548 * 0.1}`\n\nexport function DashDottedIcon() {\n  return (\n    <svg width=\"24\" height=\"24\" stroke=\"currentColor\" xmlns=\"http://www.w3.org/2000/svg\">\n      <circle\n        cx={12}\n        cy={12}\n        r={8}\n        fill=\"none\"\n        strokeWidth={2.5}\n        strokeLinecap=\"round\"\n        strokeDasharray={dottedDasharray}\n      />\n    </svg>\n  )\n}\n", "import * as React from 'react'\n\nexport function DashDrawIcon() {\n  return (\n    <svg\n      width=\"24\"\n      height=\"24\"\n      viewBox=\"1 1.5 21 22\"\n      fill=\"currentColor\"\n      stroke=\"currentColor\"\n      xmlns=\"http://www.w3.org/2000/svg\"\n    >\n      <path\n        d=\"M10.0162 19.2768C10.0162 19.2768 9.90679 19.2517 9.6879 19.2017C9.46275 19.1454 9.12816 19.0422 8.68413 18.8921C8.23384 18.7358 7.81482 18.545 7.42707 18.3199C7.03307 18.101 6.62343 17.7883 6.19816 17.3818C5.77289 16.9753 5.33511 16.3718 4.88482 15.5713C4.43453 14.7645 4.1531 13.8545 4.04053 12.8414C3.92795 11.822 4.04991 10.8464 4.40639 9.91451C4.76286 8.98266 5.39452 8.10084 6.30135 7.26906C7.21444 6.44353 8.29325 5.83377 9.5378 5.43976C10.7823 5.05202 11.833 4.92068 12.6898 5.04576C13.5466 5.16459 14.3878 5.43664 15.2133 5.86191C16.0388 6.28718 16.7768 6.8688 17.4272 7.60678C18.0714 8.34475 18.5404 9.21406 18.8344 10.2147C19.1283 11.2153 19.1721 12.2598 18.9657 13.348C18.7593 14.4299 18.2872 15.4337 17.5492 16.3593C16.8112 17.2849 15.9263 18.0072 14.8944 18.5263C13.8624 19.0391 12.9056 19.3174 12.0238 19.3612C11.142 19.405 10.2101 19.2705 9.22823 18.9578C8.24635 18.6451 7.35828 18.151 6.56402 17.4756C5.77601 16.8002 6.08871 16.8658 7.50212 17.6726C8.90927 18.4731 10.1444 18.8484 11.2076 18.7983C12.2645 18.7545 13.2965 18.4825 14.3034 17.9822C15.3102 17.4819 16.1264 16.8221 16.7518 16.0028C17.3772 15.1835 17.7681 14.3111 17.9244 13.3855C18.0808 12.4599 18.0401 11.5781 17.8025 10.74C17.5586 9.902 17.1739 9.15464 16.6486 8.49797C16.1233 7.8413 15.2289 7.27844 13.9656 6.80939C12.7086 6.34034 11.4203 6.20901 10.1007 6.41539C8.78732 6.61552 7.69599 7.06893 6.82669 7.77564C5.96363 8.48859 5.34761 9.26409 4.97863 10.1021C4.60964 10.9402 4.45329 11.8376 4.50958 12.7945C4.56586 13.7513 4.79101 14.6238 5.18501 15.4118C5.57276 16.1998 5.96363 16.8002 6.35764 17.2129C6.75164 17.6257 7.13313 17.9509 7.50212 18.1886C7.87736 18.4325 8.28074 18.642 8.71227 18.8171C9.15005 18.9922 9.47839 19.111 9.69728 19.1736C9.91617 19.2361 10.0256 19.2705 10.0256 19.2768H10.0162Z\"\n        strokeWidth=\"2\"\n      />\n    </svg>\n  )\n}\n", "import * as React from 'react'\n\nexport function DashSolidIcon() {\n  return (\n    <svg width=\"24\" height=\"24\" stroke=\"currentColor\" xmlns=\"http://www.w3.org/2000/svg\">\n      <circle cx={12} cy={12} r={8} fill=\"none\" strokeWidth={2} strokeLinecap=\"round\" />\n    </svg>\n  )\n}\n", "import * as React from 'react'\n\nexport function TrashIcon(props: React.SVGProps<SVGSVGElement>) {\n  return (\n    <svg\n      width={18}\n      height={18}\n      viewBox=\"0 0 15 15\"\n      fill=\"currentColor\"\n      xmlns=\"http://www.w3.org/2000/svg\"\n      {...props}\n    >\n      <path\n        fillRule=\"evenodd\"\n        clipRule=\"evenodd\"\n        d=\"M2 4.656a.5.5 0 01.5-.5h9.7a.5.5 0 010 1H2.5a.5.5 0 01-.5-.5z\"\n      />\n      <path\n        fillRule=\"evenodd\"\n        clipRule=\"evenodd\"\n        d=\"M6.272 3a.578.578 0 00-.578.578v.578h3.311v-.578A.578.578 0 008.428 3H6.272zm3.733 1.156v-.578A1.578 1.578 0 008.428 2H6.272a1.578 1.578 0 00-1.578 1.578v.578H3.578a.5.5 0 00-.5.5V12.2a1.578 1.578 0 001.577 1.578h5.39a1.578 1.578 0 001.577-1.578V4.656a.5.5 0 00-.5-.5h-1.117zm-5.927 1V12.2a.578.578 0 00.577.578h5.39a.578.578 0 00.577-.578V5.156H4.078z\"\n      />\n      <path\n        fillRule=\"evenodd\"\n        clipRule=\"evenodd\"\n        d=\"M6.272 6.85a.5.5 0 01.5.5v3.233a.5.5 0 11-1 0V7.35a.5.5 0 01.5-.5zM8.428 6.85a.5.5 0 01.5.5v3.233a.5.5 0 11-1 0V7.35a.5.5 0 01.5-.5z\"\n      />\n    </svg>\n  )\n}\n", "import * as React from 'react'\n\nexport function UndoIcon({\n  flipHorizontal,\n  ...props\n}: React.SVGProps<SVGSVGElement> & { flipHorizontal?: boolean }) {\n  return (\n    <svg\n      width={24}\n      height={24}\n      viewBox=\"0 0 15 15\"\n      fill=\"currentColor\"\n      xmlns=\"http://www.w3.org/2000/svg\"\n      style={{\n        transform: flipHorizontal ? 'scale(-1, 1)' : 'scale(1, 1)',\n      }}\n      {...props}\n    >\n      <path d=\"M10.6707 8.5081C10.6707 10.1923 9.3004 11.5625 7.61631 11.5625H6.5351C6.35593 11.5625 6.21074 11.4173 6.21074 11.2382V11.13C6.21074 10.9508 6.35591 10.8057 6.5351 10.8057H7.61631C8.88313 10.8057 9.91387 9.77492 9.91387 8.5081C9.91387 7.24128 8.88313 6.21054 7.61631 6.21054H5.62155L6.99534 7.58433C7.14289 7.73183 7.14289 7.97195 6.99534 8.11944C6.85216 8.26251 6.60298 8.2623 6.46013 8.11944L4.44045 6.09971C4.36898 6.02824 4.32959 5.93321 4.32959 5.8321C4.32959 5.73106 4.36898 5.63598 4.44045 5.56454L6.46024 3.54472C6.60309 3.40176 6.85248 3.40176 6.99535 3.54472C7.14291 3.69218 7.14291 3.93234 6.99535 4.07979L5.62156 5.45368H7.61631C9.3004 5.45368 10.6707 6.82393 10.6707 8.5081Z\" />\n    </svg>\n  )\n}\n", "import * as React from 'react'\n\nexport function SizeSmallIcon(props: React.SVGProps<SVGSVGElement>) {\n  return (\n    <svg\n      width={24}\n      height={24}\n      viewBox=\"-2 -2 28 28\"\n      fill=\"currentColor\"\n      xmlns=\"http://www.w3.org/2000/svg\"\n      {...props}\n    >\n      <path d=\"M12.4239 4.62C13.3572 4.62 14.1572 4.73333 14.8239 4.96C15.4906 5.17333 15.9772 5.43333 16.2839 5.74C16.3639 5.82 16.4039 5.94 16.4039 6.1V8.86H14.0639C13.9172 8.86 13.8439 8.78666 13.8439 8.64V7.26C13.4306 7.12666 12.9572 7.06 12.4239 7.06C11.6506 7.06 11.0639 7.18 10.6639 7.42C10.2639 7.66 10.0639 8.04666 10.0639 8.58V9C10.0639 9.38666 10.1639 9.69333 10.3639 9.92C10.5772 10.1333 11.0306 10.3467 11.7239 10.56L13.6439 11.14C14.4706 11.38 15.1172 11.66 15.5839 11.98C16.0506 12.3 16.3772 12.68 16.5639 13.12C16.7639 13.5467 16.8639 14.0733 16.8639 14.7V15.62C16.8639 16.7933 16.4039 17.7133 15.4839 18.38C14.5639 19.0467 13.2839 19.38 11.6439 19.38C10.6706 19.38 9.79723 19.2867 9.0239 19.1C8.2639 18.9133 7.71056 18.6533 7.3639 18.32C7.3239 18.28 7.29056 18.24 7.2639 18.2C7.25056 18.1467 7.2439 18.06 7.2439 17.94V15.74H7.6239C8.2239 16.1533 8.85056 16.4533 9.5039 16.64C10.1572 16.8267 10.9306 16.92 11.8239 16.92C12.6506 16.92 13.2506 16.7867 13.6239 16.52C14.0106 16.2533 14.2039 15.9333 14.2039 15.56V14.88C14.2039 14.6667 14.1639 14.48 14.0839 14.32C14.0172 14.16 13.8706 14.0133 13.6439 13.88C13.4172 13.7467 13.0572 13.6067 12.5639 13.46L10.6639 12.88C9.7839 12.6133 9.11056 12.3 8.6439 11.94C8.17723 11.58 7.85056 11.18 7.6639 10.74C7.49056 10.3 7.4039 9.83333 7.4039 9.34V8.38C7.4039 7.64666 7.61056 7 8.0239 6.44C8.43723 5.88 9.01723 5.44 9.7639 5.12C10.5239 4.78666 11.4106 4.62 12.4239 4.62Z\" />\n    </svg>\n  )\n}\n", "import * as React from 'react'\n\nexport function SizeMediumIcon(props: React.SVGProps<SVGSVGElement>) {\n  return (\n    <svg\n      width={24}\n      height={24}\n      viewBox=\"-2 -2 28 28\"\n      fill=\"currentColor\"\n      xmlns=\"http://www.w3.org/2000/svg\"\n      {...props}\n    >\n      <path d=\"M8.16191 19H5.68191C5.53525 19 5.46191 18.9267 5.46191 18.78V5H8.76191C8.88191 5 8.97525 5.03333 9.04191 5.1C9.10858 5.15333 9.17525 5.27333 9.24191 5.46C9.72191 6.59333 10.1686 7.7 10.5819 8.78C11.0086 9.84667 11.4352 10.98 11.8619 12.18H12.1619C12.6019 10.9667 13.0352 9.79333 13.4619 8.66C13.8886 7.52667 14.3552 6.30667 14.8619 5H18.3219C18.4686 5 18.5419 5.07333 18.5419 5.22V19H16.0619C15.9152 19 15.8419 18.9267 15.8419 18.78V16.26C15.8419 15.5267 15.8486 14.8133 15.8619 14.12C15.8886 13.4267 15.9286 12.6867 15.9819 11.9C16.0486 11.1 16.1419 10.1933 16.2619 9.18H15.9019C15.4352 10.3533 14.9486 11.5667 14.4419 12.82C13.9486 14.06 13.4819 15.2333 13.0419 16.34H11.1019C11.0619 16.34 11.0152 16.3333 10.9619 16.32C10.9219 16.2933 10.8886 16.2467 10.8619 16.18C10.4619 15.18 10.0086 14.06 9.50191 12.82C9.00858 11.58 8.53525 10.3667 8.08191 9.18H7.70191C7.83525 10.18 7.93525 11.0733 8.00191 11.86C8.06858 12.6467 8.10858 13.3933 8.12191 14.1C8.14858 14.8067 8.16191 15.5267 8.16191 16.26V19Z\" />\n    </svg>\n  )\n}\n", "import * as React from 'react'\n\nexport function SizeLargeIcon(props: React.SVGProps<SVGSVGElement>) {\n  return (\n    <svg\n      width={24}\n      height={24}\n      viewBox=\"-2 -2 28 28\"\n      fill=\"currentColor\"\n      xmlns=\"http://www.w3.org/2000/svg\"\n      {...props}\n    >\n      <path d=\"M7.68191 19C7.53525 19 7.46191 18.9267 7.46191 18.78V5H10.1219C10.2686 5 10.3419 5.07333 10.3419 5.22V16.56H13.4419V15.02H15.7619C15.9086 15.02 15.9819 15.0933 15.9819 15.24V19H7.68191Z\" />\n    </svg>\n  )\n}\n", "import * as React from 'react'\n\nexport function EraserIcon() {\n  return (\n    <svg width=\"15\" height=\"15\" viewBox=\"0 0 15 15\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n      <path\n        d=\"M1.72838 9.33987L8.84935 2.34732C9.23874 1.96494 9.86279 1.96539 10.2516 2.34831L13.5636 5.60975C13.9655 6.00555 13.9607 6.65526 13.553 7.04507L8.13212 12.2278C7.94604 12.4057 7.69851 12.505 7.44107 12.505L6.06722 12.505L3.83772 12.505C3.5673 12.505 3.30842 12.3954 3.12009 12.2014L1.7114 10.7498C1.32837 10.3551 1.33596 9.72521 1.72838 9.33987Z\"\n        stroke=\"currentColor\"\n      />\n      <line\n        x1=\"6.01807\"\n        y1=\"12.5\"\n        x2=\"10.7959\"\n        y2=\"12.5\"\n        stroke=\"currentColor\"\n        strokeLinecap=\"round\"\n      />\n      <line x1=\"5.50834\" y1=\"5.74606\" x2=\"10.1984\" y2=\"10.4361\" stroke=\"currentColor\" />\n    </svg>\n  )\n}\n", "import * as React from 'react'\n\nexport function DiscordIcon() {\n  return (\n    <svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      width=\"16\"\n      height=\"16\"\n      fill=\"currentColor\"\n      viewBox=\"0 0 16 16\"\n    >\n      <path d=\"M13.545 2.907a13.227 13.227 0 0 0-3.257-1.011.05.05 0 0 0-.052.025c-.141.25-.297.577-.406.833a12.19 12.19 0 0 0-3.658 0 8.258 8.258 0 0 0-.412-.833.051.051 0 0 0-.052-.025c-1.125.194-2.22.534-3.257 1.011a.041.041 0 0 0-.021.018C.356 6.024-.213 9.047.066 12.032c.001.014.01.028.021.037a13.276 13.276 0 0 0 3.995 2.02.05.05 0 0 0 .056-.019c.308-.42.582-.863.818-1.329a.05.05 0 0 0-.01-.059.051.051 0 0 0-.018-.011 8.875 8.875 0 0 1-1.248-.595.05.05 0 0 1-.02-.066.051.051 0 0 1 .015-.019c.084-.063.168-.129.248-.195a.05.05 0 0 1 .051-.007c2.619 1.196 5.454 1.196 8.041 0a.052.052 0 0 1 .053.007c.08.066.164.132.248.195a.051.051 0 0 1-.004.085 8.254 8.254 0 0 1-1.249.594.05.05 0 0 0-.03.03.052.052 0 0 0 .003.041c.24.465.515.909.817 1.329a.05.05 0 0 0 .056.019 13.235 13.235 0 0 0 4.001-2.02.049.049 0 0 0 .021-.037c.334-3.451-.559-6.449-2.366-9.106a.034.034 0 0 0-.02-.019Zm-8.198 7.307c-.789 0-1.438-.724-1.438-1.612 0-.889.637-1.613 1.438-1.613.807 0 1.45.73 1.438 1.613 0 .888-.637 1.612-1.438 1.612Zm5.316 0c-.788 0-1.438-.724-1.438-1.612 0-.889.637-1.613 1.438-1.613.807 0 1.451.73 1.438 1.613 0 .888-.631 1.612-1.438 1.612Z\" />\n    </svg>\n  )\n}\n", "import * as React from 'react'\n\nexport function LineIcon() {\n  return (\n    <svg\n      width=\"15\"\n      height=\"15\"\n      viewBox=\"0 0 15 15\"\n      fill=\"currentColor\"\n      xmlns=\"http://www.w3.org/2000/svg\"\n    >\n      <path d=\"M3.64645 11.3536C3.45118 11.1583 3.45118 10.8417 3.64645 10.6465L11.1464 3.14645C11.3417 2.95118 11.6583 2.95118 11.8536 3.14645C12.0488 3.34171 12.0488 3.65829 11.8536 3.85355L4.35355 11.3536C4.15829 11.5488 3.84171 11.5488 3.64645 11.3536Z\" />\n    </svg>\n  )\n}\n", "import * as DropdownMenu from '@radix-ui/react-dropdown-menu'\nimport {\n  ExternalLinkIcon,\n  GitHubLogoIcon,\n  HeartFilledIcon,\n  QuestionMarkIcon,\n  TwitterLogoIcon,\n} from '@radix-ui/react-icons'\nimport * as Popover from '@radix-ui/react-popover'\nimport * as React from 'react'\nimport { FormattedMessage } from 'react-intl'\nimport { Divider } from '~components/Primitives/Divider'\nimport { MenuContent } from '~components/Primitives/MenuContent'\nimport { RowButton } from '~components/Primitives/RowButton'\nimport { SmallIcon } from '~components/Primitives/SmallIcon'\nimport { DiscordIcon } from '~components/Primitives/icons'\nimport { LanguageMenu } from '~components/TopPanel/LanguageMenu/LanguageMenu'\nimport { breakpoints } from '~components/breakpoints'\nimport { useTldrawApp } from '~hooks'\nimport { styled } from '~styles'\nimport { TDSnapshot } from '~types'\nimport { KeyboardShortcutDialog } from './KeyboardShortcutDialog'\n\nconst isDebugModeSelector = (s: TDSnapshot) => s.settings.isDebugMode\nconst dockPositionState = (s: TDSnapshot) => s.settings.dockPosition\n\nexport function HelpPanel() {\n  const app = useTldrawApp()\n  const isDebugMode = app.useStore(isDebugModeSelector)\n  const side = app.useStore(dockPositionState)\n\n  const [isKeyboardShortcutsOpen, setIsKeyboardShortcutsOpen] = React.useState(false)\n\n  return (\n    <Popover.Root>\n      <PopoverAnchor dir=\"ltr\" debug={isDebugMode} side={side} bp={breakpoints}>\n        <Popover.Trigger dir=\"ltr\" asChild>\n          <HelpButton>\n            <QuestionMarkIcon />\n          </HelpButton>\n        </Popover.Trigger>\n      </PopoverAnchor>\n      <Popover.Content dir=\"ltr\" align=\"end\" side=\"top\" alignOffset={10} sideOffset={8} asChild>\n        <StyledContent style={{ visibility: isKeyboardShortcutsOpen ? 'hidden' : 'visible' }}>\n          <LanguageMenuDropdown />\n          <KeyboardShortcutDialog onOpenChange={setIsKeyboardShortcutsOpen} />\n          <Divider />\n          <Links />\n        </StyledContent>\n      </Popover.Content>\n    </Popover.Root>\n  )\n}\n\nconst LanguageMenuDropdown = () => {\n  return (\n    <DropdownMenu.Root dir=\"ltr\">\n      <DropdownMenu.Trigger asChild>\n        <RowButton variant=\"wide\" hasArrow>\n          <FormattedMessage id=\"language\" />\n        </RowButton>\n      </DropdownMenu.Trigger>\n      <LanguageMenu />\n    </DropdownMenu.Root>\n  )\n}\n\nconst linksData = [\n  { id: 'tldraw-beta', icon: ExternalLinkIcon, url: 'https://beta.tldraw.com' },\n  { id: 'github', icon: GitHubLogoIcon, url: 'https://github.com/tldraw/tldraw' },\n  { id: 'twitter', icon: TwitterLogoIcon, url: 'https://twitter.com/tldraw' },\n  { id: 'discord', icon: DiscordIcon, url: 'https://discord.gg/SBBEVCA4PG' },\n  {\n    id: 'become.a.sponsor',\n    icon: HeartFilledIcon,\n    url: 'https://github.com/sponsors/steveruizok',\n  },\n]\n\nconst Links = () => {\n  return (\n    <>\n      {linksData.map((item) => (\n        <a key={item.id} href={item.url} target=\"_blank\" rel=\"nofollow\">\n          <RowButton id={`TD-Link-${item.id}`} variant=\"wide\">\n            <FormattedMessage id={item.id} />\n            <SmallIcon>\n              <item.icon />\n            </SmallIcon>\n          </RowButton>\n        </a>\n      ))}\n    </>\n  )\n}\n\nconst HelpButton = styled('button', {\n  width: 32,\n  height: 32,\n  borderRadius: '100%',\n  display: 'flex',\n  padding: 0,\n  justifyContent: 'center',\n  alignItems: 'center',\n  outline: 'none',\n  backgroundColor: '$panel',\n  cursor: 'pointer',\n  boxShadow: '$panel',\n  border: '1px solid $panelContrast',\n  color: '$text',\n  '& svg': {\n    height: 12,\n    width: 12,\n  },\n})\n\nexport const StyledContent = styled(MenuContent, {\n  width: 'fit-content',\n  height: 'fit-content',\n  minWidth: 200,\n  maxHeight: 380,\n  overflowY: 'auto',\n  '& *': {\n    boxSizing: 'border-box',\n  },\n  '& a': {\n    outline: 'none',\n  },\n  variants: {\n    variant: {\n      horizontal: {\n        flexDirection: 'row',\n      },\n      menu: {\n        minWidth: 128,\n      },\n    },\n  },\n})\n\nconst PopoverAnchor = styled(Popover.Anchor, {\n  position: 'absolute',\n  zIndex: 999,\n  right: 10,\n  bottom: 10,\n  width: 32,\n  height: 32,\n  variants: {\n    debug: {\n      true: {},\n      false: {},\n    },\n    bp: {\n      mobile: {\n        bottom: 64,\n      },\n      small: {\n        bottom: 10,\n      },\n      medium: {},\n      large: {},\n    },\n    side: {\n      top: {},\n      left: {},\n      right: {},\n      bottom: {},\n    },\n  },\n  compoundVariants: [\n    {\n      bp: 'mobile',\n      side: 'bottom',\n      debug: true,\n      css: {\n        bottom: 104,\n      },\n    },\n    {\n      bp: 'small',\n      side: 'bottom',\n      debug: true,\n      css: {\n        bottom: 50,\n      },\n    },\n  ],\n})\n", "import { ExternalLinkIcon } from '@radix-ui/react-icons'\nimport * as React from 'react'\nimport { FormattedMessage } from 'react-intl'\nimport { Divider } from '~components/Primitives/Divider'\nimport { DMCheckboxItem, DMContent, DMItem } from '~components/Primitives/DropdownMenu'\nimport { SmallIcon } from '~components/Primitives/SmallIcon'\nimport { useTldrawApp } from '~hooks'\nimport { TDLanguage, TRANSLATIONS } from '~translations'\nimport { TDSnapshot } from '~types'\n\nconst languageSelector = (s: TDSnapshot) => s.settings.language\n\nexport const LanguageMenu = () => {\n  const app = useTldrawApp()\n  const language = app.useStore(languageSelector)\n\n  const handleChangeLanguage = React.useCallback(\n    (locale: TDLanguage) => {\n      app.setSetting('language', locale)\n    },\n    [app]\n  )\n\n  return (\n    <DMContent variant=\"menu\" overflow id=\"language-menu\" side=\"left\" sideOffset={8}>\n      {TRANSLATIONS.map(({ locale, label }) => (\n        <DMCheckboxItem\n          key={locale}\n          checked={language === locale}\n          onCheckedChange={() => handleChangeLanguage(locale)}\n          id={`TD-MenuItem-Language-${locale}`}\n        >\n          {label}\n        </DMCheckboxItem>\n      ))}\n      <Divider />\n      <a\n        href=\"https://github.com/tldraw/tldraw/blob/main/guides/translation.md\"\n        target=\"_blank\"\n        rel=\"nofollow\"\n      >\n        <DMItem id=\"TD-MenuItem-Translation-Link\">\n          <FormattedMessage id=\"translation.link\" />\n          <SmallIcon>\n            <ExternalLinkIcon />\n          </SmallIcon>\n        </DMItem>\n      </a>\n    </DMContent>\n  )\n}\n", "import * as Dialog from '@radix-ui/react-dialog'\nimport { Cross2Icon } from '@radix-ui/react-icons'\nimport * as React from 'react'\nimport { FormattedMessage, useIntl } from 'react-intl'\nimport { IconButton } from '~components/Primitives/IconButton'\nimport { Kbd } from '~components/Primitives/Kbd'\nimport { RowButton } from '~components/Primitives/RowButton'\nimport { breakpoints } from '~components/breakpoints'\nimport { useContainer } from '~hooks'\nimport { styled } from '~styles'\n\nexport function KeyboardShortcutDialog({\n  onOpenChange,\n}: {\n  onOpenChange?: (open: boolean) => void\n}) {\n  const intl = useIntl()\n  const container = useContainer()\n\n  const shortcuts = {\n    Tools: [\n      { label: intl.formatMessage({ id: 'select' }), kbd: '1' },\n      { label: intl.formatMessage({ id: 'draw' }), kbd: '2' },\n      { label: intl.formatMessage({ id: 'eraser' }), kbd: '3' },\n      { label: intl.formatMessage({ id: 'rectangle' }), kbd: '4' },\n      { label: intl.formatMessage({ id: 'ellipse' }), kbd: '5' },\n      { label: intl.formatMessage({ id: 'triangle' }), kbd: '6' },\n      { label: intl.formatMessage({ id: 'line' }), kbd: '7' },\n      { label: intl.formatMessage({ id: 'arrow' }), kbd: '8' },\n      { label: intl.formatMessage({ id: 'text' }), kbd: '9' },\n      { label: intl.formatMessage({ id: 'sticky' }), kbd: '0' },\n    ],\n    View: [\n      { label: intl.formatMessage({ id: 'zoom.in' }), kbd: '#+' },\n      { label: intl.formatMessage({ id: 'zoom.out' }), kbd: '#-' },\n      { label: `${intl.formatMessage({ id: 'zoom.to' })} 100%`, kbd: '\u21E7+0' },\n      { label: intl.formatMessage({ id: 'zoom.to.fit' }), kbd: '\u21E7+1' },\n      { label: intl.formatMessage({ id: 'zoom.to.selection' }), kbd: '\u21E7+2' },\n      { label: intl.formatMessage({ id: 'preferences.dark.mode' }), kbd: '#\u21E7D' },\n      { label: intl.formatMessage({ id: 'preferences.focus.mode' }), kbd: '#.' },\n      { label: intl.formatMessage({ id: 'preferences.show.grid' }), kbd: '#\u21E7G' },\n    ],\n    Transform: [\n      { label: intl.formatMessage({ id: 'flip.horizontal' }), kbd: '\u21E7H' },\n      { label: intl.formatMessage({ id: 'flip.vertical' }), kbd: '\u21E7V' },\n      {\n        label: `${intl.formatMessage({ id: 'lock' })} / ${intl.formatMessage({ id: 'unlock' })}`,\n        kbd: '#\u21E7L',\n      },\n      {\n        label: `${intl.formatMessage({ id: 'move' })} ${intl.formatMessage({ id: 'to.front' })}`,\n        kbd: '\u21E7]',\n      },\n      {\n        label: `${intl.formatMessage({ id: 'move' })} ${intl.formatMessage({ id: 'forward' })}`,\n        kbd: ']',\n      },\n      {\n        label: `${intl.formatMessage({ id: 'move' })} ${intl.formatMessage({ id: 'backward' })}`,\n        kbd: '[',\n      },\n      {\n        label: `${intl.formatMessage({ id: 'move' })} ${intl.formatMessage({ id: 'back' })}`,\n        kbd: '\u21E7[',\n      },\n    ],\n    File: [\n      { label: intl.formatMessage({ id: 'new.project' }), kbd: '#N' },\n      { label: intl.formatMessage({ id: 'open' }), kbd: '#O' },\n      { label: intl.formatMessage({ id: 'save' }), kbd: '#S' },\n      { label: intl.formatMessage({ id: 'save.as' }), kbd: '#\u21E7S' },\n      { label: intl.formatMessage({ id: 'upload.media' }), kbd: '#U' },\n    ],\n    Edit: [\n      { label: intl.formatMessage({ id: 'undo' }), kbd: '#Z' },\n      { label: intl.formatMessage({ id: 'redo' }), kbd: '#\u21E7Z' },\n      { label: intl.formatMessage({ id: 'cut' }), kbd: '#X' },\n      { label: intl.formatMessage({ id: 'copy' }), kbd: '#C' },\n      { label: intl.formatMessage({ id: 'paste' }), kbd: '#V' },\n      { label: intl.formatMessage({ id: 'select.all' }), kbd: '#A' },\n      { label: intl.formatMessage({ id: 'delete' }), kbd: '\u232B' },\n      { label: intl.formatMessage({ id: 'duplicate' }), kbd: '#D' },\n    ],\n  }\n\n  return (\n    <Dialog.Root onOpenChange={onOpenChange}>\n      {/* // todo: hide if no keyboard is attached */}\n      <Dialog.Trigger asChild>\n        <RowButton id=\"TD-HelpItem-Keyboard\" variant=\"wide\">\n          <FormattedMessage id=\"keyboard.shortcuts\" />\n        </RowButton>\n      </Dialog.Trigger>\n      <Dialog.Portal container={container.current}>\n        <DialogOverlay />\n        <DialogContent>\n          <DialogTitle>\n            <FormattedMessage id=\"keyboard.shortcuts\" />\n            <Dialog.Close asChild>\n              <DialogIconButton>\n                <Cross2Icon />\n              </DialogIconButton>\n            </Dialog.Close>\n          </DialogTitle>\n          <StyledColumns bp={breakpoints}>\n            {Object.entries(shortcuts).map(([key, value]) => (\n              <StyledSection key={key}>\n                <Label>\n                  <FormattedMessage id={`menu.${key.toLocaleLowerCase()}`} />\n                </Label>\n                <ContentItem>\n                  {value.map((shortcut) => (\n                    <StyledItem key={shortcut.label}>\n                      {shortcut.label}\n                      <Kbd variant=\"menu\">{shortcut.kbd}</Kbd>\n                    </StyledItem>\n                  ))}\n                </ContentItem>\n              </StyledSection>\n            ))}\n          </StyledColumns>\n        </DialogContent>\n      </Dialog.Portal>\n    </Dialog.Root>\n  )\n}\n\nconst Label = styled('h3', {\n  fontSize: '$2',\n  color: '$text',\n  fontFamily: '$ui',\n  margin: 0,\n  paddingBottom: '$5',\n})\n\nconst StyledSection = styled('div', {\n  breakInside: 'avoid',\n  paddingBottom: 24,\n})\n\nconst ContentItem = styled('ul', {\n  listStyleType: 'none',\n  width: '100%',\n  padding: 0,\n  margin: 0,\n})\n\nconst StyledItem = styled('li', {\n  display: 'flex',\n  alignItems: 'center',\n  justifyContent: 'space-between',\n  height: 32,\n  minHeight: 32,\n  width: '100%',\n  outline: 'none',\n  color: '$text',\n  fontFamily: '$ui',\n  fontWeight: 400,\n  fontSize: '$1',\n  borderRadius: 4,\n  userSelect: 'none',\n  margin: 0,\n  padding: '0 0',\n})\n\nconst DialogContent = styled(Dialog.Content, {\n  borderRadius: 6,\n  boxShadow: 'hsl(206 22% 7% / 35%) 0px 10px 38px -10px, hsl(206 22% 7% / 20%) 0px 10px 20px -15px',\n  position: 'fixed',\n  top: '50%',\n  left: '50%',\n  transform: 'translate(-50%, -50%)',\n  width: 'fit-content',\n  maxWidth: '90vw',\n  maxHeight: '74vh',\n  overflowY: 'auto',\n  padding: 25,\n  zIndex: 9999,\n  pointerEvents: 'all',\n  background: '$panel',\n  '&:focus': { outline: 'none' },\n})\n\nconst StyledColumns = styled('div', {\n  maxWidth: '100%',\n  width: 'fit-content',\n  height: 'fit-content',\n  overflowY: 'auto',\n  columnGap: 64,\n  variants: {\n    bp: {\n      mobile: {\n        columns: 1,\n        [`& ${StyledSection}`]: {\n          minWidth: '0px',\n        },\n      },\n      small: {\n        columns: 2,\n        [`& ${StyledSection}`]: {\n          minWidth: '200px',\n        },\n      },\n      medium: {\n        columns: 3,\n      },\n      large: {\n        columns: 3,\n      },\n    },\n  },\n})\n\nconst DialogOverlay = styled(Dialog.Overlay, {\n  backgroundColor: '$overlay',\n  position: 'fixed',\n  inset: 0,\n  zIndex: 9998,\n})\n\nconst DialogIconButton = styled(IconButton, {\n  fontFamily: 'inherit',\n  borderRadius: '100%',\n  height: 25,\n  width: 25,\n  display: 'inline-flex',\n  alignItems: 'center',\n  justifyContent: 'center',\n  color: '$text',\n  cursor: 'pointer',\n  '&:hover': { backgroundColor: '$hover' },\n})\n\nconst DialogTitle = styled(Dialog.Title, {\n  fontFamily: '$body',\n  fontSize: '$3',\n  color: '$text',\n  paddingBottom: 32,\n  display: 'flex',\n  alignItems: 'center',\n  justifyContent: 'space-between',\n  margin: 0,\n})\n", "import {\n  ArrowTopRightIcon,\n  CursorArrowIcon,\n  ImageIcon,\n  Pencil1Icon,\n  Pencil2Icon,\n  TextIcon,\n} from '@radix-ui/react-icons'\nimport * as React from 'react'\nimport { useIntl } from 'react-intl'\nimport { Panel } from '~components/Primitives/Panel'\nimport { ToolButtonWithTooltip } from '~components/Primitives/ToolButton'\nimport { EraserIcon } from '~components/Primitives/icons'\nimport { breakpoints } from '~components/breakpoints'\nimport { useTldrawApp } from '~hooks'\nimport { styled } from '~styles/stitches.config'\nimport { TDShapeType, TDSnapshot } from '~types'\nimport { ShapesMenu } from './ShapesMenu'\n\nconst activeToolSelector = (s: TDSnapshot) => s.appState.activeTool\nconst toolLockedSelector = (s: TDSnapshot) => s.appState.isToolLocked\nconst dockPositionState = (s: TDSnapshot) => s.settings.dockPosition\n\nexport const PrimaryTools = React.memo(function PrimaryTools() {\n  const app = useTldrawApp()\n  const intl = useIntl()\n\n  const activeTool = app.useStore(activeToolSelector)\n\n  const isToolLocked = app.useStore(toolLockedSelector)\n  const dockPosition = app.useStore(dockPositionState)\n\n  const selectSelectTool = React.useCallback(() => {\n    app.selectTool('select')\n  }, [app])\n\n  const selectEraseTool = React.useCallback(() => {\n    app.selectTool('erase')\n  }, [app])\n\n  const selectDrawTool = React.useCallback(() => {\n    app.selectTool(TDShapeType.Draw)\n  }, [app])\n\n  const selectArrowTool = React.useCallback(() => {\n    app.selectTool(TDShapeType.Arrow)\n  }, [app])\n\n  const selectTextTool = React.useCallback(() => {\n    app.selectTool(TDShapeType.Text)\n  }, [app])\n\n  const selectStickyTool = React.useCallback(() => {\n    app.selectTool(TDShapeType.Sticky)\n  }, [app])\n\n  const uploadMedias = React.useCallback(async () => {\n    app.openAsset()\n  }, [app])\n\n  const panelStyle = dockPosition === 'bottom' || dockPosition === 'top' ? 'row' : 'column'\n\n  return (\n    <StyledPanel\n      side=\"center\"\n      id=\"TD-PrimaryTools\"\n      style={{ flexDirection: panelStyle }}\n      bp={breakpoints}\n    >\n      <ToolButtonWithTooltip\n        kbd={'1'}\n        label={intl.formatMessage({ id: 'select' })}\n        onClick={selectSelectTool}\n        isActive={activeTool === 'select'}\n        id=\"TD-PrimaryTools-CursorArrow\"\n      >\n        <CursorArrowIcon />\n      </ToolButtonWithTooltip>\n      <ToolButtonWithTooltip\n        kbd={'2'}\n        label={intl.formatMessage({ id: 'draw' })}\n        onClick={selectDrawTool}\n        isActive={activeTool === TDShapeType.Draw}\n        id=\"TD-PrimaryTools-Pencil\"\n      >\n        <Pencil1Icon />\n      </ToolButtonWithTooltip>\n      <ToolButtonWithTooltip\n        kbd={'3'}\n        label={intl.formatMessage({ id: 'eraser' })}\n        onClick={selectEraseTool}\n        isActive={activeTool === 'erase'}\n        id=\"TD-PrimaryTools-Eraser\"\n      >\n        <EraserIcon />\n      </ToolButtonWithTooltip>\n      <ShapesMenu activeTool={activeTool} isToolLocked={isToolLocked} />\n      <ToolButtonWithTooltip\n        kbd={'8'}\n        label={intl.formatMessage({ id: 'arrow' })}\n        onClick={selectArrowTool}\n        isLocked={isToolLocked}\n        isActive={activeTool === TDShapeType.Arrow}\n        id=\"TD-PrimaryTools-ArrowTopRight\"\n      >\n        <ArrowTopRightIcon />\n      </ToolButtonWithTooltip>\n      <ToolButtonWithTooltip\n        kbd={'9'}\n        label={intl.formatMessage({ id: 'text' })}\n        onClick={selectTextTool}\n        isLocked={isToolLocked}\n        isActive={activeTool === TDShapeType.Text}\n        id=\"TD-PrimaryTools-Text\"\n      >\n        <TextIcon />\n      </ToolButtonWithTooltip>\n      <ToolButtonWithTooltip\n        kbd={'0'}\n        label={intl.formatMessage({ id: 'sticky' })}\n        onClick={selectStickyTool}\n        isActive={activeTool === TDShapeType.Sticky}\n        id=\"TD-PrimaryTools-Pencil2\"\n      >\n        <Pencil2Icon />\n      </ToolButtonWithTooltip>\n      <ToolButtonWithTooltip\n        label={intl.formatMessage({ id: 'image' })}\n        onClick={uploadMedias}\n        id=\"TD-PrimaryTools-Image\"\n      >\n        <ImageIcon />\n      </ToolButtonWithTooltip>\n    </StyledPanel>\n  )\n})\n\nconst StyledPanel = styled(Panel, {\n  variants: {\n    bp: {\n      mobile: {\n        padding: '$0',\n        borderRadius: '10px',\n      },\n      small: {\n        padding: '$2',\n      },\n    },\n  },\n})\n", "import { styled } from '~styles/stitches.config'\n\nexport const Panel = styled('div', {\n  backgroundColor: '$panel',\n  display: 'flex',\n  flexDirection: 'row',\n  boxShadow: '$panel',\n  padding: '$2',\n  border: '1px solid $panelContrast',\n  gap: 0,\n  overflow: 'hidden',\n  variants: {\n    side: {\n      center: {\n        borderRadius: 9,\n      },\n      left: {\n        padding: 0,\n        borderTop: 0,\n        borderLeft: 0,\n        borderTopRightRadius: 0,\n        borderBottomRightRadius: 9,\n        borderBottomLeftRadius: 0,\n      },\n      right: {\n        padding: 0,\n        borderTop: 0,\n        borderRight: 0,\n        borderTopLeftRadius: 0,\n        borderBottomLeftRadius: 9,\n        borderBottomRightRadius: 0,\n      },\n    },\n  },\n  '& hr': {\n    height: 10,\n    width: '100%',\n    backgroundColor: 'red',\n    border: 'none',\n  },\n})\n", "import * as DropdownMenu from '@radix-ui/react-dropdown-menu'\nimport { CircleIcon, SquareIcon, VercelLogoIcon } from '@radix-ui/react-icons'\nimport * as React from 'react'\nimport { useIntl } from 'react-intl'\nimport { Panel } from '~components/Primitives/Panel'\nimport { ToolButton } from '~components/Primitives/ToolButton'\nimport { Tooltip } from '~components/Primitives/Tooltip'\nimport { LineIcon } from '~components/Primitives/icons'\nimport { useTldrawApp } from '~hooks'\nimport { TDShapeType, TDSnapshot, TDToolType } from '~types'\n\ninterface ShapesMenuProps {\n  activeTool: TDToolType\n  isToolLocked: boolean\n}\n\ntype ShapeShape =\n  | TDShapeType.Rectangle\n  | TDShapeType.Ellipse\n  | TDShapeType.Triangle\n  | TDShapeType.Line\n\nconst shapeShapes: ShapeShape[] = [\n  TDShapeType.Rectangle,\n  TDShapeType.Ellipse,\n  TDShapeType.Triangle,\n  TDShapeType.Line,\n]\n\nconst shapeShapeIcons = {\n  [TDShapeType.Rectangle]: <SquareIcon />,\n  [TDShapeType.Ellipse]: <CircleIcon />,\n  [TDShapeType.Triangle]: <VercelLogoIcon />,\n  [TDShapeType.Line]: <LineIcon />,\n}\n\nconst dockPositionState = (s: TDSnapshot) => s.settings.dockPosition\n\nexport const ShapesMenu = React.memo(function ShapesMenu({\n  activeTool,\n  isToolLocked,\n}: ShapesMenuProps) {\n  const app = useTldrawApp()\n  const intl = useIntl()\n\n  const dockPosition = app.useStore(dockPositionState)\n\n  const [lastActiveTool, setLastActiveTool] = React.useState<ShapeShape>(TDShapeType.Rectangle)\n\n  React.useEffect(() => {\n    if (shapeShapes.includes(activeTool as ShapeShape) && lastActiveTool !== activeTool) {\n      setLastActiveTool(activeTool as ShapeShape)\n    }\n  }, [activeTool])\n\n  const selectShapeTool = React.useCallback(() => {\n    app.selectTool(lastActiveTool)\n  }, [activeTool, app])\n\n  const handleDoubleClick = React.useCallback(() => {\n    app.toggleToolLock()\n  }, [app])\n\n  const handleKeyDown = React.useCallback((e: React.KeyboardEvent<HTMLButtonElement>) => {\n    if (e.key === ' ') {\n      if (app.shiftKey) {\n        e.preventDefault()\n      }\n    }\n  }, [])\n\n  const isActive = shapeShapes.includes(activeTool as ShapeShape)\n  const contentSide = dockPosition === 'bottom' || dockPosition === 'top' ? 'top' : dockPosition\n\n  const panelStyle = dockPosition === 'bottom' || dockPosition === 'top' ? 'row' : 'column'\n\n  return (\n    <DropdownMenu.Root dir=\"ltr\" onOpenChange={selectShapeTool}>\n      <DropdownMenu.Trigger dir=\"ltr\" asChild id=\"TD-PrimaryTools-Shapes\">\n        <ToolButton\n          disabled={isActive && app.shiftKey} // otherwise this continuously opens and closes on \"SpacePanning\"\n          variant=\"primary\"\n          onDoubleClick={handleDoubleClick}\n          isToolLocked={isActive && isToolLocked}\n          isActive={isActive}\n          onKeyDown={handleKeyDown}\n          aria-label={intl.formatMessage({ id: 'shapes' })}\n        >\n          {shapeShapeIcons[lastActiveTool]}\n        </ToolButton>\n      </DropdownMenu.Trigger>\n      <DropdownMenu.Content asChild side={contentSide} sideOffset={12}>\n        <Panel side=\"center\" style={{ flexDirection: panelStyle }}>\n          {shapeShapes.map((shape, i) => (\n            <Tooltip\n              key={shape}\n              label={intl.formatMessage({ id: shape })}\n              kbd={(4 + i).toString()}\n              id={`TD-PrimaryTools-Shapes-${shape}`}\n            >\n              <DropdownMenu.Item asChild>\n                <ToolButton\n                  aria-label={intl.formatMessage({ id: shape })}\n                  variant=\"primary\"\n                  onClick={() => {\n                    app.selectTool(shape)\n                    setLastActiveTool(shape)\n                  }}\n                >\n                  {shapeShapeIcons[shape]}\n                </ToolButton>\n              </DropdownMenu.Item>\n            </Tooltip>\n          ))}\n        </Panel>\n      </DropdownMenu.Content>\n    </DropdownMenu.Root>\n  )\n})\n", "import * as React from 'react'\nimport { breakpoints } from '~components/breakpoints'\nimport { useTldrawApp } from '~hooks'\nimport { styled } from '~styles'\nimport type { TDSnapshot } from '~types'\n\nconst statusSelector = (s: TDSnapshot) => s.appState.status\nconst activeToolSelector = (s: TDSnapshot) => s.appState.activeTool\n\nexport function StatusBar() {\n  const app = useTldrawApp()\n  const status = app.useStore(statusSelector)\n  const activeTool = app.useStore(activeToolSelector)\n\n  return (\n    <StyledStatusBar bp={breakpoints} id=\"TD-StatusBar\">\n      <StyledSection>\n        {activeTool} | {status}\n      </StyledSection>\n    </StyledStatusBar>\n  )\n}\n\nconst StyledStatusBar = styled('div', {\n  height: 40,\n  userSelect: 'none',\n  borderTop: '1px solid $panelContrast',\n  gridArea: 'status',\n  display: 'flex',\n  color: '$text',\n  justifyContent: 'space-between',\n  alignItems: 'center',\n  backgroundColor: '$panel',\n  gap: 8,\n  fontFamily: '$ui',\n  fontSize: '$0',\n  padding: '0 16px',\n\n  variants: {\n    bp: {\n      small: {\n        fontSize: '$1',\n      },\n    },\n  },\n})\n\nconst StyledSection = styled('div', {\n  whiteSpace: 'nowrap',\n  overflow: 'hidden',\n})\n", "import * as React from 'react'\nimport { useIntl } from 'react-intl'\nimport { Panel } from '~components/Primitives/Panel'\nimport { ToolButton, ToolButtonWithTooltip } from '~components/Primitives/ToolButton'\nimport { UndoIcon } from '~components/Primitives/icons'\nimport { useTldrawApp } from '~hooks'\nimport { styled } from '~styles'\nimport { Menu } from './Menu/Menu'\nimport { MultiplayerMenu } from './MultiplayerMenu'\nimport { PageMenu } from './PageMenu'\nimport { StyleMenu } from './StyleMenu'\nimport { ZoomMenu } from './ZoomMenu'\n\ninterface TopPanelProps {\n  readOnly: boolean\n  showPages: boolean\n  showMenu: boolean\n  showStyles: boolean\n  showZoom: boolean\n  showMultiplayerMenu: boolean\n}\n\nexport function _TopPanel({\n  readOnly,\n  showPages,\n  showMenu,\n  showStyles,\n  showZoom,\n  showMultiplayerMenu,\n}: TopPanelProps) {\n  const app = useTldrawApp()\n  const intl = useIntl()\n\n  return (\n    <StyledTopPanel>\n      {(showMenu || showPages) && (\n        <Panel side=\"left\" id=\"TD-MenuPanel\">\n          {showMenu && <Menu readOnly={readOnly} />}\n          {showMultiplayerMenu && <MultiplayerMenu />}\n          {showPages && <PageMenu />}\n        </Panel>\n      )}\n      <StyledSpacer />\n      {(showStyles || showZoom) && (\n        <Panel side=\"right\">\n          {app.readOnly ? (\n            <ReadOnlyLabel>Read Only</ReadOnlyLabel>\n          ) : (\n            <>\n              <ToolButtonWithTooltip\n                kbd={'#Z'}\n                label={intl.formatMessage({ id: 'undo' })}\n                onClick={app.undo}\n                id=\"TD-TopPanel-Undo\"\n              >\n                <UndoIcon />\n              </ToolButtonWithTooltip>\n              <ToolButtonWithTooltip\n                kbd={'#\u21E7Z'}\n                label={intl.formatMessage({ id: 'redo' })}\n                onClick={app.redo}\n                id=\"TD-TopPanel-Redo\"\n              >\n                <UndoIcon flipHorizontal />\n              </ToolButtonWithTooltip>\n            </>\n          )}\n          {showZoom && <ZoomMenu />}\n          {showStyles && !readOnly && <StyleMenu />}\n        </Panel>\n      )}\n    </StyledTopPanel>\n  )\n}\n\nconst StyledTopPanel = styled('div', {\n  width: '100%',\n  position: 'absolute',\n  top: 0,\n  left: 0,\n  right: 0,\n  display: 'flex',\n  flexDirection: 'row',\n  pointerEvents: 'none',\n  '& > *': {\n    pointerEvents: 'all',\n  },\n})\n\nconst StyledSpacer = styled('div', {\n  flexGrow: 2,\n  pointerEvents: 'none',\n})\n\nconst ReadOnlyLabel = styled('div', {\n  width: '100%',\n  display: 'flex',\n  alignItems: 'center',\n  justifyContent: 'center',\n  fontFamily: '$ui',\n  fontSize: '$1',\n  paddingLeft: '$4',\n  paddingRight: '$1',\n  userSelect: 'none',\n})\n\nexport const TopPanel = React.memo(_TopPanel)\n", "import * as DropdownMenu from '@radix-ui/react-dropdown-menu'\nimport { HamburgerMenuIcon } from '@radix-ui/react-icons'\nimport { supported } from 'browser-fs-access'\nimport * as React from 'react'\nimport { FormattedMessage, useIntl } from 'react-intl'\nimport { FilenameDialog } from '~components/Primitives/AlertDialog'\nimport { Divider } from '~components/Primitives/Divider'\nimport { DMContent, DMItem, DMSubMenu, DMTriggerIcon } from '~components/Primitives/DropdownMenu'\nimport { preventEvent } from '~components/preventEvent'\nimport { useTldrawApp } from '~hooks'\nimport { useFileSystemHandlers } from '~hooks'\nimport { TDExportType, TDSnapshot } from '~types'\nimport { PreferencesMenu } from '../PreferencesMenu'\n\ninterface MenuProps {\n  readOnly: boolean\n}\n\nconst numberOfSelectedIdsSelector = (s: TDSnapshot) => {\n  return s.document.pageStates[s.appState.currentPageId].selectedIds.length\n}\n\nconst disableAssetsSelector = (s: TDSnapshot) => {\n  return s.appState.disableAssets\n}\n\nexport const Menu = React.memo(function Menu({ readOnly }: MenuProps) {\n  const app = useTldrawApp()\n  const intl = useIntl()\n  const [openDialog, setOpenDialog] = React.useState(false)\n\n  const numberOfSelectedIds = app.useStore(numberOfSelectedIdsSelector)\n\n  const disableAssets = app.useStore(disableAssetsSelector)\n\n  const [_, setForce] = React.useState(0)\n\n  React.useEffect(() => setForce(1), [])\n\n  const { onNewProject, onOpenProject, onSaveProject, onSaveProjectAs } = useFileSystemHandlers()\n\n  const handleSaveProjectAs = React.useCallback(() => {\n    if (!supported) {\n      setOpenDialog(true)\n    } else {\n      app.saveProjectAs()\n    }\n  }, [app])\n\n  const handleDelete = React.useCallback(() => {\n    app.delete()\n  }, [app])\n\n  const handleCopySVG = React.useCallback(() => {\n    app.copyImage(TDExportType.SVG, { scale: 1, quality: 1, transparentBackground: false })\n  }, [app])\n\n  const handleCopyPNG = React.useCallback(() => {\n    app.copyImage(TDExportType.PNG, { scale: 2, quality: 1, transparentBackground: true })\n  }, [app])\n\n  const handleExportPNG = React.useCallback(async () => {\n    app.exportImage(TDExportType.PNG, { scale: 2, quality: 1 })\n  }, [app])\n\n  const handleExportJPG = React.useCallback(async () => {\n    app.exportImage(TDExportType.JPG, { scale: 2, quality: 1 })\n  }, [app])\n\n  const handleExportWEBP = React.useCallback(async () => {\n    app.exportImage(TDExportType.WEBP, { scale: 2, quality: 1 })\n  }, [app])\n\n  const handleExportSVG = React.useCallback(async () => {\n    app.exportImage(TDExportType.SVG, { scale: 2, quality: 1 })\n  }, [app])\n\n  const handleCopyJSON = React.useCallback(async () => {\n    app.copyJson()\n  }, [app])\n\n  const handleExportJSON = React.useCallback(async () => {\n    app.exportJson()\n  }, [app])\n\n  const handleCut = React.useCallback(() => {\n    app.cut()\n  }, [app])\n\n  const handleCopy = React.useCallback(() => {\n    app.copy()\n  }, [app])\n\n  const handlePaste = React.useCallback(() => {\n    app.paste()\n  }, [app])\n\n  const handleSelectAll = React.useCallback(() => {\n    app.selectAll()\n  }, [app])\n\n  const handleSelectNone = React.useCallback(() => {\n    app.selectNone()\n  }, [app])\n\n  const handleUploadMedia = React.useCallback(() => {\n    app.openAsset()\n  }, [app])\n\n  const handleZoomTo100 = React.useCallback(() => {\n    app.zoomTo(1)\n  }, [app])\n\n  const showFileMenu =\n    app.callbacks.onNewProject ||\n    app.callbacks.onOpenProject ||\n    app.callbacks.onSaveProject ||\n    app.callbacks.onSaveProjectAs ||\n    app.callbacks.onExport\n\n  const hasSelection = numberOfSelectedIds > 0\n\n  return (\n    <>\n      <DropdownMenu.Root dir=\"ltr\">\n        <DMTriggerIcon id=\"TD-MenuIcon\">\n          <HamburgerMenuIcon />\n        </DMTriggerIcon>\n        <DMContent\n          variant=\"menu\"\n          id=\"TD-Menu\"\n          side=\"bottom\"\n          align=\"start\"\n          sideOffset={4}\n          alignOffset={4}\n        >\n          {showFileMenu && (\n            <DMSubMenu\n              label={`${intl.formatMessage({ id: 'menu.file' })}...`}\n              id=\"TD-MenuItem-File\"\n            >\n              {app.callbacks.onNewProject && (\n                <DMItem onClick={onNewProject} kbd=\"#N\" id=\"TD-MenuItem-File-New_Project\">\n                  <FormattedMessage id=\"new.project\" />\n                </DMItem>\n              )}\n              {app.callbacks.onOpenProject && (\n                <DMItem onClick={onOpenProject} kbd=\"#O\" id=\"TD-MenuItem-File-Open\">\n                  <FormattedMessage id=\"open\" />\n                  ...\n                </DMItem>\n              )}\n              {app.callbacks.onSaveProject && (\n                <DMItem onClick={onSaveProject} kbd=\"#S\" id=\"TD-MenuItem-File-Save\">\n                  <FormattedMessage id=\"save\" />\n                </DMItem>\n              )}\n              {app.callbacks.onSaveProjectAs && (\n                <DMItem onClick={handleSaveProjectAs} kbd=\"#\u21E7S\" id=\"TD-MenuItem-File-Save_As\">\n                  <FormattedMessage id=\"save.as\" />\n                  ...\n                </DMItem>\n              )}\n              {!disableAssets && (\n                <>\n                  <Divider />\n                  <DMItem onClick={handleUploadMedia} kbd=\"#U\" id=\"TD-MenuItem-File-Upload_Media\">\n                    <FormattedMessage id=\"upload.media\" />\n                  </DMItem>\n                </>\n              )}\n            </DMSubMenu>\n          )}\n          <DMSubMenu label={`${intl.formatMessage({ id: 'menu.edit' })}...`} id=\"TD-MenuItem-Edit\">\n            <DMItem\n              onSelect={preventEvent}\n              onClick={app.undo}\n              disabled={readOnly}\n              kbd=\"#Z\"\n              id=\"TD-MenuItem-Edit-Undo\"\n            >\n              <FormattedMessage id=\"undo\" />\n            </DMItem>\n            <DMItem\n              onSelect={preventEvent}\n              onClick={app.redo}\n              disabled={readOnly}\n              kbd=\"#\u21E7Z\"\n              id=\"TD-MenuItem-Edit-Redo\"\n            >\n              <FormattedMessage id=\"redo\" />\n            </DMItem>\n            <Divider />\n            <DMItem\n              onSelect={preventEvent}\n              disabled={!hasSelection || readOnly}\n              onClick={handleCut}\n              kbd=\"#X\"\n              id=\"TD-MenuItem-Edit-Cut\"\n            >\n              <FormattedMessage id=\"cut\" />\n            </DMItem>\n            <DMItem\n              onSelect={preventEvent}\n              disabled={!hasSelection}\n              onClick={handleCopy}\n              kbd=\"#C\"\n              id=\"TD-MenuItem-Edit-Copy\"\n            >\n              <FormattedMessage id=\"copy\" />\n            </DMItem>\n            <DMItem\n              onSelect={preventEvent}\n              onClick={handlePaste}\n              kbd=\"#V\"\n              id=\"TD-MenuItem-Edit-Paste\"\n            >\n              <FormattedMessage id=\"paste\" />\n            </DMItem>\n            <Divider />\n            <DMSubMenu\n              label={`${intl.formatMessage({ id: 'copy.as' })}...`}\n              size=\"small\"\n              id=\"TD-MenuItem-Copy-As\"\n            >\n              <DMItem onClick={handleCopySVG} id=\"TD-MenuItem-Copy-as-SVG\">\n                SVG\n              </DMItem>\n              <DMItem onClick={handleCopyPNG} id=\"TD-MenuItem-Copy-As-PNG\">\n                PNG\n              </DMItem>\n              <DMItem onClick={handleCopyJSON} id=\"TD-MenuItem-Copy_as_JSON\">\n                JSON\n              </DMItem>\n            </DMSubMenu>\n            <DMSubMenu\n              label={`${intl.formatMessage({ id: 'export.as' })}...`}\n              size=\"small\"\n              id=\"TD-MenuItem-Export\"\n            >\n              <DMItem onClick={handleExportSVG} id=\"TD-MenuItem-Export-SVG\">\n                SVG\n              </DMItem>\n              <DMItem onClick={handleExportPNG} id=\"TD-MenuItem-Export-PNG\">\n                PNG\n              </DMItem>\n              <DMItem onClick={handleExportJPG} id=\"TD-MenuItem-Export-JPG\">\n                JPG\n              </DMItem>\n              <DMItem onClick={handleExportWEBP} id=\"TD-MenuItem-Export-WEBP\">\n                WEBP\n              </DMItem>\n              <DMItem onClick={handleExportJSON} id=\"TD-MenuItem-Export-JSON\">\n                JSON\n              </DMItem>\n            </DMSubMenu>\n\n            <Divider />\n            <DMItem\n              onSelect={preventEvent}\n              onClick={handleSelectAll}\n              kbd=\"#A\"\n              id=\"TD-MenuItem-Select_All\"\n            >\n              <FormattedMessage id=\"select.all\" />\n            </DMItem>\n            <DMItem\n              onSelect={preventEvent}\n              disabled={!hasSelection}\n              onClick={handleSelectNone}\n              id=\"TD-MenuItem-Select_None\"\n            >\n              <FormattedMessage id=\"select.none\" />\n            </DMItem>\n            <Divider />\n            <DMItem\n              onSelect={handleDelete}\n              disabled={!hasSelection}\n              kbd=\"\u232B\"\n              id=\"TD-MenuItem-Delete\"\n            >\n              <FormattedMessage id=\"delete\" />\n            </DMItem>\n          </DMSubMenu>\n          <DMSubMenu label={intl.formatMessage({ id: 'menu.view' })} id=\"TD-MenuItem-Edit\">\n            <DMItem\n              onSelect={preventEvent}\n              onClick={app.zoomIn}\n              kbd=\"#+\"\n              id=\"TD-MenuItem-View-ZoomIn\"\n            >\n              <FormattedMessage id=\"zoom.in\" />\n            </DMItem>\n            <DMItem\n              onSelect={preventEvent}\n              onClick={app.zoomOut}\n              kbd=\"#-\"\n              id=\"TD-MenuItem-View-ZoomOut\"\n            >\n              <FormattedMessage id=\"zoom.out\" />\n            </DMItem>\n            <DMItem\n              onSelect={preventEvent}\n              onClick={handleZoomTo100}\n              kbd=\"\u21E7+0\"\n              id=\"TD-MenuItem-View-ZoomTo100\"\n            >\n              <FormattedMessage id=\"zoom.to\" /> 100%\n            </DMItem>\n            <DMItem\n              onSelect={preventEvent}\n              onClick={app.zoomToFit}\n              kbd=\"\u21E7+1\"\n              id=\"TD-MenuItem-View-ZoomToFit\"\n            >\n              <FormattedMessage id=\"zoom.to.fit\" />\n            </DMItem>\n            <DMItem\n              onSelect={preventEvent}\n              onClick={app.zoomToSelection}\n              kbd=\"\u21E7+2\"\n              id=\"TD-MenuItem-View-ZoomToSelection\"\n            >\n              <FormattedMessage id=\"zoom.to.selection\" />\n            </DMItem>\n          </DMSubMenu>\n          <Divider />\n          <PreferencesMenu />\n        </DMContent>\n      </DropdownMenu.Root>\n      <FilenameDialog isOpen={openDialog} onClose={() => setOpenDialog(false)} />\n    </>\n  )\n})\n", "import * as React from 'react'\nimport { FormattedMessage, useIntl } from 'react-intl'\nimport { Divider } from '~components/Primitives/Divider'\nimport { DMCheckboxItem, DMSubMenu } from '~components/Primitives/DropdownMenu'\nimport { useTldrawApp } from '~hooks'\nimport { styled } from '~styles'\nimport { TDDockPosition, TDExportBackground, TDSnapshot } from '~types'\n\nconst settingsSelector = (s: TDSnapshot) => s.settings\n\nconst DockPosition = ['bottom', 'left', 'right', 'top']\n\nexport function PreferencesMenu() {\n  const app = useTldrawApp()\n  const intl = useIntl()\n\n  const settings = app.useStore(settingsSelector)\n\n  const toggleDebugMode = React.useCallback(() => {\n    app.setSetting('isDebugMode', (v) => !v)\n  }, [app])\n\n  const toggleDarkMode = React.useCallback(() => {\n    app.setSetting('isDarkMode', (v) => !v)\n  }, [app])\n\n  const toggleFocusMode = React.useCallback(() => {\n    app.setSetting('isFocusMode', (v) => !v)\n  }, [app])\n\n  const toggleGrid = React.useCallback(() => {\n    app.setSetting('showGrid', (v) => !v)\n  }, [app])\n\n  const toggleKeepStyleMenuOpen = React.useCallback(() => {\n    app.setSetting('keepStyleMenuOpen', (v) => !v)\n  }, [app])\n\n  const toggleCadSelectMode = React.useCallback(() => {\n    app.setSetting('isCadSelectMode', (v) => !v)\n  }, [app])\n\n  const handleChangeDockPosition = React.useCallback(\n    (position: TDDockPosition) => {\n      app.setSetting('dockPosition', position)\n    },\n    [app]\n  )\n\n  const selectExportBackground = React.useCallback(\n    (background: TDExportBackground) => {\n      app.setSetting('exportBackground', background)\n    },\n    [app]\n  )\n\n  return (\n    <DMSubMenu label={intl.formatMessage({ id: 'menu.preferences' })} id=\"TD-MenuItem-Preferences\">\n      <DMCheckboxItem\n        checked={settings.isDarkMode}\n        onCheckedChange={toggleDarkMode}\n        kbd=\"#\u21E7D\"\n        id=\"TD-MenuItem-Preferences-Dark_Mode\"\n      >\n        <FormattedMessage id=\"preferences.dark.mode\" />\n      </DMCheckboxItem>\n      <DMCheckboxItem\n        checked={settings.isFocusMode}\n        onCheckedChange={toggleFocusMode}\n        kbd=\"#.\"\n        id=\"TD-MenuItem-Preferences-Focus_Mode\"\n      >\n        <FormattedMessage id=\"preferences.focus.mode\" />\n      </DMCheckboxItem>\n      <DMCheckboxItem\n        checked={settings.isDebugMode}\n        onCheckedChange={toggleDebugMode}\n        id=\"TD-MenuItem-Preferences-Debug_Mode\"\n      >\n        <FormattedMessage id=\"preferences.debug.mode\" />\n      </DMCheckboxItem>\n      <Divider />\n      <DMCheckboxItem\n        checked={settings.showGrid}\n        onCheckedChange={toggleGrid}\n        kbd=\"#\u21E7G\"\n        id=\"TD-MenuItem-Preferences-Grid\"\n      >\n        <FormattedMessage id=\"preferences.show.grid\" />\n      </DMCheckboxItem>\n      <DMCheckboxItem\n        checked={settings.isCadSelectMode}\n        onCheckedChange={toggleCadSelectMode}\n        id=\"TD-MenuItem-Preferences-Cad_Selection\"\n      >\n        <FormattedMessage id=\"preferences.use.cad.selection\" />\n      </DMCheckboxItem>\n      <DMCheckboxItem\n        checked={settings.keepStyleMenuOpen}\n        onCheckedChange={toggleKeepStyleMenuOpen}\n        id=\"TD-MenuItem-Preferences-Style_menu\"\n      >\n        <FormattedMessage id=\"preferences.keep.stylemenu.open\" />\n      </DMCheckboxItem>\n      <DMSubMenu label={intl.formatMessage({ id: 'dock.position' })}>\n        {DockPosition.map((position) => (\n          <DMCheckboxItem\n            key={position}\n            checked={settings.dockPosition === position}\n            onCheckedChange={() => handleChangeDockPosition(position as TDDockPosition)}\n            id={`TD-MenuItem-DockPosition-${position}`}\n          >\n            <StyledText>\n              <FormattedMessage id={position} />\n            </StyledText>\n          </DMCheckboxItem>\n        ))}\n      </DMSubMenu>\n      <DMSubMenu label={intl.formatMessage({ id: 'export.background' })}>\n        {Object.values(TDExportBackground).map((exportBackground) => (\n          <DMCheckboxItem\n            key={exportBackground}\n            checked={settings.exportBackground === exportBackground}\n            onCheckedChange={() => selectExportBackground(exportBackground as TDExportBackground)}\n            id={`TD-MenuItem-ExportBackground-${exportBackground}`}\n          >\n            <StyledText>\n              <FormattedMessage id={exportBackground as string} />\n            </StyledText>\n          </DMCheckboxItem>\n        ))}\n      </DMSubMenu>\n    </DMSubMenu>\n  )\n}\n\nconst StyledText = styled('span', {\n  textTransform: 'capitalize',\n})\n", "import * as DropdownMenu from '@radix-ui/react-dropdown-menu'\nimport { CheckIcon, ClipboardIcon } from '@radix-ui/react-icons'\nimport { Utils } from '@tldraw/core'\nimport * as React from 'react'\nimport { FormattedMessage } from 'react-intl'\nimport { Divider } from '~components/Primitives/Divider'\nimport { DMContent, DMItem, DMTriggerIcon } from '~components/Primitives/DropdownMenu'\nimport { SmallIcon } from '~components/Primitives/SmallIcon'\nimport { MultiplayerIcon2 } from '~components/Primitives/icons/MultiplayerIcon2'\nimport { useTldrawApp } from '~hooks'\nimport { TLDR } from '~state/TLDR'\nimport { TDAssetType, TDSnapshot } from '~types'\n\nconst roomSelector = (state: TDSnapshot) => state.room\n\nexport const MultiplayerMenu = function MultiplayerMenu() {\n  const app = useTldrawApp()\n\n  const room = app.useStore(roomSelector)\n\n  const [copied, setCopied] = React.useState(false)\n\n  const rTimeout = React.useRef<any>(0)\n\n  const handleCopySelect = React.useCallback(() => {\n    setCopied(true)\n    TLDR.copyStringToClipboard(window.location.href)\n    clearTimeout(rTimeout.current)\n    rTimeout.current = setTimeout(() => setCopied(false), 1200)\n  }, [])\n\n  const handleCopyReadOnlySelect = React.useCallback(() => {\n    setCopied(true)\n    const segs = window.location.href.split('/')\n    segs[segs.length - 2] = 'v'\n    segs[segs.length - 1] = Utils.lns(segs[segs.length - 1])\n    TLDR.copyStringToClipboard(segs.join('/'))\n    clearTimeout(rTimeout.current)\n    rTimeout.current = setTimeout(() => setCopied(false), 1200)\n  }, [])\n\n  const handleCreateMultiplayerProject = React.useCallback(async () => {\n    if (app.isDirty) {\n      if (app.fileSystemHandle) {\n        if (window.confirm('Do you want to save changes to your current project?')) {\n          await app.saveProject()\n        }\n      } else {\n        if (window.confirm('Do you want to save your current project?')) {\n          await app.saveProject()\n        }\n      }\n    } else if (!app.fileSystemHandle) {\n      if (window.confirm('Do you want to save your current project?')) {\n        await app.saveProject()\n      }\n    }\n  }, [])\n\n  const handleCopyToMultiplayerProject = React.useCallback(async () => {\n    const nextDocument = Utils.deepClone(app.document)\n\n    app.setIsLoading(true)\n\n    try {\n      if (app.callbacks.onAssetUpload) {\n        for (const id in nextDocument.assets) {\n          const asset = nextDocument.assets[id]\n          if (asset.src.includes('base64')) {\n            const file = dataURLtoFile(\n              asset.src,\n              asset.fileName ?? asset.type === TDAssetType.Video ? 'image.png' : 'image.mp4'\n            )\n            const newSrc = await app.callbacks.onAssetUpload(app, file, id)\n            if (newSrc) {\n              asset.src = newSrc\n            } else {\n              asset.src = ''\n            }\n          }\n        }\n      }\n\n      const result = await fetch(`/api/create`, {\n        method: 'POST',\n        mode: 'no-cors',\n        headers: {\n          'Access-Control-Allow-Origin': '*',\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          roomId: Utils.uniqueId(),\n          pageId: app.currentPageId,\n          document: nextDocument,\n        }),\n      }).then((d) => d.json())\n\n      if (result?.url) {\n        window.location.href = result.url\n      } else {\n        TLDR.warn(result?.message)\n      }\n    } catch (e) {\n      TLDR.warn((e as any).message)\n    }\n\n    app.setIsLoading(false)\n  }, [])\n\n  return (\n    <DropdownMenu.Root dir=\"ltr\">\n      <DMTriggerIcon id=\"TD-MultiplayerMenuIcon\" isActive={!!room}>\n        <MultiplayerIcon2 />\n      </DMTriggerIcon>\n      <DMContent variant=\"menu\" id=\"TD-MultiplayerMenu\" side=\"bottom\" align=\"start\" sideOffset={4}>\n        <DMItem id=\"TD-Multiplayer-CopyInviteLink\" onClick={handleCopySelect} disabled={!room}>\n          <FormattedMessage id=\"copy.invite.link\" />\n          <SmallIcon>{copied ? <CheckIcon /> : <ClipboardIcon />}</SmallIcon>\n        </DMItem>\n        <DMItem\n          id=\"TD-Multiplayer-CopyReadOnlyLink\"\n          onClick={handleCopyReadOnlySelect}\n          disabled={!room}\n        >\n          <FormattedMessage id=\"copy.readonly.link\" />\n          <SmallIcon>{copied ? <CheckIcon /> : <ClipboardIcon />}</SmallIcon>\n        </DMItem>\n        <Divider />\n        <DMItem\n          id=\"TD-Multiplayer-CreateMultiplayerProject\"\n          onClick={handleCreateMultiplayerProject}\n        >\n          <a href=\"https://tldraw.com/r\">\n            <FormattedMessage id=\"create.multiplayer.project\" />\n          </a>\n        </DMItem>\n        <DMItem\n          id=\"TD-Multiplayer-CopyToMultiplayerProject\"\n          onClick={handleCopyToMultiplayerProject}\n        >\n          <FormattedMessage id=\"copy.multiplayer.project\" />\n        </DMItem>\n      </DMContent>\n    </DropdownMenu.Root>\n  )\n}\n\nfunction dataURLtoFile(dataurl: string, filename: string) {\n  const arr = dataurl.split(',')\n  const mime = arr[0]?.match(/:(.*?);/)?.[1]\n  const bstr = window.atob(arr[1])\n  let n = bstr.length\n  const u8arr = new Uint8Array(n)\n\n  while (n--) {\n    u8arr[n] = bstr.charCodeAt(n)\n  }\n\n  return new File([u8arr], filename, { type: mime })\n}\n", "import * as React from 'react'\n\nexport function MultiplayerIcon2() {\n  return (\n    <svg\n      width=\"15\"\n      height=\"15\"\n      viewBox=\"0 0 15 15\"\n      xmlns=\"http://www.w3.org/2000/svg\"\n      fill=\"currentColor\"\n      fillRule=\"evenodd\"\n      clipRule=\"evenodd\"\n    >\n      <path d=\"M1.36482 4.71089C1.36482 3.21371 2.57853 2 4.07572 2C5.5729 2 6.78661 3.21371 6.78661 4.71089C6.78661 5.76842 6.18106 6.68452 5.29779 7.13136C5.80465 7.24611 6.26407 7.44186 6.66028 7.73182C7.18674 8.11711 7.57215 8.64722 7.81073 9.30983C7.81452 9.30606 7.81832 9.3023 7.82212 9.29855C8.30448 8.82317 8.91325 8.52463 9.60905 8.37275C8.68812 7.922 8.05394 6.97569 8.05394 5.88126C8.05394 4.35017 9.29513 3.10898 10.8262 3.10898C12.3573 3.10898 13.5985 4.35017 13.5985 5.88126C13.5985 6.97561 12.9644 7.92186 12.0436 8.37265C12.7396 8.52449 13.3486 8.82306 13.831 9.29854C14.5795 10.0361 14.9481 11.1249 14.9481 12.5176C14.9481 12.7799 14.7354 12.9926 14.473 12.9926C14.2107 12.9926 13.9981 12.7799 13.9981 12.5175C13.9981 11.2848 13.6738 10.4774 13.1642 9.97518C12.6532 9.4716 11.8802 9.20024 10.8266 9.20024C9.77294 9.20024 8.99993 9.4716 8.48896 9.97518C7.97939 10.4774 7.65513 11.2848 7.65513 12.5176C7.65513 12.7799 7.44247 12.9926 7.18013 12.9926C6.9178 12.9926 6.70513 12.7799 6.70513 12.5176C6.70513 11.6734 6.84053 10.941 7.11384 10.3307C7.0922 10.2895 7.0763 10.2444 7.06737 10.1962C6.91739 9.38749 6.57392 8.84586 6.09923 8.49845C5.61626 8.14499 4.94481 7.95427 4.07574 7.95427C3.05232 7.95427 2.30368 8.21784 1.80952 8.70485C1.31675 9.19047 1.00176 9.97257 1.00176 11.1702C1.00176 11.4326 0.789093 11.6452 0.526758 11.6452C0.264423 11.6452 0.0517578 11.4326 0.0517578 11.1702C0.0517578 9.81263 0.411052 8.74925 1.14268 8.02821C1.60624 7.57137 2.18892 7.28191 2.85378 7.13142C1.97043 6.68461 1.36482 5.76848 1.36482 4.71089ZM4.07572 2.95C3.1032 2.95 2.31482 3.73838 2.31482 4.71089C2.31482 5.68341 3.1032 6.47178 4.07572 6.47178C5.04823 6.47178 5.83661 5.68341 5.83661 4.71089C5.83661 3.73838 5.04823 2.95 4.07572 2.95ZM10.8262 4.05898C9.8198 4.05898 9.00394 4.87484 9.00394 5.88126C9.00394 6.88768 9.8198 7.70355 10.8262 7.70355C11.8326 7.70355 12.6485 6.88768 12.6485 5.88126C12.6485 4.87484 11.8326 4.05898 10.8262 4.05898Z\" />\n    </svg>\n  )\n}\n", "import { TLBounds, TLPageState, TLTransformInfo, Utils } from '@tldraw/core'\nimport { intersectRayBounds, intersectRayEllipse, intersectRayLineSegment } from '@tldraw/intersect'\nimport { Vec } from '@tldraw/vec'\nimport { BINDING_DISTANCE } from '~constants'\nimport {\n  ArrowShape,\n  ShapesWithProp,\n  TDBinding,\n  TDExportType,\n  TDHandle,\n  TDPage,\n  TDShape,\n  TDShapeType,\n  TDSnapshot,\n  TldrawCommand,\n  TldrawPatch,\n} from '~types'\nimport { deepCopy } from './StateManager/copy'\nimport { getShapeUtil } from './shapes'\nimport type { TDShapeUtil } from './shapes/TDShapeUtil'\nimport { getTrianglePoints } from './shapes/TriangleUtil/triangleHelpers'\n\nconst isDev = process.env.NODE_ENV === 'development'\nexport class TLDR {\n  static getShapeUtil<T extends TDShape>(type: T['type']): TDShapeUtil<T>\n  static getShapeUtil<T extends TDShape>(shape: T): TDShapeUtil<T>\n  static getShapeUtil<T extends TDShape>(shape: T | T['type']) {\n    return getShapeUtil<T>(shape)\n  }\n\n  static getSelectedShapes(data: TDSnapshot, pageId: string) {\n    const page = TLDR.getPage(data, pageId)\n    const selectedIds = TLDR.getSelectedIds(data, pageId)\n    return selectedIds.map((id) => page.shapes[id])\n  }\n\n  static screenToWorld(data: TDSnapshot, point: number[]) {\n    const camera = TLDR.getPageState(data, data.appState.currentPageId).camera\n    return Vec.sub(Vec.div(point, camera.zoom), camera.point)\n  }\n\n  static getCameraZoom(zoom: number) {\n    return Utils.clamp(zoom, 0.1, 5)\n  }\n\n  static getPage(data: TDSnapshot, pageId: string): TDPage {\n    return data.document.pages[pageId]\n  }\n\n  static getPageState(data: TDSnapshot, pageId: string): TLPageState {\n    return data.document.pageStates[pageId]\n  }\n\n  static getSelectedIds(data: TDSnapshot, pageId: string): string[] {\n    return TLDR.getPageState(data, pageId).selectedIds\n  }\n\n  static getShapes(data: TDSnapshot, pageId: string): TDShape[] {\n    return Object.values(TLDR.getPage(data, pageId).shapes)\n  }\n\n  static getCamera(data: TDSnapshot, pageId: string): TLPageState['camera'] {\n    return TLDR.getPageState(data, pageId).camera\n  }\n\n  static getShape<T extends TDShape = TDShape>(\n    data: TDSnapshot,\n    shapeId: string,\n    pageId: string\n  ): T {\n    return TLDR.getPage(data, pageId).shapes[shapeId] as T\n  }\n\n  static getCenter<T extends TDShape>(shape: T) {\n    return TLDR.getShapeUtil(shape).getCenter(shape)\n  }\n\n  static getBounds<T extends TDShape>(shape: T) {\n    return TLDR.getShapeUtil(shape).getBounds(shape)\n  }\n\n  static getRotatedBounds<T extends TDShape>(shape: T) {\n    return TLDR.getShapeUtil(shape).getRotatedBounds(shape)\n  }\n\n  static getSelectedBounds(data: TDSnapshot): TLBounds {\n    return Utils.getCommonBounds(\n      TLDR.getSelectedShapes(data, data.appState.currentPageId).map((shape) =>\n        TLDR.getShapeUtil(shape).getBounds(shape)\n      )\n    )\n  }\n\n  static getParentId(data: TDSnapshot, id: string, pageId: string) {\n    return TLDR.getShape(data, id, pageId).parentId\n  }\n\n  // static getPointedId(data: TDSnapshot, id: string, pageId: string): string {\n  //   const page = TLDR.getPage(data, pageId)\n  //   const pageState = TLDR.getPageState(data, data.appState.currentPageId)\n  //   const shape = TLDR.getShape(data, id, pageId)\n  //   if (!shape) return id\n\n  //   return shape.parentId === pageState.currentParentId || shape.parentId === page.id\n  //     ? id\n  //     : TLDR.getPointedId(data, shape.parentId, pageId)\n  // }\n\n  // static getDrilledPointedId(data: TDSnapshot, id: string, pageId: string): string {\n  //   const shape = TLDR.getShape(data, id, pageId)\n  //   const { currentPageId } = data.appState\n  //   const { currentParentId, pointedId } = TLDR.getPageState(data, data.appState.currentPageId)\n\n  //   return shape.parentId === currentPageId ||\n  //     shape.parentId === pointedId ||\n  //     shape.parentId === currentParentId\n  //     ? id\n  //     : TLDR.getDrilledPointedId(data, shape.parentId, pageId)\n  // }\n\n  // static getTopParentId(data: TDSnapshot, id: string, pageId: string): string {\n  //   const page = TLDR.getPage(data, pageId)\n  //   const pageState = TLDR.getPageState(data, pageId)\n  //   const shape = TLDR.getShape(data, id, pageId)\n\n  //   if (shape.parentId === shape.id) {\n  //     throw Error(`Shape has the same id as its parent! ${shape.id}`)\n  //   }\n\n  //   return shape.parentId === page.id || shape.parentId === pageState.currentParentId\n  //     ? id\n  //     : TLDR.getTopParentId(data, shape.parentId, pageId)\n  // }\n\n  // Get an array of a shape id and its descendant shapes' ids\n  static getDocumentBranch(data: TDSnapshot, id: string, pageId: string): string[] {\n    const shape = TLDR.getShape(data, id, pageId)\n\n    if (shape.children === undefined) return [id]\n\n    return [\n      id,\n      ...shape.children.flatMap((childId) => TLDR.getDocumentBranch(data, childId, pageId)),\n    ]\n  }\n\n  // Get a deep array of unproxied shapes and their descendants\n  static getSelectedBranchSnapshot<K>(\n    data: TDSnapshot,\n    pageId: string,\n    fn: (shape: TDShape) => K\n  ): ({ id: string } & K)[]\n  static getSelectedBranchSnapshot(data: TDSnapshot, pageId: string): TDShape[]\n  static getSelectedBranchSnapshot<K>(\n    data: TDSnapshot,\n    pageId: string,\n    fn?: (shape: TDShape) => K\n  ): (TDShape | K)[] {\n    const page = TLDR.getPage(data, pageId)\n\n    const copies = TLDR.getSelectedIds(data, pageId)\n      .flatMap((id) => TLDR.getDocumentBranch(data, id, pageId).map((id) => page.shapes[id]))\n      .filter((shape) => !shape.isLocked)\n      .map(Utils.deepClone)\n\n    if (fn !== undefined) {\n      return copies.map((shape) => ({ id: shape.id, ...fn(shape) }))\n    }\n\n    return copies\n  }\n\n  // Get a shallow array of unproxied shapes\n  static getSelectedShapeSnapshot(data: TDSnapshot, pageId: string): TDShape[]\n  static getSelectedShapeSnapshot<K>(\n    data: TDSnapshot,\n    pageId: string,\n    fn?: (shape: TDShape) => K\n  ): ({ id: string } & K)[]\n  static getSelectedShapeSnapshot<K>(\n    data: TDSnapshot,\n    pageId: string,\n    fn?: (shape: TDShape) => K\n  ): (TDShape | K)[] {\n    const copies = TLDR.getSelectedShapes(data, pageId)\n      .filter((shape) => !shape.isLocked)\n      .map(Utils.deepClone)\n\n    if (fn !== undefined) {\n      return copies.map((shape) => ({ id: shape.id, ...fn(shape) }))\n    }\n\n    return copies\n  }\n\n  // For a given array of shape ids, an array of all other shapes that may be affected by a mutation to it.\n  // Use this to decide which shapes to clone as before / after for a command.\n  static getAllEffectedShapeIds(data: TDSnapshot, ids: string[], pageId: string): string[] {\n    const page = TLDR.getPage(data, pageId)\n\n    const visited = new Set(ids)\n\n    ids.forEach((id) => {\n      const shape = page.shapes[id]\n\n      // Add descendant shapes\n      function collectDescendants(shape: TDShape): void {\n        if (shape.children === undefined) return\n        shape.children\n          .filter((childId) => !visited.has(childId))\n          .forEach((childId) => {\n            visited.add(childId)\n            collectDescendants(page.shapes[childId])\n          })\n      }\n\n      collectDescendants(shape)\n\n      // Add asecendant shapes\n      function collectAscendants(shape: TDShape): void {\n        const parentId = shape.parentId\n        if (parentId === page.id) return\n        if (visited.has(parentId)) return\n        visited.add(parentId)\n        collectAscendants(page.shapes[parentId])\n      }\n\n      collectAscendants(shape)\n\n      // Add bindings that are to or from any of the visited shapes (this does not have to be recursive)\n      visited.forEach((id) => {\n        Object.values(page.bindings)\n          .filter((binding) => binding.fromId === id || binding.toId === id)\n          .forEach((binding) => visited.add(binding.fromId === id ? binding.toId : binding.fromId))\n      })\n    })\n\n    // Return the unique array of visited shapes\n    return Array.from(visited.values())\n  }\n\n  static getLinkedShapeIds(\n    data: TDSnapshot,\n    pageId: string,\n    direction: 'center' | 'left' | 'right',\n    includeArrows = true\n  ) {\n    const selectedIds = TLDR.getSelectedIds(data, pageId)\n\n    const page = TLDR.getPage(data, pageId)\n\n    const linkedIds = new Set<string>(selectedIds)\n\n    const checkedIds = new Set<string>()\n\n    const idsToCheck = [...selectedIds]\n\n    const arrows = new Set(\n      Object.values(page.shapes).filter((shape) => {\n        return (\n          shape.type === TDShapeType.Arrow &&\n          (shape.handles.start.bindingId || shape.handles?.end.bindingId)\n        )\n      }) as ArrowShape[]\n    )\n\n    while (idsToCheck.length) {\n      const id = idsToCheck.pop()\n\n      if (!(id && arrows.size)) break\n\n      if (checkedIds.has(id)) continue\n\n      checkedIds.add(id)\n\n      arrows.forEach((arrow) => {\n        const {\n          handles: {\n            start: { bindingId: startBindingId },\n            end: { bindingId: endBindingId },\n          },\n        } = arrow\n\n        const startBinding = startBindingId ? page.bindings[startBindingId] : null\n        const endBinding = endBindingId ? page.bindings[endBindingId] : null\n\n        let hit = false\n\n        if (startBinding && startBinding.toId === id) {\n          if (direction === 'center') {\n            hit = true\n          } else if (arrow.decorations?.start && endBinding) {\n            // The arrow is pointing to this shape at its start\n            hit = direction === 'left'\n          } else {\n            // The arrow is pointing away from this shape\n            hit = direction === 'right'\n          }\n\n          if (hit) {\n            // This arrow is bound to this shape\n            if (includeArrows) linkedIds.add(arrow.id)\n            linkedIds.add(id)\n\n            if (endBinding) {\n              linkedIds.add(endBinding.toId)\n              idsToCheck.push(endBinding.toId)\n            }\n          }\n        } else if (endBinding && endBinding.toId === id) {\n          // This arrow is bound to this shape at its end\n          if (direction === 'center') {\n            hit = true\n          } else if (arrow.decorations?.end && startBinding) {\n            // The arrow is pointing to this shape\n            hit = direction === 'left'\n          } else {\n            // The arrow is pointing away from this shape\n            hit = direction === 'right'\n          }\n\n          if (hit) {\n            if (includeArrows) linkedIds.add(arrow.id)\n            linkedIds.add(id)\n\n            if (startBinding) {\n              linkedIds.add(startBinding.toId)\n              idsToCheck.push(startBinding.toId)\n            }\n          }\n        }\n\n        if (\n          (!startBinding || linkedIds.has(startBinding.toId)) &&\n          (!endBinding || linkedIds.has(endBinding.toId))\n        ) {\n          arrows.delete(arrow)\n        }\n      })\n    }\n\n    return Array.from(linkedIds.values())\n  }\n\n  static getChildIndexAbove(data: TDSnapshot, id: string, pageId: string): number {\n    const page = data.document.pages[pageId]\n    const shape = page.shapes[id]\n\n    let siblings: TDShape[]\n\n    if (shape.parentId === page.id) {\n      siblings = Object.values(page.shapes)\n        .filter((shape) => shape.parentId === page.id)\n        .sort((a, b) => a.childIndex - b.childIndex)\n    } else {\n      const parent = page.shapes[shape.parentId]\n      if (!parent.children) throw Error('No children in parent!')\n      siblings = parent.children\n        .map((childId) => page.shapes[childId])\n        .sort((a, b) => a.childIndex - b.childIndex)\n    }\n\n    const index = siblings.indexOf(shape)\n\n    const nextSibling = siblings[index + 1]\n\n    if (!nextSibling) return shape.childIndex + 1\n\n    return nextSibling.childIndex\n  }\n\n  /* -------------------------------------------------- */\n  /*                      Mutations                     */\n  /* -------------------------------------------------- */\n\n  static getBeforeShape<T extends TDShape>(shape: T, change: Partial<T>): Partial<T> {\n    return Object.fromEntries(\n      Object.keys(change).map((k) => [k, shape[k as keyof T]])\n    ) as Partial<T>\n  }\n\n  static mutateShapes<T extends TDShape>(\n    data: TDSnapshot,\n    ids: string[],\n    fn: (shape: T, i: number) => Partial<T> | void,\n    pageId: string,\n    forceChildrenTraversal = false\n  ): {\n    before: Record<string, Partial<T>>\n    after: Record<string, Partial<T>>\n    data: TDSnapshot\n  } {\n    const beforeShapes: Record<string, Partial<T>> = {}\n    const afterShapes: Record<string, Partial<T>> = {}\n\n    ids.forEach((id, i) => {\n      const shape = TLDR.getShape<T>(data, id, pageId)\n      if (shape.isLocked) return\n      if (shape?.type === 'group' && (ids.length === 1 || forceChildrenTraversal)) {\n        shape.children.forEach((id, i) => {\n          const shape = TLDR.getShape<T>(data, id, pageId)\n          if (shape.isLocked) return\n          const change = fn(shape, i)\n          if (change) {\n            beforeShapes[id] = TLDR.getBeforeShape(shape, change)\n            afterShapes[id] = change\n          }\n        })\n      }\n      const change = fn(shape, i)\n      if (change) {\n        beforeShapes[id] = TLDR.getBeforeShape(shape, change)\n        afterShapes[id] = change\n      }\n    })\n\n    const dataWithMutations = Utils.deepMerge(data, {\n      document: {\n        pages: {\n          [data.appState.currentPageId]: {\n            shapes: afterShapes,\n          },\n        },\n      },\n    })\n\n    return {\n      before: beforeShapes,\n      after: afterShapes,\n      data: dataWithMutations,\n    }\n  }\n\n  static createShapes(data: TDSnapshot, shapes: TDShape[], pageId: string): TldrawCommand {\n    const before: TldrawPatch = {\n      document: {\n        pages: {\n          [pageId]: {\n            shapes: {\n              ...Object.fromEntries(\n                shapes.flatMap((shape) => {\n                  const results: [string, Partial<TDShape> | undefined][] = [[shape.id, undefined]]\n\n                  // If the shape is a child of another shape, also save that shape\n                  if (shape.parentId !== pageId) {\n                    const parent = TLDR.getShape(data, shape.parentId, pageId)\n                    if (!parent.children) throw Error('No children in parent!')\n                    results.push([parent.id, { children: parent.children }])\n                  }\n\n                  return results\n                })\n              ),\n            },\n          },\n        },\n      },\n    }\n\n    const after: TldrawPatch = {\n      document: {\n        pages: {\n          [pageId]: {\n            shapes: {\n              shapes: {\n                ...Object.fromEntries(\n                  shapes.flatMap((shape) => {\n                    const results: [string, Partial<TDShape> | undefined][] = [[shape.id, shape]]\n\n                    // If the shape is a child of a different shape, update its parent\n                    if (shape.parentId !== pageId) {\n                      const parent = TLDR.getShape(data, shape.parentId, pageId)\n                      if (!parent.children) throw Error('No children in parent!')\n                      results.push([parent.id, { children: [...parent.children, shape.id] }])\n                    }\n\n                    return results\n                  })\n                ),\n              },\n            },\n          },\n        },\n      },\n    }\n\n    return {\n      before,\n      after,\n    }\n  }\n\n  static deleteShapes(\n    data: TDSnapshot,\n    shapes: TDShape[] | string[],\n    pageId?: string\n  ): TldrawCommand {\n    pageId = pageId ? pageId : data.appState.currentPageId\n\n    const page = TLDR.getPage(data, pageId)\n\n    const shapeIds =\n      typeof shapes[0] === 'string'\n        ? (shapes as string[])\n        : (shapes as TDShape[]).map((shape) => shape.id)\n\n    const before: TldrawPatch = {\n      document: {\n        pages: {\n          [pageId]: {\n            shapes: {\n              // These are the shapes that we're going to delete\n              ...Object.fromEntries(\n                shapeIds.flatMap((id) => {\n                  const shape = page.shapes[id]\n                  const results: [string, Partial<TDShape> | undefined][] = [[shape.id, shape]]\n\n                  // If the shape is a child of another shape, also add that shape\n                  if (shape.parentId !== pageId) {\n                    const parent = page.shapes[shape.parentId]\n                    if (!parent.children) throw Error('No children in parent!')\n                    results.push([parent.id, { children: parent.children }])\n                  }\n\n                  return results\n                })\n              ),\n            },\n            bindings: {\n              // These are the bindings that we're going to delete\n              ...Object.fromEntries(\n                Object.values(page.bindings)\n                  .filter((binding) => {\n                    return shapeIds.includes(binding.fromId) || shapeIds.includes(binding.toId)\n                  })\n                  .map((binding) => {\n                    return [binding.id, binding]\n                  })\n              ),\n            },\n          },\n        },\n      },\n    }\n\n    const after: TldrawPatch = {\n      document: {\n        pages: {\n          [pageId]: {\n            shapes: {\n              ...Object.fromEntries(\n                shapeIds.flatMap((id) => {\n                  const shape = page.shapes[id]\n                  const results: [string, Partial<TDShape> | undefined][] = [[shape.id, undefined]]\n\n                  // If the shape is a child of a different shape, update its parent\n                  if (shape.parentId !== page.id) {\n                    const parent = page.shapes[shape.parentId]\n\n                    if (!parent.children) throw Error('No children in parent!')\n\n                    results.push([\n                      parent.id,\n                      { children: parent.children.filter((id) => id !== shape.id) },\n                    ])\n                  }\n\n                  return results\n                })\n              ),\n            },\n          },\n        },\n      },\n    }\n\n    return {\n      before,\n      after,\n    }\n  }\n\n  static onSessionComplete<T extends TDShape>(shape: T) {\n    const delta = TLDR.getShapeUtil(shape).onSessionComplete?.(shape)\n    if (!delta) return shape\n    return { ...shape, ...delta }\n  }\n\n  static onChildrenChange<T extends TDShape>(data: TDSnapshot, shape: T, pageId: string) {\n    if (!shape.children) return\n\n    const delta = TLDR.getShapeUtil(shape).onChildrenChange?.(\n      shape,\n      shape.children.map((id) => TLDR.getShape(data, id, pageId))\n    )\n\n    if (!delta) return shape\n\n    return { ...shape, ...delta }\n  }\n\n  static updateArrowBindings(page: TDPage, arrowShape: ArrowShape) {\n    const result = {\n      start: deepCopy(arrowShape.handles.start),\n      end: deepCopy(arrowShape.handles.end),\n    }\n    type HandleInfo = {\n      handle: TDHandle\n      point: number[] // in page space\n    } & (\n      | {\n          isBound: false\n        }\n      | {\n          isBound: true\n          hasDecoration: boolean\n          binding: TDBinding\n          util: TDShapeUtil<TDShape, any>\n          target: TDShape\n          bounds: TLBounds\n          expandedBounds: TLBounds\n          intersectBounds: TLBounds\n          center: number[]\n        }\n    )\n    let start: HandleInfo = {\n      isBound: false,\n      handle: arrowShape.handles.start,\n      point: Vec.add(arrowShape.handles.start.point, arrowShape.point),\n    }\n    let end: HandleInfo = {\n      isBound: false,\n      handle: arrowShape.handles.end,\n      point: Vec.add(arrowShape.handles.end.point, arrowShape.point),\n    }\n    if (arrowShape.handles.start.bindingId) {\n      const hasDecoration = arrowShape.decorations?.start !== undefined\n      const handle = arrowShape.handles.start\n      const binding = page.bindings[arrowShape.handles.start.bindingId]\n      if (!binding)\n        throw Error(\n          \"Could not find a binding to match the start handle's bindingId: \" +\n            arrowShape.handles.start.bindingId\n        )\n      const target = page.shapes[binding.toId]\n      const util = TLDR.getShapeUtil(target)\n      const bounds = util.getBounds(target)\n      const expandedBounds = util.getExpandedBounds(target)\n      const intersectBounds = hasDecoration ? Utils.expandBounds(bounds, binding.distance) : bounds\n      const { minX, minY, width, height } = expandedBounds\n      const anchorPoint = Vec.add(\n        [minX, minY],\n        Vec.mulV([width, height], Vec.rotWith(binding.point, [0.5, 0.5], target.rotation || 0))\n      )\n      start = {\n        isBound: true,\n        hasDecoration,\n        binding,\n        handle,\n        point: anchorPoint,\n        util,\n        target,\n        bounds,\n        expandedBounds,\n        intersectBounds,\n        center: util.getCenter(target),\n      }\n    }\n    if (arrowShape.handles.end.bindingId) {\n      const hasDecoration = arrowShape.decorations?.end !== undefined\n      const handle = arrowShape.handles.end\n      const binding = page.bindings[arrowShape.handles.end.bindingId]\n      if (!binding) throw Error(\"Could not find a binding to match the end handle's bindingId\")\n      const target = page.shapes[binding.toId]\n      const util = TLDR.getShapeUtil(target)\n      const bounds = util.getBounds(target)\n      const expandedBounds = util.getExpandedBounds(target)\n      const intersectBounds = hasDecoration ? Utils.expandBounds(bounds, binding.distance) : bounds\n      const { minX, minY, width, height } = expandedBounds\n      const anchorPoint = Vec.add(\n        [minX, minY],\n        Vec.mulV([width, height], Vec.rotWith(binding.point, [0.5, 0.5], target.rotation || 0))\n      )\n      end = {\n        isBound: true,\n        hasDecoration,\n        binding,\n        handle,\n        point: anchorPoint,\n        util,\n        target,\n        bounds,\n        expandedBounds,\n        intersectBounds,\n        center: util.getCenter(target),\n      }\n    }\n\n    for (const ID of ['end', 'start'] as const) {\n      const A = ID === 'start' ? start : end\n      const B = ID === 'start' ? end : start\n      if (A.isBound) {\n        if (!A.binding.distance) {\n          // If the binding distance is zero, then the arrow is bound to a specific point\n          // in the target shape. The resulting handle should be exactly at that point.\n          result[ID].point = Vec.sub(A.point, arrowShape.point)\n        } else {\n          // We'll need to figure out the handle's true point based on some intersections\n          // between the opposite handle point and this handle point. This is different\n          // for each type of shape.\n          const direction = Vec.uni(Vec.sub(A.point, B.point))\n          switch (A.target.type) {\n            case TDShapeType.Ellipse: {\n              const hits = intersectRayEllipse(\n                B.point,\n                direction,\n                A.center,\n                A.target.radius[0] + (A.hasDecoration ? A.binding.distance : 0),\n                A.target.radius[1] + (A.hasDecoration ? A.binding.distance : 0),\n                A.target.rotation || 0\n              ).points.sort((a, b) => Vec.dist(a, B.point) - Vec.dist(b, B.point))\n              if (hits[0] !== undefined) {\n                result[ID].point = Vec.toFixed(Vec.sub(hits[0], arrowShape.point))\n              }\n              break\n            }\n            case TDShapeType.Triangle: {\n              const targetPoint = A.target.point\n              const points = getTrianglePoints(\n                A.target.size,\n                A.hasDecoration ? BINDING_DISTANCE : 0,\n                A.target.rotation\n              ).map((pt) => Vec.add(pt, targetPoint))\n              const hits = Utils.pointsToLineSegments(points, true)\n                .map(([p0, p1]) => intersectRayLineSegment(B.point, direction, p0, p1))\n                .filter((intersection) => intersection.didIntersect)\n                .flatMap((intersection) => intersection.points)\n                .sort((a, b) => Vec.dist(a, B.point) - Vec.dist(b, B.point))\n              if (hits[0] !== undefined) {\n                result[ID].point = Vec.toFixed(Vec.sub(hits[0], arrowShape.point))\n              }\n              break\n            }\n            default: {\n              const hits = intersectRayBounds(\n                B.point,\n                direction,\n                A.intersectBounds,\n                A.target.rotation\n              )\n                .filter((int) => int.didIntersect)\n                .map((int) => int.points[0])\n                .sort((a, b) => Vec.dist(a, B.point) - Vec.dist(b, B.point))\n              if (!hits[0]) continue\n              let bHit: number[] | undefined = undefined\n              if (B.isBound) {\n                const bHits = intersectRayBounds(\n                  B.point,\n                  direction,\n                  B.intersectBounds,\n                  B.target.rotation\n                )\n                  .filter((int) => int.didIntersect)\n                  .map((int) => int.points[0])\n                  .sort((a, b) => Vec.dist(a, B.point) - Vec.dist(b, B.point))\n                bHit = bHits[0]\n              }\n              if (\n                B.isBound &&\n                (hits.length < 2 ||\n                  (bHit &&\n                    hits[0] &&\n                    Math.ceil(Vec.dist(hits[0], bHit)) < BINDING_DISTANCE * 2.5) ||\n                  Utils.boundsContain(A.expandedBounds, B.expandedBounds) ||\n                  Utils.boundsCollide(A.expandedBounds, B.expandedBounds))\n              ) {\n                // If the other handle is bound, and if we need to fallback to the short arrow method...\n                const shortArrowDirection = Vec.uni(Vec.sub(B.point, A.point))\n                const shortArrowHits = intersectRayBounds(\n                  A.point,\n                  shortArrowDirection,\n                  A.bounds,\n                  A.target.rotation\n                )\n                  .filter((int) => int.didIntersect)\n                  .map((int) => int.points[0])\n                if (!shortArrowHits[0]) continue\n                result[ID].point = Vec.toFixed(Vec.sub(shortArrowHits[0], arrowShape.point))\n                result[ID === 'start' ? 'end' : 'start'].point = Vec.toFixed(\n                  Vec.add(\n                    Vec.sub(shortArrowHits[0], arrowShape.point),\n                    Vec.mul(\n                      shortArrowDirection,\n                      Math.min(\n                        Vec.dist(shortArrowHits[0], B.point),\n                        BINDING_DISTANCE *\n                          2.5 *\n                          (Utils.boundsContain(B.bounds, A.intersectBounds) ? -1 : 1)\n                      )\n                    )\n                  )\n                )\n              } else if (\n                !B.isBound &&\n                ((hits[0] && Vec.dist(hits[0], B.point) < BINDING_DISTANCE * 2.5) ||\n                  Utils.pointInBounds(B.point, A.intersectBounds))\n              ) {\n                // Short arrow time!\n                const shortArrowDirection = Vec.uni(Vec.sub(A.center, B.point))\n                return TLDR.getShapeUtil<ArrowShape>(arrowShape).onHandleChange?.(arrowShape, {\n                  [ID]: {\n                    ...arrowShape.handles[ID],\n                    point: Vec.toFixed(\n                      Vec.add(\n                        Vec.sub(B.point, arrowShape.point),\n                        Vec.mul(shortArrowDirection, BINDING_DISTANCE * 2.5)\n                      )\n                    ),\n                  },\n                })\n              } else if (hits[0]) {\n                result[ID].point = Vec.toFixed(Vec.sub(hits[0], arrowShape.point))\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return TLDR.getShapeUtil<ArrowShape>(arrowShape).onHandleChange?.(arrowShape, result)\n  }\n\n  static transform<T extends TDShape>(shape: T, bounds: TLBounds, info: TLTransformInfo<T>) {\n    const delta = TLDR.getShapeUtil(shape).transform(shape, bounds, info)\n    if (!delta) return shape\n    return { ...shape, ...delta }\n  }\n\n  static transformSingle<T extends TDShape>(shape: T, bounds: TLBounds, info: TLTransformInfo<T>) {\n    const delta = TLDR.getShapeUtil(shape).transformSingle(shape, bounds, info)\n    if (!delta) return shape\n    return { ...shape, ...delta }\n  }\n\n  /**\n   * Rotate a shape around an origin point.\n   * @param shape a shape.\n   * @param center the shape's center in page space.\n   * @param origin the page point to rotate around.\n   * @param rotation the amount to rotate the shape.\n   */\n  static getRotatedShapeMutation<T extends TDShape>(\n    shape: T, // in page space\n    center: number[], // in page space\n    origin: number[], // in page space (probably the center of common bounds)\n    delta: number // The shape's rotation delta\n  ): Partial<T> | void {\n    // The shape's center relative to the shape's point\n    const relativeCenter = Vec.sub(center, shape.point)\n\n    // Rotate the center around the origin\n    const rotatedCenter = Vec.rotWith(center, origin, delta)\n\n    // Get the top left point relative to the rotated center\n    const nextPoint = Vec.toFixed(Vec.sub(rotatedCenter, relativeCenter))\n\n    // If the shape has handles, we need to rotate the handles instead\n    // of rotating the shape. Shapes with handles should never be rotated,\n    // because that makes a lot of other things incredible difficult.\n    if (shape.handles !== undefined) {\n      const change = this.getShapeUtil(shape).onHandleChange?.(\n        // Base the change on a shape with the next point\n        { ...shape, point: nextPoint },\n        Object.fromEntries(\n          Object.entries(shape.handles).map(([handleId, handle]) => {\n            // Rotate each handle's point around the shape's center\n            // (in relative shape space, as the handle's point will be).\n            const point = Vec.toFixed(Vec.rotWith(handle.point, relativeCenter, delta))\n            return [handleId, { ...handle, point }]\n          })\n        ) as T['handles']\n      )\n\n      return change\n    }\n\n    // If the shape has no handles, move the shape to the new point\n    // and set the rotation.\n\n    // Clamp the next rotation between 0 and PI2\n    const nextRotation = Utils.clampRadians((shape.rotation || 0) + delta)\n\n    return {\n      point: nextPoint,\n      rotation: nextRotation,\n    } as Partial<T>\n  }\n\n  /* -------------------------------------------------- */\n  /*                       Parents                      */\n  /* -------------------------------------------------- */\n\n  static updateParents(data: TDSnapshot, pageId: string, changedShapeIds: string[]): void {\n    const page = TLDR.getPage(data, pageId)\n\n    if (changedShapeIds.length === 0) return\n\n    const { shapes } = TLDR.getPage(data, pageId)\n\n    const parentToUpdateIds = Array.from(\n      new Set(changedShapeIds.map((id) => shapes[id].parentId).values())\n    ).filter((id) => id !== page.id)\n\n    for (const parentId of parentToUpdateIds) {\n      const parent = shapes[parentId]\n\n      if (!parent.children) {\n        throw Error('A shape is parented to a shape without a children array.')\n      }\n\n      TLDR.onChildrenChange(data, parent, pageId)\n    }\n\n    TLDR.updateParents(data, pageId, parentToUpdateIds)\n  }\n\n  /* -------------------------------------------------- */\n  /*                      Bindings                      */\n  /* -------------------------------------------------- */\n\n  static getBinding(data: TDSnapshot, id: string, pageId: string): TDBinding {\n    return TLDR.getPage(data, pageId).bindings[id]\n  }\n\n  static getBindings(data: TDSnapshot, pageId: string): TDBinding[] {\n    const page = TLDR.getPage(data, pageId)\n    return Object.values(page.bindings)\n  }\n\n  static getBindableShapeIds(data: TDSnapshot) {\n    return TLDR.getShapes(data, data.appState.currentPageId)\n      .filter((shape) => TLDR.getShapeUtil(shape).canBind)\n      .sort((a, b) => b.childIndex - a.childIndex)\n      .map((shape) => shape.id)\n  }\n\n  static getBindingsWithShapeIds(data: TDSnapshot, ids: string[], pageId: string): TDBinding[] {\n    return Array.from(\n      new Set(\n        TLDR.getBindings(data, pageId).filter((binding) => {\n          return ids.includes(binding.toId) || ids.includes(binding.fromId)\n        })\n      ).values()\n    )\n  }\n\n  static getRelatedBindings(data: TDSnapshot, ids: string[], pageId: string): TDBinding[] {\n    const changedShapeIds = new Set(ids)\n\n    const page = TLDR.getPage(data, pageId)\n\n    // Find all bindings that we need to update\n    const bindingsArr = Object.values(page.bindings)\n\n    // Start with bindings that are directly bound to our changed shapes\n    const bindingsToUpdate = new Set(\n      bindingsArr.filter(\n        (binding) => changedShapeIds.has(binding.toId) || changedShapeIds.has(binding.fromId)\n      )\n    )\n\n    // Next, look for other bindings that effect the same shapes\n    let prevSize = bindingsToUpdate.size\n    let delta = -1\n\n    while (delta !== 0) {\n      bindingsToUpdate.forEach((binding) => {\n        const fromId = binding.fromId\n\n        for (const otherBinding of bindingsArr) {\n          if (otherBinding.fromId === fromId) {\n            bindingsToUpdate.add(otherBinding)\n          }\n\n          if (otherBinding.toId === fromId) {\n            bindingsToUpdate.add(otherBinding)\n          }\n        }\n      })\n\n      // Continue until we stop finding new bindings to update\n      delta = bindingsToUpdate.size - prevSize\n\n      prevSize = bindingsToUpdate.size\n    }\n\n    return Array.from(bindingsToUpdate.values())\n  }\n\n  static copyStringToClipboard = (string: string) => {\n    try {\n      if (navigator.clipboard) {\n        navigator.clipboard.write([\n          new ClipboardItem({\n            'text/plain': new Blob([string], { type: 'text/plain' }),\n          }),\n        ])\n      }\n    } catch (e) {\n      const textarea = document.createElement('textarea')\n      textarea.setAttribute('position', 'fixed')\n      textarea.setAttribute('top', '0')\n      textarea.setAttribute('readonly', 'true')\n      textarea.setAttribute('contenteditable', 'true')\n      textarea.style.position = 'fixed'\n      textarea.value = string\n      document.body.appendChild(textarea)\n      textarea.focus()\n      textarea.select()\n\n      try {\n        const range = document.createRange()\n        range.selectNodeContents(textarea)\n        const sel = window.getSelection()\n        if (sel) {\n          sel.removeAllRanges()\n          sel.addRange(range)\n          textarea.setSelectionRange(0, textarea.value.length)\n        }\n        document.execCommand('copy')\n      } catch (err) {\n        null // Could not copy to clipboard\n      } finally {\n        document.body.removeChild(textarea)\n      }\n    }\n  }\n\n  /* -------------------------------------------------- */\n  /*                       Groups                       */\n  /* -------------------------------------------------- */\n\n  static flattenShape = (data: TDSnapshot, shape: TDShape): TDShape[] => {\n    return [\n      shape,\n      ...(shape.children ?? [])\n        .map((childId) => TLDR.getShape(data, childId, data.appState.currentPageId))\n        .sort((a, b) => a.childIndex - b.childIndex)\n        .flatMap((shape) => TLDR.flattenShape(data, shape)),\n    ]\n  }\n\n  static flattenPage = (data: TDSnapshot, pageId: string): TDShape[] => {\n    return Object.values(data.document.pages[pageId].shapes)\n      .sort((a, b) => a.childIndex - b.childIndex)\n      .reduce<TDShape[]>((acc, shape) => [...acc, ...TLDR.flattenShape(data, shape)], [])\n  }\n\n  static getTopChildIndex = (data: TDSnapshot, pageId: string): number => {\n    const shapes = TLDR.getShapes(data, pageId)\n    return shapes.length === 0\n      ? 1\n      : shapes\n          .filter((shape) => shape.parentId === pageId)\n          .sort((a, b) => b.childIndex - a.childIndex)[0].childIndex + 1\n  }\n\n  /* -------------------------------------------------- */\n  /*                        Text                        */\n  /* -------------------------------------------------- */\n\n  static fixNewLines = /\\r?\\n|\\r/g\n\n  static normalizeText(text: string) {\n    return text\n      .replace(TLDR.fixNewLines, '\\n')\n      .split('\\n')\n      .map((x) => x || ' ')\n      .join('\\n')\n  }\n\n  /* -------------------------------------------------- */\n  /*                     Assertions                     */\n  /* -------------------------------------------------- */\n\n  static assertShapeHasProperty<P extends keyof TDShape>(\n    shape: TDShape,\n    prop: P\n  ): asserts shape is ShapesWithProp<P> {\n    if (shape[prop] === undefined) {\n      throw new Error()\n    }\n  }\n\n  static warn(e: any) {\n    if (isDev) {\n      console.warn(e)\n    }\n  }\n  static error(e: any) {\n    if (isDev) {\n      console.error(e)\n    }\n  }\n\n  /* -------------------------------------------------- */\n  /*                       Export                       */\n  /* -------------------------------------------------- */\n\n  static getSvgString(svg: SVGElement, scale = 1) {\n    const clone = svg.cloneNode(true) as SVGGraphicsElement\n\n    svg.setAttribute('width', +svg.getAttribute('width')! * scale + '')\n    svg.setAttribute('height', +svg.getAttribute('height')! * scale + '')\n\n    return new XMLSerializer()\n      .serializeToString(clone)\n      .replaceAll('&#10;      ', '')\n      .replaceAll(/((\\s|\")[0-9]*\\.[0-9]{2})([0-9]*)(\\b|\"|\\))/g, '$1')\n  }\n\n  static getSvgAsDataUrl(svg: SVGElement, scale = 1) {\n    const svgString = TLDR.getSvgString(svg, scale)\n\n    const base64SVG = window.btoa(unescape(svgString))\n\n    return `data:image/svg+xml;base64,${base64SVG}`\n  }\n\n  static async getImageForSvg(\n    svg: SVGElement,\n    type: Exclude<TDExportType, TDExportType.JSON> = TDExportType.PNG,\n    opts = {} as Partial<{\n      scale: number\n      quality: number\n    }>\n  ) {\n    const { scale = 2, quality = 1 } = opts\n\n    const svgString = TLDR.getSvgString(svg, scale)\n\n    const width = +svg.getAttribute('width')!\n    const height = +svg.getAttribute('height')!\n\n    if (!svgString) return\n\n    const canvas = await new Promise<HTMLCanvasElement>((resolve) => {\n      const image = new Image()\n\n      image.crossOrigin = 'anonymous'\n\n      const base64SVG = window.btoa(unescape(encodeURIComponent(svgString)))\n\n      const dataUrl = `data:image/svg+xml;base64,${base64SVG}`\n\n      image.onload = () => {\n        const canvas = document.createElement('canvas') as HTMLCanvasElement\n        const context = canvas.getContext('2d')!\n\n        canvas.width = width\n        canvas.height = height\n\n        context.drawImage(image, 0, 0, width, height)\n\n        URL.revokeObjectURL(dataUrl)\n\n        resolve(canvas)\n      }\n\n      image.onerror = () => {\n        console.warn('Could not convert that SVG to an image.')\n      }\n\n      image.src = dataUrl\n    })\n\n    const blob = await new Promise<Blob>((resolve) =>\n      canvas.toBlob((blob) => resolve(blob!), 'image/' + type, quality)\n    )\n\n    return blob\n  }\n}\n", "import type { Easing } from '~types'\n\nexport const LETTER_SPACING = '-0.03em'\nexport const LINE_HEIGHT = 1\nexport const GRID_SIZE = 8\nexport const SVG_EXPORT_PADDING = 16\nexport const BINDING_DISTANCE = 16\nexport const CLONING_DISTANCE = 32\nexport const FIT_TO_SCREEN_PADDING = 128\nexport const SNAP_DISTANCE = 5\nexport const EMPTY_ARRAY = [] as any[]\nexport const SLOW_SPEED = 10\nexport const VERY_SLOW_SPEED = 2.5\nexport const GHOSTED_OPACITY = 0.3\nexport const DEAD_ZONE = 3\nexport const LABEL_POINT = [0.5, 0.5]\n\nexport const PI2 = Math.PI * 2\n\nexport const FILE_EXTENSION = '.tldr'\n\nexport const EASINGS: Record<Easing, (t: number) => number> = {\n  linear: (t) => t,\n  easeInQuad: (t) => t * t,\n  easeOutQuad: (t) => t * (2 - t),\n  easeInOutQuad: (t) => (t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t),\n  easeInCubic: (t) => t * t * t,\n  easeOutCubic: (t) => --t * t * t + 1,\n  easeInOutCubic: (t) => (t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1),\n  easeInQuart: (t) => t * t * t * t,\n  easeOutQuart: (t) => 1 - --t * t * t * t,\n  easeInOutQuart: (t) => (t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t),\n  easeInQuint: (t) => t * t * t * t * t,\n  easeOutQuint: (t) => 1 + --t * t * t * t * t,\n  easeInOutQuint: (t) => (t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t),\n  easeInSine: (t) => 1 - Math.cos((t * Math.PI) / 2),\n  easeOutSine: (t) => Math.sin((t * Math.PI) / 2),\n  easeInOutSine: (t) => -(Math.cos(Math.PI * t) - 1) / 2,\n  easeInExpo: (t) => (t <= 0 ? 0 : Math.pow(2, 10 * t - 10)),\n  easeOutExpo: (t) => (t >= 1 ? 1 : 1 - Math.pow(2, -10 * t)),\n  easeInOutExpo: (t) =>\n    t <= 0\n      ? 0\n      : t >= 1\n      ? 1\n      : t < 0.5\n      ? Math.pow(2, 20 * t - 10) / 2\n      : (2 - Math.pow(2, -20 * t + 10)) / 2,\n}\n\nexport const EASING_STRINGS: Record<Easing, string> = {\n  linear: `(t) => t`,\n  easeInQuad: `(t) => t * t`,\n  easeOutQuad: `(t) => t * (2 - t)`,\n  easeInOutQuad: `(t) => (t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t)`,\n  easeInCubic: `(t) => t * t * t`,\n  easeOutCubic: `(t) => --t * t * t + 1`,\n  easeInOutCubic: `(t) => t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1`,\n  easeInQuart: `(t) => t * t * t * t`,\n  easeOutQuart: `(t) => 1 - --t * t * t * t`,\n  easeInOutQuart: `(t) => t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t`,\n  easeInQuint: `(t) => t * t * t * t * t`,\n  easeOutQuint: `(t) => 1 + --t * t * t * t * t`,\n  easeInOutQuint: `(t) => t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t`,\n  easeInSine: `(t) => 1 - Math.cos((t * Math.PI) / 2)`,\n  easeOutSine: `(t) => Math.sin((t * Math.PI) / 2)`,\n  easeInOutSine: `(t) => -(Math.cos(Math.PI * t) - 1) / 2`,\n  easeInExpo: `(t) => (t <= 0 ? 0 : Math.pow(2, 10 * t - 10))`,\n  easeOutExpo: `(t) => (t >= 1 ? 1 : 1 - Math.pow(2, -10 * t))`,\n  easeInOutExpo: `(t) => t <= 0 ? 0 : t >= 1 ? 1 : t < 0.5 ? Math.pow(2, 20 * t - 10) / 2 : (2 - Math.pow(2, -20 * t + 10)) / 2`,\n}\n\nexport const USER_COLORS = [\n  '#EC5E41',\n  '#F2555A',\n  '#F04F88',\n  '#E34BA9',\n  '#BD54C6',\n  '#9D5BD2',\n  '#7B66DC',\n  '#02B1CC',\n  '#11B3A3',\n  '#39B178',\n  '#55B467',\n  '#FF802B',\n]\n\nexport const isSafari =\n  typeof Window === 'undefined' ? false : /^((?!chrome|android).)*safari/i.test(navigator.userAgent)\n\nexport const isLinux = typeof Window === 'undefined' ? false : /linux/i.test(navigator.userAgent)\n\nexport const IMAGE_EXTENSIONS = ['.png', '.svg', '.jpg', '.jpeg', '.gif']\n\nexport const VIDEO_EXTENSIONS = isSafari ? [] : ['.mp4', '.webm']\n", "/**\n * Deep copy function for TypeScript.\n * @param T Generic type of target/copied value.\n * @param target Target value to be copied.\n * @see Source project, ts-deeply https://github.com/ykdr2017/ts-deepcopy\n * @see Code pen https://codepen.io/erikvullings/pen/ejyBYg\n */\nexport function deepCopy<T>(target: T): T {\n  if (target === null) {\n    return target\n  }\n  if (target instanceof Date) {\n    return new Date(target.getTime()) as any\n  }\n\n  // First part is for array and second part is for Realm.Collection\n  // if (target instanceof Array || typeof (target as any).type === 'string') {\n  if (typeof target === 'object') {\n    if (typeof target[Symbol.iterator as keyof T] === 'function') {\n      const cp = [] as any[]\n      if ((target as any as any[]).length > 0) {\n        for (const arrayMember of target as any as any[]) {\n          cp.push(deepCopy(arrayMember))\n        }\n      }\n      return cp as any as T\n    } else {\n      const targetKeys = Object.keys(target)\n      const cp = {} as T\n      if (targetKeys.length > 0) {\n        for (const key of targetKeys) {\n          cp[key as keyof T] = deepCopy(target[key as keyof T])\n        }\n      }\n      return cp\n    }\n  }\n\n  // Means that object is atomic\n  return target\n}\n", "import { SVGContainer, TLBounds, Utils } from '@tldraw/core'\nimport {\n  intersectArcBounds,\n  intersectLineSegmentBounds,\n  intersectLineSegmentLineSegment,\n} from '@tldraw/intersect'\nimport { Vec } from '@tldraw/vec'\nimport * as React from 'react'\nimport { GHOSTED_OPACITY } from '~constants'\nimport { TDShapeUtil } from '~state/shapes/TDShapeUtil'\nimport {\n  LabelMask,\n  TextLabel,\n  defaultStyle,\n  getFontFace,\n  getFontSize,\n  getFontStyle,\n  getShapeStyle,\n  getTextLabelSize,\n  getTextSvgElement,\n} from '~state/shapes/shared'\nimport { styled } from '~styles'\nimport {\n  AlignStyle,\n  ArrowShape,\n  DashStyle,\n  Decoration,\n  TDMeta,\n  TDShapeType,\n  TransformInfo,\n} from '~types'\nimport {\n  getArcLength,\n  getArcPoints,\n  getArrowPath,\n  getBendPoint,\n  getCtp,\n  isAngleBetween,\n} from './arrowHelpers'\nimport { CurvedArrow } from './components/CurvedArrow.tsx'\nimport { StraightArrow } from './components/StraightArrow'\n\ntype T = ArrowShape\ntype E = HTMLDivElement\n\nexport class ArrowUtil extends TDShapeUtil<T, E> {\n  type = TDShapeType.Arrow as const\n\n  hideBounds = true\n\n  canEdit = true\n\n  pathCache = new WeakMap<T, string>()\n\n  getShape = (props: Partial<T>): T => {\n    return {\n      id: 'id',\n      type: TDShapeType.Arrow,\n      name: 'Arrow',\n      parentId: 'page',\n      childIndex: 1,\n      point: [0, 0],\n      rotation: 0,\n      bend: 0,\n      handles: {\n        start: {\n          id: 'start',\n          index: 0,\n          point: [0, 0],\n          canBind: true,\n          ...props.handles?.start,\n        },\n        end: {\n          id: 'end',\n          index: 1,\n          point: [1, 1],\n          canBind: true,\n          ...props.handles?.end,\n        },\n        bend: {\n          id: 'bend',\n          index: 2,\n          point: [0.5, 0.5],\n          ...props.handles?.bend,\n        },\n      },\n      decorations: props.decorations ?? {\n        end: Decoration.Arrow,\n      },\n      style: {\n        ...defaultStyle,\n        isFilled: false,\n        ...props.style,\n      },\n      label: '',\n      labelPoint: [0.5, 0.5],\n      ...props,\n    }\n  }\n\n  Component = TDShapeUtil.Component<T, E, TDMeta>(\n    ({ shape, isEditing, isGhost, meta, events, onShapeChange, onShapeBlur }, ref) => {\n      const {\n        id,\n        label = '',\n        handles: { start, bend, end },\n        decorations = {},\n        style,\n      } = shape\n\n      const hasLabel = label?.trim()?.length ?? 0 > 0\n\n      const isStraightLine = Vec.dist(bend.point, Vec.toFixed(Vec.med(start.point, end.point))) < 1\n\n      const font = getFontStyle(style)\n\n      const styles = getShapeStyle(style, meta.isDarkMode)\n\n      const labelSize = hasLabel || isEditing ? getTextLabelSize(label, font) : [0, 0]\n\n      const bounds = this.getBounds(shape)\n\n      const dist = React.useMemo(() => {\n        const { start, bend, end } = shape.handles\n        if (isStraightLine) return Vec.dist(start.point, end.point)\n        const circle = getCtp(start.point, bend.point, end.point)\n        const center = circle.slice(0, 2)\n        const radius = circle[2]\n        const length = getArcLength(center, radius, start.point, end.point)\n        return Math.abs(length)\n      }, [shape.handles])\n\n      const scale = Math.max(\n        0.5,\n        Math.min(1, Math.max(dist / (labelSize[1] + 128), dist / (labelSize[0] + 128)))\n      )\n\n      const offset = React.useMemo(() => {\n        const bounds = this.getBounds(shape)\n        const offset = Vec.sub(\n          shape.handles.bend.point,\n          Vec.toFixed([bounds.width / 2, bounds.height / 2])\n        )\n        return offset\n      }, [shape, scale])\n\n      const handleLabelChange = React.useCallback(\n        (label: string) => {\n          onShapeChange?.({ id, label })\n        },\n        [onShapeChange]\n      )\n\n      const Component = isStraightLine ? StraightArrow : CurvedArrow\n\n      return (\n        <FullWrapper ref={ref} {...events}>\n          <TextLabel\n            font={font}\n            text={label}\n            color={styles.stroke}\n            offsetX={offset[0]}\n            offsetY={offset[1]}\n            scale={scale}\n            isEditing={isEditing}\n            onChange={handleLabelChange}\n            onBlur={onShapeBlur}\n          />\n          <SVGContainer id={shape.id + '_svg'}>\n            <defs>\n              <mask id={shape.id + '_clip'}>\n                <rect\n                  x={-100}\n                  y={-100}\n                  width={bounds.width + 200}\n                  height={bounds.height + 200}\n                  fill=\"white\"\n                />\n                <rect\n                  x={bounds.width / 2 - (labelSize[0] / 2) * scale + offset[0]}\n                  y={bounds.height / 2 - (labelSize[1] / 2) * scale + offset[1]}\n                  width={labelSize[0] * scale}\n                  height={labelSize[1] * scale}\n                  rx={4 * scale}\n                  ry={4 * scale}\n                  fill=\"black\"\n                  opacity={1}\n                />\n              </mask>\n            </defs>\n            <g\n              pointerEvents=\"none\"\n              opacity={isGhost ? GHOSTED_OPACITY : 1}\n              mask={hasLabel || isEditing ? `url(#${shape.id}_clip)` : ``}\n            >\n              <Component\n                id={id}\n                style={style}\n                start={start.point}\n                end={end.point}\n                bend={bend.point}\n                arrowBend={shape.bend}\n                decorationStart={decorations?.start}\n                decorationEnd={decorations?.end}\n                isDraw={style.dash === DashStyle.Draw}\n                isDarkMode={meta.isDarkMode}\n              />\n            </g>\n          </SVGContainer>\n        </FullWrapper>\n      )\n    }\n  )\n\n  Indicator = TDShapeUtil.Indicator<ArrowShape>(({ shape, bounds }) => {\n    const {\n      style,\n      decorations,\n      label,\n      handles: { start, bend, end },\n    } = shape\n\n    const hasLabel = label?.trim()?.length ?? 0 > 0\n\n    const font = getFontStyle(style)\n    const labelSize = hasLabel ? getTextLabelSize(label!, font) : [0, 0]\n    const isStraightLine = Vec.dist(bend.point, Vec.toFixed(Vec.med(start.point, end.point))) < 1\n\n    const dist = React.useMemo(() => {\n      const { start, bend, end } = shape.handles\n      if (isStraightLine) return Vec.dist(start.point, end.point)\n      const circle = getCtp(start.point, bend.point, end.point)\n      const center = circle.slice(0, 2)\n      const radius = circle[2]\n      const length = getArcLength(center, radius, start.point, end.point)\n      return Math.abs(length)\n    }, [shape.handles])\n\n    const scale = Math.max(\n      0.5,\n      Math.min(1, Math.max(dist / (labelSize[1] + 128), dist / (labelSize[0] + 128)))\n    )\n\n    const offset = React.useMemo(() => {\n      const bounds = this.getBounds(shape)\n      const offset = Vec.sub(shape.handles.bend.point, [bounds.width / 2, bounds.height / 2])\n      return offset\n    }, [shape, scale])\n\n    return (\n      <>\n        {hasLabel && (\n          <LabelMask\n            id={shape.id}\n            scale={scale}\n            offset={offset}\n            bounds={bounds}\n            labelSize={labelSize}\n          />\n        )}\n        <path\n          d={getArrowPath(\n            style,\n            start.point,\n            bend.point,\n            end.point,\n            decorations?.start,\n            decorations?.end\n          )}\n          mask={hasLabel ? `url(#${shape.id}_clip)` : ``}\n        />\n        {hasLabel && (\n          <rect\n            x={bounds.width / 2 - (labelSize[0] / 2) * scale + offset[0]}\n            y={bounds.height / 2 - (labelSize[1] / 2) * scale + offset[1]}\n            width={labelSize[0] * scale}\n            height={labelSize[1] * scale}\n            rx={4 * scale}\n            ry={4 * scale}\n            fill=\"transparent\"\n          />\n        )}\n      </>\n    )\n  })\n\n  getBounds = (shape: T) => {\n    const bounds = Utils.getFromCache(this.boundsCache, shape, () => {\n      const {\n        handles: { start, bend, end },\n      } = shape\n      return Utils.getBoundsFromPoints(getArcPoints(start.point, bend.point, end.point))\n    })\n    return Utils.translateBounds(bounds, shape.point)\n  }\n\n  getRotatedBounds = (shape: T) => {\n    const {\n      handles: { start, bend, end },\n    } = shape\n    let points = getArcPoints(start.point, bend.point, end.point)\n    const { minX, minY, maxX, maxY } = Utils.getBoundsFromPoints(points)\n    if (shape.rotation !== 0) {\n      points = points.map((pt) =>\n        Vec.rotWith(pt, [(minX + maxX) / 2, (minY + maxY) / 2], shape.rotation || 0)\n      )\n    }\n\n    return Utils.translateBounds(Utils.getBoundsFromPoints(points), shape.point)\n  }\n\n  getCenter = (shape: T) => {\n    const { start, end } = shape.handles\n    return Vec.add(shape.point, Vec.med(start.point, end.point))\n  }\n\n  shouldRender = (prev: T, next: T) => {\n    return (\n      next.decorations !== prev.decorations ||\n      next.handles !== prev.handles ||\n      next.style !== prev.style ||\n      next.label !== prev.label\n    )\n  }\n\n  hitTestPoint = (shape: T, point: number[]): boolean => {\n    const {\n      handles: { start, bend, end },\n    } = shape\n    const pt = Vec.sub(point, shape.point)\n    const points = getArcPoints(start.point, bend.point, end.point)\n    for (let i = 1; i < points.length; i++) {\n      if (Vec.distanceToLineSegment(points[i - 1], points[i], pt) < 1) {\n        return true\n      }\n    }\n    return false\n  }\n\n  hitTestLineSegment = (shape: T, A: number[], B: number[]): boolean => {\n    const {\n      handles: { start, bend, end },\n    } = shape\n    const ptA = Vec.sub(A, shape.point)\n    const ptB = Vec.sub(B, shape.point)\n    const points = getArcPoints(start.point, bend.point, end.point)\n    for (let i = 1; i < points.length; i++) {\n      if (intersectLineSegmentLineSegment(points[i - 1], points[i], ptA, ptB).didIntersect) {\n        return true\n      }\n    }\n    return false\n  }\n\n  hitTestBounds = (shape: T, bounds: TLBounds) => {\n    const { start, end, bend } = shape.handles\n    const sp = Vec.add(shape.point, start.point)\n    const ep = Vec.add(shape.point, end.point)\n    if (Utils.pointInBounds(sp, bounds) || Utils.pointInBounds(ep, bounds)) {\n      return true\n    }\n    if (Vec.isEqual(Vec.med(start.point, end.point), bend.point)) {\n      return intersectLineSegmentBounds(sp, ep, bounds).length > 0\n    } else {\n      const [cx, cy, r] = getCtp(start.point, bend.point, end.point)\n      const cp = Vec.add(shape.point, [cx, cy])\n      return intersectArcBounds(cp, r, sp, ep, bounds).length > 0\n    }\n  }\n\n  transform = (\n    shape: T,\n    bounds: TLBounds,\n    { initialShape, scaleX, scaleY }: TransformInfo<T>\n  ): Partial<T> => {\n    const initialShapeBounds = this.getBounds(initialShape)\n    const handles: (keyof T['handles'])[] = ['start', 'end']\n    const nextHandles = { ...initialShape.handles }\n\n    handles.forEach((handle) => {\n      if (handle === 'bend') return\n\n      const [x, y] = nextHandles[handle].point\n      const nw = x / initialShapeBounds.width\n      const nh = y / initialShapeBounds.height\n      nextHandles[handle] = {\n        ...nextHandles[handle],\n        point: [\n          bounds.width * (scaleX < 0 ? 1 - nw : nw),\n          bounds.height * (scaleY < 0 ? 1 - nh : nh),\n        ],\n      }\n    })\n\n    // If we've flipped one of the dimensions (but not both) then invert shape.bend\n\n    const nextBend =\n      (scaleX > 0 && scaleY < 0) || (scaleX < 0 && scaleY > 0)\n        ? -initialShape.bend\n        : initialShape.bend\n\n    // Find the position of the bend handle based on the new start / end handles and the new bend\n    const bendPoint = getBendPoint(nextHandles, nextBend)\n    nextHandles.bend.point = bendPoint\n\n    return {\n      point: Vec.toFixed([bounds.minX, bounds.minY]),\n      handles: nextHandles,\n      bend: nextBend, // does this change?\n    }\n  }\n\n  onDoubleClickHandle = (shape: T, handle: Partial<T['handles']>): Partial<T> | void => {\n    switch (handle) {\n      case 'bend': {\n        return {\n          bend: 0,\n          handles: {\n            ...shape.handles,\n            bend: {\n              ...shape.handles.bend,\n              point: getBendPoint(shape.handles, shape.bend),\n            },\n          },\n        }\n      }\n      case 'start': {\n        return {\n          decorations: {\n            ...shape.decorations,\n            start: shape.decorations?.start ? undefined : Decoration.Arrow,\n          },\n        }\n      }\n      case 'end': {\n        return {\n          decorations: {\n            ...shape.decorations,\n            end: shape.decorations?.end ? undefined : Decoration.Arrow,\n          },\n        }\n      }\n    }\n\n    return this\n  }\n\n  onHandleChange = (shape: T, handles: Partial<T['handles']>): Partial<T> | void => {\n    let nextHandles = Utils.deepMerge<ArrowShape['handles']>(shape.handles, handles)\n    let nextBend = shape.bend\n\n    nextHandles = Utils.deepMerge(nextHandles, {\n      start: {\n        point: Vec.toFixed(nextHandles.start.point),\n      },\n      end: {\n        point: Vec.toFixed(nextHandles.end.point),\n      },\n    })\n\n    // This will produce NaN values\n    if (Vec.isEqual(nextHandles.start.point, nextHandles.end.point)) return\n\n    // If the user is moving the bend handle, we want to move the bend point\n    if ('bend' in handles) {\n      const { start, end, bend } = nextHandles\n\n      const distance = Vec.dist(start.point, end.point)\n      const midPoint = Vec.med(start.point, end.point)\n      const angle = Vec.angle(start.point, end.point)\n      const u = Vec.uni(Vec.vec(start.point, end.point))\n\n      // Create a line segment perendicular to the line between the start and end points\n      const ap = Vec.add(midPoint, Vec.mul(Vec.per(u), distance))\n      const bp = Vec.sub(midPoint, Vec.mul(Vec.per(u), distance))\n\n      const bendPoint = Vec.nearestPointOnLineSegment(ap, bp, bend.point, true)\n\n      // Find the distance between the midpoint and the nearest point on the\n      // line segment to the bend handle's dragged point\n      const bendDist = Vec.dist(midPoint, bendPoint)\n\n      // The shape's \"bend\" is the ratio of the bend to the distance between\n      // the start and end points. If the bend is below a certain amount, the\n      // bend should be zero.\n      const realBend = bendDist / (distance / 2)\n\n      nextBend = Utils.clamp(realBend, -0.99, 0.99)\n\n      // If the point is to the left of the line segment, we make the bend\n      // negative, otherwise it's positive.\n      const angleToBend = Vec.angle(start.point, bendPoint)\n\n      // If resulting bend is low enough that the handle will snap to center,\n      // then also snap the bend to center\n\n      if (Vec.isEqual(midPoint, getBendPoint(nextHandles, nextBend))) {\n        nextBend = 0\n      } else if (isAngleBetween(angle, angle + Math.PI, angleToBend)) {\n        // Otherwise, fix the bend direction\n        nextBend *= -1\n      }\n    }\n\n    const nextShape = {\n      point: shape.point,\n      bend: nextBend,\n      handles: {\n        ...nextHandles,\n        bend: {\n          ...nextHandles.bend,\n          point: getBendPoint(nextHandles, nextBend),\n        },\n      },\n    }\n\n    // Zero out the handles to prevent handles with negative points. If a handle's x or y\n    // is below zero, we need to move the shape left or up to make it zero.\n    const topLeft = shape.point\n\n    const nextBounds = this.getBounds({ ...nextShape } as ArrowShape)\n\n    const offset = Vec.sub([nextBounds.minX, nextBounds.minY], topLeft)\n\n    if (!Vec.isEqual(offset, [0, 0])) {\n      Object.values(nextShape.handles).forEach((handle) => {\n        handle.point = Vec.toFixed(Vec.sub(handle.point, offset))\n      })\n      nextShape.point = Vec.toFixed(Vec.add(nextShape.point, offset))\n    }\n\n    return nextShape\n  }\n\n  getSvgElement = (shape: ArrowShape, isDarkMode: boolean): SVGElement | void => {\n    const elm = document.getElementById(shape.id + '_svg')?.cloneNode(true) as SVGElement\n    if (!elm) return // possibly in test mode\n    const hasLabel = shape.label?.trim()?.length ?? 0 > 0\n    if (hasLabel) {\n      const s = shape as ArrowShape\n      const g = document.createElementNS('http://www.w3.org/2000/svg', 'g')\n\n      const font = getFontStyle(shape.style)\n      const labelSize = getTextLabelSize(shape.label!, font)\n      const fontSize = getFontSize(shape.style.size, shape.style.font) * (shape.style.scale ?? 1)\n      const fontFamily = getFontFace(shape.style.font).slice(1, -1)\n\n      const labelElm = getTextSvgElement(\n        s.label!,\n        fontSize,\n        fontFamily,\n        AlignStyle.Start,\n        labelSize[0],\n        false\n      )\n\n      let dist: number\n\n      const { start, bend, end } = shape.handles\n      const isStraightLine = Vec.dist(bend.point, Vec.toFixed(Vec.med(start.point, end.point))) < 1\n      if (isStraightLine) {\n        dist = Vec.dist(start.point, end.point)\n      } else {\n        const circle = getCtp(start.point, bend.point, end.point)\n        const center = circle.slice(0, 2)\n        const radius = circle[2]\n        const length = getArcLength(center, radius, start.point, end.point)\n        dist = Math.abs(length)\n      }\n\n      const scale = Math.max(\n        0.5,\n        Math.min(1, Math.max(dist / (labelSize[1] + 128), dist / (labelSize[0] + 128)))\n      )\n      const bounds = this.getBounds(shape)\n\n      const offset = Vec.sub(shape.handles.bend.point, [bounds.width / 2, bounds.height / 2])\n      const x = bounds.width / 2 - (labelSize[0] / 2) * scale + offset[0]\n      const y = bounds.height / 2 - (labelSize[1] / 2) * scale + offset[1]\n\n      labelElm.setAttribute('transform', `translate(${x}, ${y})`)\n      labelElm.setAttribute('fill', getShapeStyle(shape.style, isDarkMode).stroke)\n      labelElm.setAttribute('transform-origin', 'center center')\n      g.setAttribute('text-align', 'center')\n      g.setAttribute('text-anchor', 'middle')\n      g.appendChild(elm)\n      g.appendChild(labelElm)\n      return g\n    }\n    return elm\n  }\n}\n\nconst FullWrapper = styled('div', { width: '100%', height: '100%' })\n", "import { TLShapeUtil, Utils } from '@tldraw/core'\nimport type { TLBounds, TLPointerInfo } from '@tldraw/core'\nimport {\n  intersectLineSegmentBounds,\n  intersectLineSegmentPolyline,\n  intersectRayBounds,\n} from '@tldraw/intersect'\nimport { Vec } from '@tldraw/vec'\nimport * as React from 'react'\nimport { BINDING_DISTANCE } from '~constants'\nimport { AlignStyle, ShapesWithProp, TDBinding, TDMeta, TDShape, TransformInfo } from '~types'\nimport { getFontFace, getFontSize, getFontStyle, getShapeStyle } from './shared'\nimport { getTextLabelSize } from './shared/getTextSize'\nimport { getTextSvgElement } from './shared/getTextSvgElement'\n\nexport abstract class TDShapeUtil<T extends TDShape, E extends Element = any> extends TLShapeUtil<\n  T,\n  E,\n  TDMeta\n> {\n  abstract type: T['type']\n\n  canBind = false\n\n  canEdit = false\n\n  canClone = false\n\n  isAspectRatioLocked = false\n\n  hideResizeHandles = false\n\n  bindingDistance = BINDING_DISTANCE\n\n  abstract getShape: (props: Partial<T>) => T\n\n  hitTestPoint = (shape: T, point: number[]): boolean => {\n    return Utils.pointInBounds(point, this.getRotatedBounds(shape))\n  }\n\n  hitTestLineSegment = (shape: T, A: number[], B: number[]): boolean => {\n    const box = Utils.getBoundsFromPoints([A, B])\n    const bounds = this.getBounds(shape)\n\n    return Utils.boundsContain(bounds, box) || shape.rotation\n      ? intersectLineSegmentPolyline(A, B, Utils.getRotatedCorners(this.getBounds(shape)))\n          .didIntersect\n      : intersectLineSegmentBounds(A, B, this.getBounds(shape)).length > 0\n  }\n\n  create = (props: { id: string } & Partial<T>) => {\n    this.refMap.set(props.id, React.createRef())\n    return this.getShape(props)\n  }\n\n  getCenter = (shape: T) => {\n    return Utils.getBoundsCenter(this.getBounds(shape))\n  }\n\n  getExpandedBounds = (shape: T) => {\n    return Utils.expandBounds(this.getBounds(shape), this.bindingDistance)\n  }\n\n  getBindingPoint = <K extends TDShape>(\n    shape: T,\n    fromShape: K,\n    point: number[],\n    origin: number[],\n    direction: number[],\n    bindAnywhere: boolean\n  ) => {\n    // Algorithm time! We need to find the binding point (a normalized point inside of the shape, or around the shape, where the arrow will point to) and the distance from the binding shape to the anchor.\n\n    const bounds = this.getBounds(shape)\n    const expandedBounds = this.getExpandedBounds(shape)\n\n    // The point must be inside of the expanded bounding box\n    if (!Utils.pointInBounds(point, expandedBounds)) return\n\n    const intersections = intersectRayBounds(origin, direction, expandedBounds)\n      .filter((int) => int.didIntersect)\n      .map((int) => int.points[0])\n\n    if (!intersections.length) return\n\n    // The center of the shape\n    const center = this.getCenter(shape)\n\n    // Find furthest intersection between ray from origin through point and expanded bounds. TODO: What if the shape has a curve? In that case, should we intersect the circle-from-three-points instead?\n    const intersection = intersections.sort((a, b) => Vec.dist(b, origin) - Vec.dist(a, origin))[0]\n\n    // The point between the handle and the intersection\n    const middlePoint = Vec.med(point, intersection)\n\n    // The anchor is the point in the shape where the arrow will be pointing\n    let anchor: number[]\n\n    // The distance is the distance from the anchor to the handle\n    let distance: number\n\n    if (bindAnywhere) {\n      // If the user is indicating that they want to bind inside of the shape, we just use the handle's point\n      anchor = Vec.dist(point, center) < BINDING_DISTANCE / 2 ? center : point\n      distance = 0\n    } else {\n      if (Vec.distanceToLineSegment(point, middlePoint, center) < BINDING_DISTANCE / 2) {\n        // If the line segment would pass near to the center, snap the anchor the center point\n        anchor = center\n      } else {\n        // Otherwise, the anchor is the middle point between the handle and the intersection\n        anchor = middlePoint\n      }\n\n      if (Utils.pointInBounds(point, bounds)) {\n        // If the point is inside of the shape, use the shape's binding distance\n\n        distance = this.bindingDistance\n      } else {\n        // Otherwise, use the actual distance from the handle point to nearest edge\n        distance = Math.max(\n          this.bindingDistance,\n          Utils.getBoundsSides(bounds)\n            .map((side) => Vec.distanceToLineSegment(side[1][0], side[1][1], point))\n            .sort((a, b) => a - b)[0]\n        )\n      }\n    }\n\n    // The binding point is a normalized point indicating the position of the anchor.\n    // An anchor at the middle of the shape would be (0.5, 0.5). When the shape's bounds\n    // changes, we will re-recalculate the actual anchor point by multiplying the\n    // normalized point by the shape's new bounds.\n    const bindingPoint = Vec.divV(Vec.sub(anchor, [expandedBounds.minX, expandedBounds.minY]), [\n      expandedBounds.width,\n      expandedBounds.height,\n    ])\n\n    return {\n      point: Vec.clampV(bindingPoint, 0, 1),\n      distance,\n    }\n  }\n\n  mutate = (shape: T, props: Partial<T>): Partial<T> => {\n    return props\n  }\n\n  transform = (shape: T, bounds: TLBounds, info: TransformInfo<T>): Partial<T> => {\n    return { ...shape, point: [bounds.minX, bounds.minY] }\n  }\n\n  transformSingle = (shape: T, bounds: TLBounds, info: TransformInfo<T>): Partial<T> | void => {\n    return this.transform(shape, bounds, info)\n  }\n\n  updateChildren?: <K extends TDShape>(shape: T, children: K[]) => Partial<K>[] | void\n\n  onChildrenChange?: (shape: T, children: TDShape[]) => Partial<T> | void\n\n  onHandleChange?: (shape: T, handles: Partial<T['handles']>) => Partial<T> | void\n\n  onRightPointHandle?: (\n    shape: T,\n    handles: Partial<T['handles']>,\n    info: Partial<TLPointerInfo>\n  ) => Partial<T> | void\n\n  onDoubleClickHandle?: (\n    shape: T,\n    handles: Partial<T['handles']>,\n    info: Partial<TLPointerInfo>\n  ) => Partial<T> | void\n\n  onDoubleClickBoundsHandle?: (shape: T) => Partial<T> | void\n\n  onSessionComplete?: (shape: T) => Partial<T> | void\n\n  getSvgElement = (shape: T, isDarkMode: boolean): SVGElement | void => {\n    const elm = document.getElementById(shape.id + '_svg')?.cloneNode(true) as SVGElement\n    if (!elm) return // possibly in test mode\n    const hasLabel = shape.label?.trim()?.length ?? 0 > 0\n    if (hasLabel) {\n      const s = shape as TDShape & { label: string }\n      const g = document.createElementNS('http://www.w3.org/2000/svg', 'g')\n\n      const font = getFontStyle(shape.style)\n      const labelSize = getTextLabelSize(shape.label!, font)\n      const fontSize = getFontSize(shape.style.size, shape.style.font) * (shape.style.scale ?? 1)\n      const fontFamily = getFontFace(shape.style.font).slice(1, -1)\n\n      const labelElm = getTextSvgElement(\n        s['label'],\n        fontSize,\n        fontFamily,\n        AlignStyle.Middle,\n        labelSize[0],\n        false\n      )\n\n      const bounds = this.getBounds(shape)\n\n      labelElm.setAttribute(\n        'transform',\n        `translate(${bounds.width / 2 - labelSize[0] / 2}, ${bounds.height / 2 - labelSize[1] / 2})`\n      )\n      labelElm.setAttribute('fill', getShapeStyle(shape.style, isDarkMode).stroke)\n      labelElm.setAttribute('transform-origin', 'center center')\n      g.setAttribute('text-align', 'center')\n      g.setAttribute('text-anchor', 'middle')\n      g.appendChild(elm)\n      g.appendChild(labelElm)\n      return g\n    }\n    return elm\n  }\n}\n", "import { TLBounds, TLShape, Utils } from '@tldraw/core'\n\n/**\n * Find the bounds of a rectangular shape.\n * @param shape\n * @param boundsCache\n */\nexport function getBoundsRectangle<T extends TLShape & { size: number[] }>(\n  shape: T,\n  boundsCache: WeakMap<T, TLBounds>\n) {\n  const bounds = Utils.getFromCache(boundsCache, shape, () => {\n    const [width, height] = shape.size\n    return {\n      minX: 0,\n      maxX: width,\n      minY: 0,\n      maxY: height,\n      width,\n      height,\n    }\n  })\n\n  return Utils.translateBounds(bounds, shape.point)\n}\n", "import { AlignStyle } from '~types'\n\nconst ALIGN_VALUES = {\n  [AlignStyle.Start]: 'left',\n  [AlignStyle.Middle]: 'center',\n  [AlignStyle.End]: 'right',\n  [AlignStyle.Justify]: 'justify',\n} as const\n\nexport function getTextAlign(alignStyle: AlignStyle = AlignStyle.Start) {\n  return ALIGN_VALUES[alignStyle]\n}\n", "import { LETTER_SPACING } from '~constants'\nimport { FontStyle } from '~types'\n\nlet melm: any\n\nfunction getMeasurementDiv() {\n  // A div used for measurement\n  document.getElementById('__textLabelMeasure')?.remove()\n\n  const pre = document.createElement('pre')\n  pre.id = '__textLabelMeasure'\n\n  Object.assign(pre.style, {\n    whiteSpace: 'pre',\n    width: 'auto',\n    border: '1px solid transparent',\n    padding: '4px',\n    margin: '0px',\n    letterSpacing: LETTER_SPACING,\n    opacity: '0',\n    position: 'absolute',\n    top: '-500px',\n    left: '0px',\n    zIndex: '9999',\n    pointerEvents: 'none',\n    userSelect: 'none',\n    alignmentBaseline: 'mathematical',\n    dominantBaseline: 'mathematical',\n  })\n\n  pre.tabIndex = -1\n\n  document.body.appendChild(pre)\n  return pre\n}\n\nif (typeof window !== 'undefined') {\n  melm = getMeasurementDiv()\n}\n\nlet prevText = ''\nlet prevFont = ''\nlet prevSize = [0, 0]\n\nexport function clearPrevSize() {\n  prevText = ''\n}\n\nexport function getTextLabelSize(text: string, font: string) {\n  if (!text) {\n    return [16, 32]\n  }\n\n  if (!melm) {\n    // We're in SSR\n    return [10, 10]\n  }\n\n  if (!melm.parent) document.body.appendChild(melm)\n\n  if (text === prevText && font === prevFont) {\n    return prevSize\n  }\n\n  prevText = text\n  prevFont = font\n\n  melm.textContent = text\n  melm.style.font = font\n\n  // In tests, offsetWidth and offsetHeight will be 0\n  const width = melm.offsetWidth || 1\n  const height = melm.offsetHeight || 1\n\n  prevSize = [width, height]\n  return prevSize\n}\n", "import { LETTER_SPACING } from '~constants'\nimport { AlignStyle } from '~types'\n\n// https://drafts.csswg.org/css-text/#word-separator\n// split on any of these characters\nconst wordSeparator = new RegExp(\n  `${[0x0020, 0x00a0, 0x1361, 0x10100, 0x10101, 0x1039, 0x1091]\n    .map((c) => String.fromCodePoint(c))\n    .join('|')}`\n)\n\nexport function getTextSvgElement(\n  text: string,\n  fontSize: number,\n  fontFamily: string,\n  textAlign: AlignStyle,\n  width: number,\n  wrap = false\n) {\n  const fontWeight = 'normal'\n  const lineHeight = 1\n  const letterSpacingPct = LETTER_SPACING\n\n  // Collect lines\n\n  const lines = breakText({\n    text,\n    wrap,\n    width,\n    fontSize,\n    fontWeight,\n    fontFamily,\n    fontStyle: 'normal',\n    textAlign: 'left',\n    letterSpacing: LETTER_SPACING,\n    lineHeight: 1,\n  })\n\n  const textElm = document.createElementNS('http://www.w3.org/2000/svg', 'text')\n  textElm.setAttribute('font-size', fontSize + 'px')\n  textElm.setAttribute('font-family', fontFamily)\n  textElm.setAttribute('font-weight', fontWeight)\n  textElm.setAttribute('line-height', lineHeight * fontSize + 'px')\n  textElm.setAttribute('letter-spacing', letterSpacingPct)\n  textElm.setAttribute('text-align', textAlign ?? 'left')\n  textElm.setAttribute('dominant-baseline', 'mathematical')\n  textElm.setAttribute('alignment-baseline', 'mathematical')\n\n  const textLines = lines.map((line, i) => {\n    const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan')\n    tspan.textContent = line + '\\n'\n    tspan.setAttribute('y', lineHeight * fontSize * (i + 0.5) + 'px')\n    textElm.appendChild(tspan)\n    return tspan\n  })\n\n  switch (textAlign) {\n    case AlignStyle.Middle: {\n      textElm.setAttribute('text-align', 'center')\n      textElm.setAttribute('text-anchor', 'middle')\n      textLines.forEach((textElm) => textElm.setAttribute('x', width / 2 + ''))\n      break\n    }\n    case AlignStyle.End: {\n      textElm.setAttribute('text-align', 'right')\n      textElm.setAttribute('text-anchor', 'end')\n      textLines.forEach((textElm) => textElm.setAttribute('x', -4 + width + ''))\n      break\n    }\n    default: {\n      textElm.setAttribute('text-align', 'left')\n      textElm.setAttribute('text-anchor', 'start')\n      textLines.forEach((textElm) => textElm.setAttribute('x', 4 + ''))\n    }\n  }\n\n  return textElm\n}\n\nfunction breakText(opts: {\n  text: string\n  wrap: boolean\n  width: number\n  fontSize: number\n  fontWeight: string\n  fontFamily: string\n  fontStyle: string\n  lineHeight: number\n  letterSpacing: string\n  textAlign: string\n}): string[] {\n  const textElm = document.createElement('div')\n  textElm.style.setProperty('position', 'absolute')\n  textElm.style.setProperty('top', '-9999px')\n  textElm.style.setProperty('left', '-9999px')\n  textElm.style.setProperty('width', opts.width + 'px')\n  textElm.style.setProperty('height', 'min-content')\n  textElm.style.setProperty('font-size', opts.fontSize + 'px')\n  textElm.style.setProperty('font-family', opts.fontFamily)\n  textElm.style.setProperty('font-weight', opts.fontWeight)\n  textElm.style.setProperty('line-height', opts.lineHeight * opts.fontSize + 'px')\n  textElm.style.setProperty('letter-spacing', opts.letterSpacing)\n  textElm.style.setProperty('text-align', opts.textAlign)\n  document.body.appendChild(textElm)\n\n  // Collect lines\n\n  // Split the text into words\n  const words = opts.text\n    .split(wordSeparator)\n    .flatMap((word) => word.replace('\\n', ' \\n'))\n    .join(' ')\n    .split(' ')\n\n  // Iterate through the words looking for either line breaks, or\n  // when the measured line exceeds the width of the container (minus\n  // its padding); at either point, create a new line.\n\n  textElm.innerText = words[0]\n  let prevHeight = textElm.offsetHeight\n\n  let currentLine = [words[0]]\n  const lines: string[][] = [currentLine]\n\n  for (let i = 1; i < words.length; i++) {\n    const word = words[i]\n    textElm.innerText += ' ' + word\n    const newHeight = textElm.offsetHeight\n    if (newHeight > prevHeight) {\n      prevHeight = newHeight\n      currentLine = []\n      lines.push(currentLine)\n    }\n\n    // Push the current word to the current line\n    currentLine.push(word)\n  }\n\n  textElm.remove()\n\n  return lines.map((line) => line.join(' '))\n}\n", "import type { TLBounds } from '@tldraw/core'\nimport * as React from 'react'\n\ninterface WithLabelMaskProps {\n  id: string\n  bounds: TLBounds\n  labelSize: number[]\n  offset?: number[]\n  scale?: number\n}\n\nexport function LabelMask({ id, bounds, labelSize, offset, scale = 1 }: WithLabelMaskProps) {\n  return (\n    <defs>\n      <mask id={id + '_clip'}>\n        <rect\n          x={-100}\n          y={-100}\n          width={bounds.width + 200}\n          height={bounds.height + 200}\n          fill=\"white\"\n        />\n        <rect\n          x={bounds.width / 2 - (labelSize[0] / 2) * scale + (offset?.[0] || 0)}\n          y={bounds.height / 2 - (labelSize[1] / 2) * scale + (offset?.[1] || 0)}\n          width={labelSize[0] * scale}\n          height={labelSize[1] * scale}\n          rx={4 * scale}\n          ry={4 * scale}\n          fill=\"black\"\n          opacity={Math.max(scale, 0.8)}\n        />\n      </mask>\n    </defs>\n  )\n}\n", "import { intersectLineLine } from '@tldraw/intersect'\nimport Vec from '@tldraw/vec'\n\nconst PI2 = Math.PI * 2\n\ntype Vert = number[]\ntype Edge = Vert[]\ntype Polygon = Vert[]\n\nexport class PolygonUtils {\n  static inwardEdgeNormal(edge: Edge) {\n    // Assuming that polygon vertices are in clockwise order\n    const delta = Vec.sub(edge[1], edge[0])\n    const len = Vec.len2(delta)\n    return [-delta[0] / len, delta[1] / len]\n  }\n\n  static outwardEdgeNormal(edge: Edge) {\n    return Vec.neg(PolygonUtils.inwardEdgeNormal(edge))\n  }\n\n  // If the slope of line v1,v2 greater than the slope of v1,p then p is on the left side of v1,v2 and the return value is > 0.\n  // If p is colinear with v1,v2 then return 0, otherwise return a value < 0.\n\n  static leftSide = Vec.isLeft\n\n  static isReflexVertex(polygon: Polygon, index: number) {\n    const len = polygon.length\n    // Assuming that polygon vertices are in clockwise order\n    const v0 = polygon[(index + len - 1) % len]\n    const v1 = polygon[index]\n    const v2 = polygon[(index + 1) % len]\n    if (PolygonUtils.leftSide(v0, v2, v1) < 0) return true\n    return false\n  }\n\n  static getEdges(vertices: Vert[]) {\n    return vertices.map((vert, i) => [vert, vertices[(i + 1) % vertices.length]])\n  }\n\n  // based on http://local.wasp.uwa.edu.au/~pbourke/geometry/lineline2d/, A => \"line a\", B => \"line b\"\n  static edgesIntersection([A1, A2]: number[][], [B1, B2]: number[][]) {\n    const den = (B2[1] - B1[1]) * (A2[0] - A1[0]) - (B2[0] - B1[0]) * (A2[1] - A1[1])\n\n    if (den == 0) return null // lines are parallel or conincident\n\n    const ua = ((B2[0] - B1[0]) * (A1[1] - B1[1]) - (B2[1] - B1[1]) * (A1[0] - B1[0])) / den\n\n    const ub = ((A2[0] - A1[0]) * (A1[1] - B1[1]) - (A2[1] - A1[1]) * (A1[0] - B1[0])) / den\n\n    if (ua < 0 || ub < 0 || ua > 1 || ub > 1) return null\n\n    return [A1[0] + ua * (A2[0] - A1[0]), A1[1] + ua * (A2[1] - A1[1])]\n  }\n\n  static appendArc(\n    polygon: number[][],\n    center: number[],\n    radius: number,\n    startVertex: number[],\n    endVertex: number[],\n    isPaddingBoundary = false\n  ) {\n    const vertices = [...polygon]\n    let startAngle = Math.atan2(startVertex[1] - center[1], startVertex[0] - center[0])\n    let endAngle = Math.atan2(endVertex[1] - center[1], endVertex[0] - center[0])\n    if (startAngle < 0) startAngle += PI2\n    if (endAngle < 0) endAngle += PI2\n    const arcSegmentCount = 5 // An odd number so that one arc vertex will be eactly arcRadius from center.\n    const angle = startAngle > endAngle ? startAngle - endAngle : startAngle + PI2 - endAngle\n    const angle5 = (isPaddingBoundary ? -angle : PI2 - angle) / arcSegmentCount\n\n    vertices.push(startVertex)\n    for (let i = 1; i < arcSegmentCount; ++i) {\n      const angle = startAngle + angle5 * i\n      vertices.push([center[0] + Math.cos(angle) * radius, center[1] + Math.sin(angle) * radius])\n    }\n    vertices.push(endVertex)\n\n    return vertices\n  }\n\n  static createOffsetEdge(edge: Edge, offset: number[]) {\n    return edge.map((vert) => Vec.add(vert, offset))\n  }\n\n  static getOffsetPolygon(polygon: Polygon, offset = 0) {\n    const edges = PolygonUtils.getEdges(polygon)\n\n    const offsetEdges = edges.map((edge) =>\n      PolygonUtils.createOffsetEdge(edge, Vec.mul(PolygonUtils.outwardEdgeNormal(edge), offset))\n    )\n\n    const vertices = []\n\n    for (let i = 0; i < offsetEdges.length; i++) {\n      const thisEdge = offsetEdges[i]\n      const prevEdge = offsetEdges[(i + offsetEdges.length - 1) % offsetEdges.length]\n      const vertex = PolygonUtils.edgesIntersection(prevEdge, thisEdge)\n      if (vertex) vertices.push(vertex)\n      else {\n        PolygonUtils.appendArc(vertices, edges[i][0], offset, prevEdge[1], thisEdge[0], false)\n      }\n    }\n\n    // var marginPolygon = PolygonUtils.createPolygon(vertices)\n    // marginPolygon.offsetEdges = offsetEdges\n    return vertices\n  }\n\n  static createPaddingPolygon(polygon: number[][][], shapePadding = 0) {\n    const offsetEdges = polygon.map((edge) =>\n      PolygonUtils.createOffsetEdge(edge, PolygonUtils.inwardEdgeNormal(edge))\n    )\n\n    const vertices = []\n    for (let i = 0; i < offsetEdges.length; i++) {\n      const thisEdge = offsetEdges[i]\n      const prevEdge = offsetEdges[(i + offsetEdges.length - 1) % offsetEdges.length]\n      const vertex = PolygonUtils.edgesIntersection(prevEdge, thisEdge)\n      if (vertex) vertices.push(vertex)\n      else {\n        PolygonUtils.appendArc(\n          vertices,\n          polygon[i][0],\n          shapePadding,\n          prevEdge[1],\n          thisEdge[0],\n          true\n        )\n      }\n    }\n\n    return vertices\n  }\n}\n\nexport function getOffsetPolygon(points: number[][], offset: number) {\n  if (points.length < 3) throw Error('Polygon must have at least 3 points')\n  const len = points.length\n  return points\n    .map((point, i) => [point, points[(i + 1) % len]])\n    .map(([A, B]) => {\n      const offsetVector = Vec.mul(Vec.per(Vec.uni(Vec.sub(B, A))), offset)\n      return [Vec.add(A, offsetVector), Vec.add(B, offsetVector)]\n    })\n    .map((edge, i, edges) => {\n      const intersection = intersectLineLine(edge, edges[(i + 1) % edges.length])\n      if (intersection === undefined) throw Error('Expected an intersection')\n      return intersection\n    })\n}\n", "import { Utils } from '@tldraw/core'\nimport { AlignStyle, ColorStyle, DashStyle, FontStyle, ShapeStyles, SizeStyle, Theme } from '~types'\n\nconst canvasLight = '#fafafa'\n\nconst canvasDark = '#343d45'\n\nconst colors = {\n  [ColorStyle.White]: '#f0f1f3',\n  [ColorStyle.LightGray]: '#c6cbd1',\n  [ColorStyle.Gray]: '#788492',\n  [ColorStyle.Black]: '#1d1d1d',\n  [ColorStyle.Green]: '#36b24d',\n  [ColorStyle.Cyan]: '#0e98ad',\n  [ColorStyle.Blue]: '#1c7ed6',\n  [ColorStyle.Indigo]: '#4263eb',\n  [ColorStyle.Violet]: '#7746f1',\n  [ColorStyle.Red]: '#ff2133',\n  [ColorStyle.Orange]: '#ff9433',\n  [ColorStyle.Yellow]: '#ffc936',\n}\n\nexport const stickyFills: Record<Theme, Record<ColorStyle, string>> = {\n  light: {\n    ...(Object.fromEntries(\n      Object.entries(colors).map(([k, v]) => [k, Utils.lerpColor(v, canvasLight, 0.45)])\n    ) as Record<ColorStyle, string>),\n    [ColorStyle.White]: '#ffffff',\n    [ColorStyle.Black]: '#3d3d3d',\n  },\n  dark: {\n    ...(Object.fromEntries(\n      Object.entries(colors).map(([k, v]) => [\n        k,\n        Utils.lerpColor(Utils.lerpColor(v, '#999999', 0.3), canvasDark, 0.4),\n      ])\n    ) as Record<ColorStyle, string>),\n    [ColorStyle.White]: '#1d1d1d',\n    [ColorStyle.Black]: '#bbbbbb',\n  },\n}\n\nexport const strokes: Record<Theme, Record<ColorStyle, string>> = {\n  light: {\n    ...colors,\n    [ColorStyle.White]: '#1d1d1d',\n  },\n  dark: {\n    ...(Object.fromEntries(\n      Object.entries(colors).map(([k, v]) => [k, Utils.lerpColor(v, canvasDark, 0.1)])\n    ) as Record<ColorStyle, string>),\n    [ColorStyle.White]: '#cecece',\n    [ColorStyle.Black]: '#cecece',\n  },\n}\n\nexport const fills: Record<Theme, Record<ColorStyle, string>> = {\n  light: {\n    ...(Object.fromEntries(\n      Object.entries(colors).map(([k, v]) => [k, Utils.lerpColor(v, canvasLight, 0.82)])\n    ) as Record<ColorStyle, string>),\n    [ColorStyle.White]: '#fefefe',\n  },\n  dark: {\n    ...(Object.fromEntries(\n      Object.entries(colors).map(([k, v]) => [k, Utils.lerpColor(v, canvasDark, 0.82)])\n    ) as Record<ColorStyle, string>),\n    [ColorStyle.White]: 'rgb(30,33,37)',\n    [ColorStyle.Black]: '#1e1e1f',\n  },\n}\n\nconst strokeWidths = {\n  [SizeStyle.Small]: 2,\n  [SizeStyle.Medium]: 3.5,\n  [SizeStyle.Large]: 5,\n}\n\nconst fontSizes = {\n  [SizeStyle.Small]: 28,\n  [SizeStyle.Medium]: 48,\n  [SizeStyle.Large]: 96,\n  auto: 'auto',\n}\n\nconst fontFaces = {\n  [FontStyle.Script]: '\"Caveat Brush\"',\n  [FontStyle.Sans]: '\"Source Sans Pro\"',\n  [FontStyle.Serif]: '\"Crimson Pro\"',\n  [FontStyle.Mono]: '\"Source Code Pro\"',\n}\n\nconst fontSizeModifiers = {\n  [FontStyle.Script]: 1,\n  [FontStyle.Sans]: 1,\n  [FontStyle.Serif]: 1,\n  [FontStyle.Mono]: 1,\n}\n\nconst stickyFontSizes = {\n  [SizeStyle.Small]: 24,\n  [SizeStyle.Medium]: 36,\n  [SizeStyle.Large]: 48,\n  auto: 'auto',\n}\n\nexport function getStrokeWidth(size: SizeStyle): number {\n  return strokeWidths[size]\n}\n\nexport function getFontSize(size: SizeStyle, fontStyle: FontStyle = FontStyle.Script): number {\n  return fontSizes[size] * fontSizeModifiers[fontStyle]\n}\n\nexport function getFontFace(font: FontStyle = FontStyle.Script): string {\n  return fontFaces[font]\n}\n\nexport function getStickyFontSize(size: SizeStyle): number {\n  return stickyFontSizes[size]\n}\n\nexport function getFontStyle(style: ShapeStyles): string {\n  const fontSize = getFontSize(style.size, style.font)\n  const fontFace = getFontFace(style.font)\n  const { scale = 1 } = style\n\n  return `${fontSize * scale}px/1 ${fontFace}`\n}\n\nexport function getStickyFontStyle(style: ShapeStyles): string {\n  const fontSize = getStickyFontSize(style.size)\n  const fontFace = getFontFace(style.font)\n  const { scale = 1 } = style\n\n  return `${fontSize * scale}px/1 ${fontFace}`\n}\n\nexport function getStickyShapeStyle(style: ShapeStyles, isDarkMode = false) {\n  const { color } = style\n\n  const theme: Theme = isDarkMode ? 'dark' : 'light'\n  const adjustedColor =\n    color === ColorStyle.White || color === ColorStyle.Black ? ColorStyle.Yellow : color\n\n  return {\n    fill: stickyFills[theme][adjustedColor],\n    stroke: strokes[theme][adjustedColor],\n    color: isDarkMode ? '#1d1d1d' : '#0d0d0d',\n  }\n}\n\nexport function getShapeStyle(\n  style: ShapeStyles,\n  isDarkMode?: boolean\n): {\n  stroke: string\n  fill: string\n  strokeWidth: number\n} {\n  const { color, size, isFilled } = style\n\n  const strokeWidth = getStrokeWidth(size)\n\n  const theme: Theme = isDarkMode ? 'dark' : 'light'\n\n  return {\n    stroke: strokes[theme][color],\n    fill: isFilled ? fills[theme][color] : 'none',\n    strokeWidth,\n  }\n}\n\nexport const defaultStyle: ShapeStyles = {\n  color: ColorStyle.Black,\n  size: SizeStyle.Small,\n  isFilled: false,\n  dash: DashStyle.Draw,\n  scale: 1,\n}\n\nexport const defaultTextStyle: ShapeStyles = {\n  ...defaultStyle,\n  font: FontStyle.Script,\n  textAlign: AlignStyle.Middle,\n}\n", "// Adapted (mostly copied) the work of https://github.com/fregante\n// Copyright (c) Federico Brigante <opensource@bfred.it> (bfred.it)\n\ntype ReplacerCallback = (substring: string, ...args: unknown[]) => string\n\nconst INDENT = '  '\n\nexport class TextAreaUtils {\n  static insertTextFirefox(field: HTMLTextAreaElement | HTMLInputElement, text: string): void {\n    // Found on https://www.everythingfrontend.com/posts/insert-text-into-textarea-at-cursor-position.html \uD83C\uDF88\n    field.setRangeText(\n      text,\n      field.selectionStart || 0,\n      field.selectionEnd || 0,\n      'end' // Without this, the cursor is either at the beginning or `text` remains selected\n    )\n\n    field.dispatchEvent(\n      new InputEvent('input', {\n        data: text,\n        inputType: 'insertText',\n        isComposing: false, // TODO: fix @types/jsdom, this shouldn't be required\n      })\n    )\n  }\n\n  /** Inserts `text` at the cursor\u2019s position, replacing any selection, with **undo** support and by firing the `input` event. */\n  static insert(field: HTMLTextAreaElement | HTMLInputElement, text: string): void {\n    const document = field.ownerDocument\n    const initialFocus = document.activeElement\n    if (initialFocus !== field) {\n      field.focus()\n    }\n\n    if (!document.execCommand('insertText', false, text)) {\n      TextAreaUtils.insertTextFirefox(field, text)\n    }\n\n    if (initialFocus === document.body) {\n      field.blur()\n    } else if (initialFocus instanceof HTMLElement && initialFocus !== field) {\n      initialFocus.focus()\n    }\n  }\n\n  /** Replaces the entire content, equivalent to `field.value = text` but with **undo** support and by firing the `input` event. */\n  static set(field: HTMLTextAreaElement | HTMLInputElement, text: string): void {\n    field.select()\n    TextAreaUtils.insert(field, text)\n  }\n\n  /** Get the selected text in a field or an empty string if nothing is selected. */\n  static getSelection(field: HTMLTextAreaElement | HTMLInputElement): string {\n    const { selectionStart, selectionEnd } = field\n    return field.value.slice(\n      selectionStart ? selectionStart : undefined,\n      selectionEnd ? selectionEnd : undefined\n    )\n  }\n\n  /** Adds the `wrappingText` before and after field\u2019s selection (or cursor). If `endWrappingText` is provided, it will be used instead of `wrappingText` at on the right. */\n  static wrapSelection(\n    field: HTMLTextAreaElement | HTMLInputElement,\n    wrap: string,\n    wrapEnd?: string\n  ): void {\n    const { selectionStart, selectionEnd } = field\n    const selection = TextAreaUtils.getSelection(field)\n    TextAreaUtils.insert(field, wrap + selection + (wrapEnd ?? wrap))\n\n    // Restore the selection around the previously-selected text\n    field.selectionStart = (selectionStart || 0) + wrap.length\n    field.selectionEnd = (selectionEnd || 0) + wrap.length\n  }\n\n  /** Finds and replaces strings and regex in the field\u2019s value, like `field.value = field.value.replace()` but better */\n  static replace(\n    field: HTMLTextAreaElement | HTMLInputElement,\n    searchValue: string | RegExp,\n    replacer: string | ReplacerCallback\n  ): void {\n    /** Remembers how much each match offset should be adjusted */\n    let drift = 0\n\n    field.value.replace(searchValue, (...args): string => {\n      // Select current match to replace it later\n      const matchStart = drift + (args[args.length - 2] as number)\n      const matchLength = args[0].length\n      field.selectionStart = matchStart\n      field.selectionEnd = matchStart + matchLength\n\n      const replacement = typeof replacer === 'string' ? replacer : replacer(...args)\n      TextAreaUtils.insert(field, replacement)\n\n      // Select replacement. Without this, the cursor would be after the replacement\n      field.selectionStart = matchStart\n      drift += replacement.length - matchLength\n      return replacement\n    })\n  }\n\n  static findLineEnd(value: string, currentEnd: number): number {\n    // Go to the beginning of the last line\n    const lastLineStart = value.lastIndexOf('\\n', currentEnd - 1) + 1\n\n    // There's nothing to unindent after the last cursor, so leave it as is\n    if (value.charAt(lastLineStart) !== '\\t') {\n      return currentEnd\n    }\n\n    return lastLineStart + 1 // Include the first character, which will be a tab\n  }\n\n  static indent(element: HTMLTextAreaElement): void {\n    const { selectionStart, selectionEnd, value } = element\n    const selectedContrast = value.slice(selectionStart, selectionEnd)\n    // The first line should be indented, even if it starts with `\\n`\n    // The last line should only be indented if includes any character after `\\n`\n    const lineBreakCount = /\\n/g.exec(selectedContrast)?.length\n\n    if (lineBreakCount && lineBreakCount > 0) {\n      // Select full first line to replace everything at once\n      const firstLineStart = value.lastIndexOf('\\n', selectionStart - 1) + 1\n\n      const newSelection = element.value.slice(firstLineStart, selectionEnd - 1)\n      const indentedText = newSelection.replace(\n        /^|\\n/g, // Match all line starts\n        `$&${INDENT}`\n      )\n      const replacementsCount = indentedText.length - newSelection.length\n\n      // Replace newSelection with indentedText\n      element.setSelectionRange(firstLineStart, selectionEnd - 1)\n      TextAreaUtils.insert(element, indentedText)\n\n      // Restore selection position, including the indentation\n      element.setSelectionRange(selectionStart + 1, selectionEnd + replacementsCount)\n    } else {\n      TextAreaUtils.insert(element, INDENT)\n    }\n  }\n\n  // The first line should always be unindented\n  // The last line should only be unindented if the selection includes any characters after `\\n`\n  static unindent(element: HTMLTextAreaElement): void {\n    const { selectionStart, selectionEnd, value } = element\n\n    // Select the whole first line because it might contain \\t\n    const firstLineStart = value.lastIndexOf('\\n', selectionStart - 1) + 1\n    const minimumSelectionEnd = TextAreaUtils.findLineEnd(value, selectionEnd)\n\n    const newSelection = element.value.slice(firstLineStart, minimumSelectionEnd)\n    const indentedText = newSelection.replace(/(^|\\n)(\\t| {1,2})/g, '$1')\n    const replacementsCount = newSelection.length - indentedText.length\n\n    // Replace newSelection with indentedText\n    element.setSelectionRange(firstLineStart, minimumSelectionEnd)\n    TextAreaUtils.insert(element, indentedText)\n\n    // Restore selection position, including the indentation\n    const firstLineIndentation = /\\t| {1,2}/.exec(value.slice(firstLineStart, selectionStart))\n\n    const difference = firstLineIndentation ? firstLineIndentation[0].length : 0\n\n    const newSelectionStart = selectionStart - difference\n    element.setSelectionRange(\n      selectionStart - difference,\n      Math.max(newSelectionStart, selectionEnd - replacementsCount)\n    )\n  }\n}\n", "import * as React from 'react'\nimport { stopPropagation } from '~components/stopPropagation'\nimport { GHOSTED_OPACITY, LETTER_SPACING } from '~constants'\nimport { TLDR } from '~state/TLDR'\nimport { styled } from '~styles'\nimport { TextAreaUtils } from './TextAreaUtils'\nimport { getTextLabelSize } from './getTextSize'\n\nexport interface TextLabelProps {\n  font: string\n  text: string\n  color: string\n  onBlur?: () => void\n  onChange: (text: string) => void\n  offsetY?: number\n  offsetX?: number\n  scale?: number\n  isEditing?: boolean\n}\n\nexport const TextLabel = React.memo(function TextLabel({\n  font,\n  text,\n  color,\n  offsetX = 0,\n  offsetY = 0,\n  scale = 1,\n  isEditing = false,\n  onBlur,\n  onChange,\n}: TextLabelProps) {\n  const rInput = React.useRef<HTMLTextAreaElement>(null)\n  const rIsMounted = React.useRef(false)\n\n  const handleChange = React.useCallback(\n    (e: React.ChangeEvent<HTMLTextAreaElement>) => {\n      onChange(TLDR.normalizeText(e.currentTarget.value))\n    },\n    [onChange]\n  )\n  const handleKeyDown = React.useCallback(\n    (e: React.KeyboardEvent<HTMLTextAreaElement>) => {\n      if (e.key === 'Escape') {\n        e.preventDefault()\n        e.stopPropagation()\n        onBlur?.()\n        return\n      }\n\n      if (e.key === 'Tab' && text.length === 0) {\n        e.preventDefault()\n        return\n      }\n\n      if (!(e.key === 'Meta' || e.metaKey)) {\n        e.stopPropagation()\n      } else if (e.key === 'z' && e.metaKey) {\n        if (e.shiftKey) {\n          document.execCommand('redo', false)\n        } else {\n          document.execCommand('undo', false)\n        }\n        e.stopPropagation()\n        e.preventDefault()\n        return\n      }\n\n      if ((e.metaKey || e.ctrlKey) && e.key === '=') {\n        e.preventDefault()\n      }\n\n      if (e.key === 'Tab') {\n        e.preventDefault()\n        if (e.shiftKey) {\n          TextAreaUtils.unindent(e.currentTarget)\n        } else {\n          TextAreaUtils.indent(e.currentTarget)\n        }\n\n        onChange?.(TLDR.normalizeText(e.currentTarget.value))\n      }\n    },\n    [onChange]\n  )\n\n  const handleBlur = React.useCallback(\n    (e: React.FocusEvent<HTMLTextAreaElement>) => {\n      e.currentTarget.setSelectionRange(0, 0)\n      onBlur?.()\n    },\n    [onBlur]\n  )\n\n  const handleFocus = React.useCallback(\n    (e: React.FocusEvent<HTMLTextAreaElement>) => {\n      if (!isEditing) return\n      if (!rIsMounted.current) return\n\n      if (document.activeElement === e.currentTarget) {\n        e.currentTarget.select()\n      }\n    },\n    [isEditing]\n  )\n\n  const handlePointerDown = React.useCallback(\n    (e: React.PointerEvent<HTMLTextAreaElement | HTMLDivElement>) => {\n      if (isEditing) {\n        e.stopPropagation()\n      }\n    },\n    [isEditing]\n  )\n\n  const rWasEditing = React.useRef(isEditing)\n\n  React.useEffect(() => {\n    if (isEditing) {\n      rWasEditing.current = true\n      requestAnimationFrame(() => {\n        rIsMounted.current = true\n        const elm = rInput.current\n        if (elm) {\n          elm.focus()\n          elm.select()\n        }\n      })\n    } else if (rWasEditing.current) {\n      onBlur?.()\n      rWasEditing.current = false\n    }\n  }, [isEditing, onBlur])\n\n  const rInnerWrapper = React.useRef<HTMLDivElement>(null)\n\n  React.useLayoutEffect(() => {\n    const elm = rInnerWrapper.current\n    if (!elm) return\n    const size = getTextLabelSize(text, font)\n    elm.style.transform = `scale(${scale}, ${scale}) translate(${offsetX}px, ${offsetY}px)`\n    elm.style.width = size[0] + 1 + 'px'\n    elm.style.height = size[1] + 1 + 'px'\n  }, [text, font, offsetY, offsetX, scale])\n\n  return (\n    <TextWrapper>\n      <InnerWrapper\n        ref={rInnerWrapper}\n        hasText={!!text}\n        isEditing={isEditing}\n        style={{\n          font,\n          color,\n        }}\n      >\n        {isEditing ? (\n          <TextArea\n            ref={rInput}\n            style={{\n              font,\n              color,\n            }}\n            name=\"text\"\n            tabIndex={-1}\n            autoComplete=\"false\"\n            autoCapitalize=\"false\"\n            autoCorrect=\"false\"\n            autoSave=\"false\"\n            autoFocus\n            placeholder=\"\"\n            spellCheck=\"true\"\n            wrap=\"off\"\n            dir=\"auto\"\n            datatype=\"wysiwyg\"\n            defaultValue={text}\n            color={color}\n            onFocus={handleFocus}\n            onChange={handleChange}\n            onKeyDown={handleKeyDown}\n            onBlur={handleBlur}\n            onPointerDown={handlePointerDown}\n            onContextMenu={stopPropagation}\n            onCopy={stopPropagation}\n            onPaste={stopPropagation}\n            onCut={stopPropagation}\n          />\n        ) : (\n          text\n        )}\n        &#8203;\n      </InnerWrapper>\n    </TextWrapper>\n  )\n})\n\nconst TextWrapper = styled('div', {\n  position: 'absolute',\n  top: 0,\n  left: 0,\n  width: '100%',\n  height: '100%',\n  display: 'flex',\n  alignItems: 'center',\n  justifyContent: 'center',\n  pointerEvents: 'none',\n  userSelect: 'none',\n  variants: {\n    isGhost: {\n      false: { opacity: 1 },\n      true: { transition: 'opacity .2s', opacity: GHOSTED_OPACITY },\n    },\n  },\n})\n\nconst commonTextWrapping = {\n  whiteSpace: 'pre-wrap',\n  overflowWrap: 'break-word',\n  letterSpacing: LETTER_SPACING,\n}\n\nconst InnerWrapper = styled('div', {\n  position: 'absolute',\n  padding: '4px',\n  zIndex: 1,\n  minHeight: 1,\n  minWidth: 1,\n  lineHeight: 1,\n  outline: 0,\n  fontWeight: '500',\n  textAlign: 'center',\n  backfaceVisibility: 'hidden',\n  userSelect: 'none',\n  WebkitUserSelect: 'none',\n  WebkitTouchCallout: 'none',\n  variants: {\n    hasText: {\n      false: {\n        pointerEvents: 'none',\n      },\n      true: {\n        pointerEvents: 'all',\n      },\n    },\n    isEditing: {\n      false: {\n        userSelect: 'none',\n      },\n      true: {\n        background: '$boundsBg',\n        userSelect: 'text',\n        WebkitUserSelect: 'text',\n      },\n    },\n  },\n  ...commonTextWrapping,\n})\n\nconst TextArea = styled('textarea', {\n  position: 'absolute',\n  top: 0,\n  left: 0,\n  zIndex: 1,\n  width: '100%',\n  height: '100%',\n  border: 'none',\n  padding: '4px',\n  resize: 'none',\n  textAlign: 'inherit',\n  minHeight: 'inherit',\n  minWidth: 'inherit',\n  lineHeight: 'inherit',\n  outline: 0,\n  fontWeight: 'inherit',\n  overflow: 'hidden',\n  backfaceVisibility: 'hidden',\n  display: 'inline-block',\n  pointerEvents: 'all',\n  background: '$boundsBg',\n  userSelect: 'text',\n  WebkitUserSelect: 'text',\n  fontSmooth: 'always',\n  WebkitFontSmoothing: 'subpixel-antialiased',\n  MozOsxFontSmoothing: 'auto',\n  ...commonTextWrapping,\n  '&:focus': {\n    outline: 'none',\n    border: 'none',\n  },\n})\n", "import type { TLBounds, TLShape, TLTransformInfo } from '@tldraw/core'\nimport Vec from '@tldraw/vec'\n\n/**\n * Transform a rectangular shape.\n * @param shape\n * @param bounds\n * @param param2\n */\nexport function transformRectangle<T extends TLShape & { size: number[] }>(\n  shape: T,\n  bounds: TLBounds,\n  { initialShape, transformOrigin, scaleX, scaleY }: TLTransformInfo<T>\n) {\n  if (shape.rotation || initialShape.isAspectRatioLocked) {\n    const size = Vec.toFixed(\n      Vec.mul(initialShape.size, Math.min(Math.abs(scaleX), Math.abs(scaleY)))\n    )\n    const point = Vec.toFixed([\n      bounds.minX +\n        (bounds.width - shape.size[0]) * (scaleX < 0 ? 1 - transformOrigin[0] : transformOrigin[0]),\n      bounds.minY +\n        (bounds.height - shape.size[1]) *\n          (scaleY < 0 ? 1 - transformOrigin[1] : transformOrigin[1]),\n    ])\n    const rotation =\n      (scaleX < 0 && scaleY >= 0) || (scaleY < 0 && scaleX >= 0)\n        ? initialShape.rotation\n          ? -initialShape.rotation\n          : 0\n        : initialShape.rotation\n    return {\n      size,\n      point,\n      rotation,\n    }\n  } else {\n    return {\n      point: Vec.toFixed([bounds.minX, bounds.minY]),\n      size: Vec.toFixed([bounds.width, bounds.height]),\n    }\n  }\n}\n", "import type { TLBounds, TLShape } from '@tldraw/core'\nimport Vec from '@tldraw/vec'\n\n/**\n * Transform a single rectangular shape.\n * @param shape\n * @param bounds\n */\nexport function transformSingleRectangle<T extends TLShape & { size: number[] }>(\n  shape: T,\n  bounds: TLBounds\n) {\n  return {\n    size: Vec.toFixed([bounds.width, bounds.height]),\n    point: Vec.toFixed([bounds.minX, bounds.minY]),\n  }\n}\n", "import { Utils } from '@tldraw/core'\nimport { intersectCircleCircle, intersectCircleLineSegment } from '@tldraw/intersect'\nimport Vec from '@tldraw/vec'\nimport getStroke from 'perfect-freehand'\nimport { EASINGS } from '~constants'\nimport { TLDR } from '~state/TLDR'\nimport { getShapeStyle } from '~state/shapes/shared'\nimport type { ArrowShape, Decoration, ShapeStyles } from '~types'\n\nexport function getArrowArcPath(start: number[], end: number[], circle: number[], bend: number) {\n  return [\n    'M',\n    start[0],\n    start[1],\n    'A',\n    circle[2],\n    circle[2],\n    0,\n    0,\n    bend < 0 ? 0 : 1,\n    end[0],\n    end[1],\n  ].join(' ')\n}\n\nexport function getBendPoint(handles: ArrowShape['handles'], bend: number) {\n  const { start, end } = handles\n\n  const dist = Vec.dist(start.point, end.point)\n\n  const midPoint = Vec.med(start.point, end.point)\n\n  const bendDist = (dist / 2) * bend\n\n  const u = Vec.uni(Vec.vec(start.point, end.point))\n\n  const point = Vec.toFixed(\n    Math.abs(bendDist) < 10 ? midPoint : Vec.add(midPoint, Vec.mul(Vec.per(u), bendDist))\n  )\n\n  return point\n}\n\nexport function renderFreehandArrowShaft(\n  id: string,\n  style: ShapeStyles,\n  start: number[],\n  end: number[],\n  decorationStart: Decoration | undefined,\n  decorationEnd: Decoration | undefined\n) {\n  const getRandom = Utils.rng(id)\n  const strokeWidth = getShapeStyle(style).strokeWidth\n  const startPoint = decorationStart ? Vec.nudge(start, end, strokeWidth) : start\n  const endPoint = decorationEnd ? Vec.nudge(end, start, strokeWidth) : end\n  const stroke = getStroke([startPoint, endPoint], {\n    size: strokeWidth,\n    thinning: 0.618 + getRandom() * 0.2,\n    easing: EASINGS.easeOutQuad,\n    simulatePressure: true,\n    streamline: 0,\n    last: true,\n  })\n  return Utils.getSvgPathFromStroke(stroke)\n}\n\nexport function renderCurvedFreehandArrowShaft(\n  id: string,\n  style: ShapeStyles,\n  start: number[],\n  end: number[],\n  decorationStart: Decoration | undefined,\n  decorationEnd: Decoration | undefined,\n  center: number[],\n  radius: number,\n  length: number,\n  easing: (t: number) => number\n) {\n  const getRandom = Utils.rng(id)\n  const strokeWidth = getShapeStyle(style).strokeWidth\n  const startPoint = decorationStart ? Vec.rotWith(start, center, strokeWidth / length) : start\n  const endPoint = decorationEnd ? Vec.rotWith(end, center, -(strokeWidth / length)) : end\n  const startAngle = Vec.angle(center, startPoint)\n  const endAngle = Vec.angle(center, endPoint)\n  const points: number[][] = []\n  const count = 8 + Math.floor((Math.abs(length) / 20) * 1 + getRandom() / 2)\n  for (let i = 0; i < count; i++) {\n    const t = easing(i / count)\n    const angle = Utils.lerpAngles(startAngle, endAngle, t)\n    points.push(Vec.toFixed(Vec.nudgeAtAngle(center, angle, radius)))\n  }\n  const stroke = getStroke([startPoint, ...points, endPoint], {\n    size: 1 + strokeWidth,\n    thinning: 0.618 + getRandom() * 0.2,\n    easing: EASINGS.easeOutQuad,\n    simulatePressure: false,\n    streamline: 0,\n    last: true,\n  })\n  return Utils.getSvgPathFromStroke(stroke)\n}\n\nexport function getCtp(start: number[], bend: number[], end: number[]) {\n  return Utils.circleFromThreePoints(start, end, bend)\n}\n\nexport function getCurvedArrowHeadPoints(\n  A: number[],\n  r1: number,\n  C: number[],\n  r2: number,\n  sweep: boolean\n) {\n  const ints = intersectCircleCircle(A, r1 * 0.618, C, r2).points\n  if (!ints) {\n    TLDR.warn('Could not find an intersection for the arrow head.')\n    return { left: A, right: A }\n  }\n  const int = sweep ? ints[0] : ints[1]\n  const left = int ? Vec.nudge(Vec.rotWith(int, A, Math.PI / 6), A, r1 * -0.382) : A\n  const right = int ? Vec.nudge(Vec.rotWith(int, A, -Math.PI / 6), A, r1 * -0.382) : A\n  return { left, right }\n}\n\nexport function getStraightArrowHeadPoints(A: number[], B: number[], r: number) {\n  const ints = intersectCircleLineSegment(A, r, A, B).points\n  if (!ints) {\n    TLDR.warn('Could not find an intersection for the arrow head.')\n    return { left: A, right: A }\n  }\n  const int = ints[0]\n  const left = int ? Vec.rotWith(int, A, Math.PI / 6) : A\n  const right = int ? Vec.rotWith(int, A, -Math.PI / 6) : A\n  return { left, right }\n}\n\nexport function getCurvedArrowHeadPath(\n  A: number[],\n  r1: number,\n  C: number[],\n  r2: number,\n  sweep: boolean\n) {\n  const { left, right } = getCurvedArrowHeadPoints(A, r1, C, r2, sweep)\n  return `M ${left} L ${A} ${right}`\n}\n\nexport function getStraightArrowHeadPath(A: number[], B: number[], r: number) {\n  const { left, right } = getStraightArrowHeadPoints(A, B, r)\n  return `M ${left} L ${A} ${right}`\n}\n\nexport function getArrowPath(\n  style: ShapeStyles,\n  start: number[],\n  bend: number[],\n  end: number[],\n  decorationStart: Decoration | undefined,\n  decorationEnd: Decoration | undefined\n) {\n  const { strokeWidth } = getShapeStyle(style, false)\n  const arrowDist = Vec.dist(start, end)\n  const arrowHeadLength = Math.min(arrowDist / 3, strokeWidth * 8)\n  const path: (string | number)[] = []\n  const isStraightLine = Vec.dist(bend, Vec.toFixed(Vec.med(start, end))) < 1\n  if (isStraightLine) {\n    path.push(`M ${start} L ${end}`)\n    if (decorationStart) {\n      path.push(getStraightArrowHeadPath(start, end, arrowHeadLength))\n    }\n    if (decorationEnd) {\n      path.push(getStraightArrowHeadPath(end, start, arrowHeadLength))\n    }\n  } else {\n    const circle = getCtp(start, bend, end)\n    const center = [circle[0], circle[1]]\n    const radius = circle[2]\n    const length = getArcLength(center, radius, start, end)\n    path.push(`M ${start} A ${radius} ${radius} 0 0 ${length > 0 ? '1' : '0'} ${end}`)\n    if (decorationStart)\n      path.push(getCurvedArrowHeadPath(start, arrowHeadLength, center, radius, length < 0))\n    if (decorationEnd) {\n      path.push(getCurvedArrowHeadPath(end, arrowHeadLength, center, radius, length >= 0))\n    }\n  }\n  return path.join(' ')\n}\n\nexport function getArcPoints(start: number[], bend: number[], end: number[]) {\n  if (Vec.dist2(bend, Vec.med(start, end)) <= 4) return [start, end]\n  // The arc is curved; calculate twenty points along the arc\n  const points: number[][] = []\n  const circle = getCtp(start, bend, end)\n  const center = [circle[0], circle[1]]\n  const radius = circle[2]\n  const startAngle = Vec.angle(center, start)\n  const endAngle = Vec.angle(center, end)\n  for (let i = 0; i < 20; i++) {\n    const t = i / 19\n    const angle = Utils.lerpAngles(startAngle, endAngle, t)\n    points.push(Vec.nudgeAtAngle(center, angle, radius))\n  }\n  return points\n}\n\nexport function isAngleBetween(a: number, b: number, c: number): boolean {\n  if (c === a || c === b) return true\n  const PI2 = Math.PI * 2\n  const AB = (b - a + PI2) % PI2\n  const AC = (c - a + PI2) % PI2\n  return AB <= Math.PI !== AC > AB\n}\n\nexport function getArcLength(C: number[], r: number, A: number[], B: number[]): number {\n  const sweep = Utils.getSweep(C, A, B)\n  return r * (2 * Math.PI) * (sweep / (2 * Math.PI))\n}\n", "import { Utils } from '@tldraw/core'\nimport Vec from '@tldraw/vec'\nimport * as React from 'react'\nimport { EASINGS } from '~constants'\nimport { getShapeStyle } from '~state/shapes/shared'\nimport type { Decoration, ShapeStyles } from '~types'\nimport {\n  getArcLength,\n  getArrowArcPath,\n  getCtp,\n  getCurvedArrowHeadPoints,\n  renderCurvedFreehandArrowShaft,\n} from '../arrowHelpers'\nimport { Arrowhead } from './ArrowHead'\n\ninterface ArrowSvgProps {\n  id: string\n  style: ShapeStyles\n  start: number[]\n  bend: number[]\n  end: number[]\n  arrowBend: number\n  decorationStart: Decoration | undefined\n  decorationEnd: Decoration | undefined\n  isDarkMode: boolean\n  isDraw: boolean\n}\n\nexport const CurvedArrow = React.memo(function CurvedArrow({\n  id,\n  style,\n  start,\n  bend,\n  end,\n  arrowBend,\n  decorationStart,\n  decorationEnd,\n  isDraw,\n  isDarkMode,\n}: ArrowSvgProps) {\n  const arrowDist = Vec.dist(start, end)\n  if (arrowDist < 2) return null\n  const styles = getShapeStyle(style, isDarkMode)\n  const { strokeWidth } = styles\n  const sw = 1 + strokeWidth * 1.618\n  // Calculate a path as a segment of a circle passing through the three points start, bend, and end\n  const circle = getCtp(start, bend, end)\n  const center = [circle[0], circle[1]]\n  const radius = circle[2]\n  const length = getArcLength(center, radius, start, end)\n  const getRandom = Utils.rng(id)\n  const easing = EASINGS[getRandom() > 0 ? 'easeInOutSine' : 'easeInOutCubic']\n  const path = isDraw\n    ? renderCurvedFreehandArrowShaft(\n        id,\n        style,\n        start,\n        end,\n        decorationStart,\n        decorationEnd,\n        center,\n        radius,\n        length,\n        easing\n      )\n    : getArrowArcPath(start, end, circle, arrowBend)\n  const { strokeDasharray, strokeDashoffset } = Utils.getPerfectDashProps(\n    Math.abs(length),\n    sw,\n    style.dash,\n    2,\n    false\n  )\n  // Arrowheads\n  const arrowHeadLength = Math.min(arrowDist / 3, strokeWidth * 8)\n  const startArrowHead = decorationStart\n    ? getCurvedArrowHeadPoints(start, arrowHeadLength, center, radius, length < 0)\n    : null\n  const endArrowHead = decorationEnd\n    ? getCurvedArrowHeadPoints(end, arrowHeadLength, center, radius, length >= 0)\n    : null\n  return (\n    <>\n      <path className=\"tl-stroke-hitarea\" d={path} />\n      <path\n        d={path}\n        fill={isDraw ? styles.stroke : 'none'}\n        stroke={styles.stroke}\n        strokeWidth={isDraw ? 0 : sw}\n        strokeDasharray={strokeDasharray}\n        strokeDashoffset={strokeDashoffset}\n        strokeLinecap=\"round\"\n        strokeLinejoin=\"round\"\n        pointerEvents=\"none\"\n      />\n      {startArrowHead && (\n        <Arrowhead\n          left={startArrowHead.left}\n          middle={start}\n          right={startArrowHead.right}\n          stroke={styles.stroke}\n          strokeWidth={sw}\n        />\n      )}\n      {endArrowHead && (\n        <Arrowhead\n          left={endArrowHead.left}\n          middle={end}\n          right={endArrowHead.right}\n          stroke={styles.stroke}\n          strokeWidth={sw}\n        />\n      )}\n    </>\n  )\n})\n", "import * as React from 'react'\n\nexport interface ArrowheadProps {\n  left: number[]\n  middle: number[]\n  right: number[]\n  stroke: string\n  strokeWidth: number\n}\n\nexport function Arrowhead({ left, middle, right, stroke, strokeWidth }: ArrowheadProps) {\n  return (\n    <g>\n      <path className=\"tl-stroke-hitarea\" d={`M ${left} L ${middle} ${right}`} />\n      <path\n        d={`M ${left} L ${middle} ${right}`}\n        fill=\"none\"\n        stroke={stroke}\n        strokeWidth={strokeWidth}\n        strokeLinecap=\"round\"\n        strokeLinejoin=\"round\"\n        pointerEvents=\"none\"\n      />\n    </g>\n  )\n}\n", "import { Utils } from '@tldraw/core'\nimport Vec from '@tldraw/vec'\nimport * as React from 'react'\nimport { getShapeStyle } from '~state/shapes/shared'\nimport type { Decoration, ShapeStyles } from '~types'\nimport { getStraightArrowHeadPoints, renderFreehandArrowShaft } from '../arrowHelpers'\nimport { Arrowhead } from './ArrowHead'\n\ninterface ArrowSvgProps {\n  id: string\n  style: ShapeStyles\n  start: number[]\n  bend: number[]\n  end: number[]\n  arrowBend: number\n  decorationStart: Decoration | undefined\n  decorationEnd: Decoration | undefined\n  isDarkMode: boolean\n  isDraw: boolean\n}\n\nexport const StraightArrow = React.memo(function StraightArrow({\n  id,\n  style,\n  start,\n  end,\n  decorationStart,\n  decorationEnd,\n  isDraw,\n  isDarkMode,\n}: ArrowSvgProps) {\n  const arrowDist = Vec.dist(start, end)\n  if (arrowDist < 2) return null\n  const styles = getShapeStyle(style, isDarkMode)\n  const { strokeWidth } = styles\n  const sw = 1 + strokeWidth * 1.618\n  // Path between start and end points\n  const path = isDraw\n    ? renderFreehandArrowShaft(id, style, start, end, decorationStart, decorationEnd)\n    : 'M' + Vec.toFixed(start) + 'L' + Vec.toFixed(end)\n  const { strokeDasharray, strokeDashoffset } = Utils.getPerfectDashProps(\n    arrowDist,\n    strokeWidth * 1.618,\n    style.dash,\n    2,\n    false\n  )\n  // Arrowheads\n  const arrowHeadLength = Math.min(arrowDist / 3, strokeWidth * 8)\n  const startArrowHead = decorationStart\n    ? getStraightArrowHeadPoints(start, end, arrowHeadLength)\n    : null\n  const endArrowHead = decorationEnd\n    ? getStraightArrowHeadPoints(end, start, arrowHeadLength)\n    : null\n  return (\n    <>\n      <path className=\"tl-stroke-hitarea\" d={path} />\n      <path\n        d={path}\n        fill={styles.stroke}\n        stroke={styles.stroke}\n        strokeWidth={isDraw ? sw / 2 : sw}\n        strokeDasharray={strokeDasharray}\n        strokeDashoffset={strokeDashoffset}\n        strokeLinecap=\"round\"\n        strokeLinejoin=\"round\"\n        pointerEvents=\"stroke\"\n      />\n      {startArrowHead && (\n        <Arrowhead\n          left={startArrowHead.left}\n          middle={start}\n          right={startArrowHead.right}\n          stroke={styles.stroke}\n          strokeWidth={sw}\n        />\n      )}\n      {endArrowHead && (\n        <Arrowhead\n          left={endArrowHead.left}\n          middle={end}\n          right={endArrowHead.right}\n          stroke={styles.stroke}\n          strokeWidth={sw}\n        />\n      )}\n    </>\n  )\n})\n", "import { SVGContainer, TLBounds, Utils } from '@tldraw/core'\nimport {\n  intersectBoundsBounds,\n  intersectBoundsPolyline,\n  intersectLineSegmentBounds,\n  intersectLineSegmentLineSegment,\n} from '@tldraw/intersect'\nimport { Vec } from '@tldraw/vec'\nimport * as React from 'react'\nimport { GHOSTED_OPACITY } from '~constants'\nimport { TDShapeUtil } from '~state/shapes/TDShapeUtil'\nimport { defaultStyle, getShapeStyle } from '~state/shapes/shared'\nimport { DashStyle, DrawShape, TDMeta, TDShapeType, TransformInfo } from '~types'\nimport {\n  getDrawStrokePathTDSnapshot,\n  getFillPath,\n  getSolidStrokePathTDSnapshot,\n} from './drawHelpers'\n\ntype T = DrawShape\ntype E = SVGSVGElement\n\nexport class DrawUtil extends TDShapeUtil<T, E> {\n  type = TDShapeType.Draw as const\n\n  pointsBoundsCache = new WeakMap<T['points'], TLBounds>([])\n\n  shapeBoundsCache = new Map<string, TLBounds>()\n\n  rotatedCache = new WeakMap<T, number[][]>([])\n\n  pointCache: Record<string, number[]> = {}\n\n  canClone = true\n\n  getShape = (props: Partial<T>): T => {\n    return Utils.deepMerge<T>(\n      {\n        id: 'id',\n        type: TDShapeType.Draw,\n        name: 'Draw',\n        parentId: 'page',\n        childIndex: 1,\n        point: [0, 0],\n        rotation: 0,\n        style: defaultStyle,\n        points: [],\n        isComplete: false,\n      },\n      props\n    )\n  }\n\n  Component = TDShapeUtil.Component<T, E, TDMeta>(\n    ({ shape, meta, isSelected, isGhost, events }, ref) => {\n      const { points, style, isComplete } = shape\n\n      const polygonPathTDSnapshot = React.useMemo(() => {\n        return getFillPath(shape)\n      }, [points, style.size])\n\n      const pathTDSnapshot = React.useMemo(() => {\n        return style.dash === DashStyle.Draw\n          ? getDrawStrokePathTDSnapshot(shape)\n          : getSolidStrokePathTDSnapshot(shape)\n      }, [points, style.size, style.dash, isComplete])\n\n      const styles = getShapeStyle(style, meta.isDarkMode)\n      const { stroke, fill, strokeWidth } = styles\n\n      // For very short lines, draw a point instead of a line\n      const bounds = this.getBounds(shape)\n\n      const verySmall = bounds.width <= strokeWidth / 2 && bounds.height <= strokeWidth / 2\n\n      if (verySmall) {\n        const sw = 1 + strokeWidth\n\n        return (\n          <SVGContainer ref={ref} id={shape.id + '_svg'} {...events}>\n            <circle\n              r={sw}\n              fill={stroke}\n              stroke={stroke}\n              pointerEvents=\"all\"\n              opacity={isGhost ? GHOSTED_OPACITY : 1}\n            />\n          </SVGContainer>\n        )\n      }\n\n      const shouldFill =\n        style.isFilled &&\n        points.length > 3 &&\n        Vec.dist(points[0], points[points.length - 1]) < strokeWidth * 2\n\n      if (shape.style.dash === DashStyle.Draw) {\n        return (\n          <SVGContainer ref={ref} id={shape.id + '_svg'} {...events}>\n            <g opacity={isGhost ? GHOSTED_OPACITY : 1}>\n              <path\n                className={shouldFill || isSelected ? 'tl-fill-hitarea' : 'tl-stroke-hitarea'}\n                d={pathTDSnapshot}\n              />\n              {shouldFill && (\n                <path\n                  d={polygonPathTDSnapshot}\n                  stroke=\"none\"\n                  fill={fill}\n                  strokeLinejoin=\"round\"\n                  strokeLinecap=\"round\"\n                  pointerEvents=\"none\"\n                />\n              )}\n              <path\n                d={pathTDSnapshot}\n                fill={stroke}\n                stroke={stroke}\n                strokeWidth={strokeWidth / 2}\n                strokeLinejoin=\"round\"\n                strokeLinecap=\"round\"\n                pointerEvents=\"none\"\n              />\n            </g>\n          </SVGContainer>\n        )\n      }\n\n      // For solid, dash and dotted lines, draw a regular stroke path\n\n      const strokeDasharray = {\n        [DashStyle.Draw]: 'none',\n        [DashStyle.Solid]: `none`,\n        [DashStyle.Dotted]: `0.1 ${strokeWidth * 4}`,\n        [DashStyle.Dashed]: `${strokeWidth * 4} ${strokeWidth * 4}`,\n      }[style.dash as DashStyle]\n\n      const strokeDashoffset = {\n        [DashStyle.Draw]: 'none',\n        [DashStyle.Solid]: `none`,\n        [DashStyle.Dotted]: `0`,\n        [DashStyle.Dashed]: `0`,\n      }[style.dash as DashStyle]\n\n      const sw = 1 + strokeWidth * 1.5\n\n      return (\n        <SVGContainer ref={ref} id={shape.id + '_svg'} {...events}>\n          <g opacity={isGhost ? GHOSTED_OPACITY : 1}>\n            <path\n              className={shouldFill && isSelected ? 'tl-fill-hitarea' : 'tl-stroke-hitarea'}\n              d={pathTDSnapshot}\n            />\n            <path\n              d={pathTDSnapshot}\n              fill={shouldFill ? fill : 'none'}\n              stroke=\"none\"\n              strokeWidth={Math.min(4, strokeWidth * 2)}\n              strokeLinejoin=\"round\"\n              strokeLinecap=\"round\"\n              pointerEvents=\"none\"\n            />\n            <path\n              d={pathTDSnapshot}\n              fill=\"none\"\n              stroke={stroke}\n              strokeWidth={sw}\n              strokeDasharray={strokeDasharray}\n              strokeDashoffset={strokeDashoffset}\n              strokeLinejoin=\"round\"\n              strokeLinecap=\"round\"\n              pointerEvents=\"none\"\n            />\n          </g>\n        </SVGContainer>\n      )\n    }\n  )\n\n  Indicator = TDShapeUtil.Indicator<T>(({ shape }) => {\n    const { points } = shape\n\n    const pathTDSnapshot = React.useMemo(() => {\n      return getSolidStrokePathTDSnapshot(shape)\n    }, [points])\n\n    const bounds = this.getBounds(shape)\n\n    const verySmall = bounds.width < 4 && bounds.height < 4\n\n    if (verySmall) {\n      return <circle x={bounds.width / 2} y={bounds.height / 2} r={1} />\n    }\n\n    return <path d={pathTDSnapshot} />\n  })\n\n  transform = (\n    shape: T,\n    bounds: TLBounds,\n    { initialShape, scaleX, scaleY }: TransformInfo<T>\n  ): Partial<T> => {\n    const initialShapeBounds = Utils.getFromCache(this.boundsCache, initialShape, () =>\n      Utils.getBoundsFromPoints(initialShape.points)\n    )\n\n    const points = initialShape.points.map(([x, y, r]) => {\n      return [\n        bounds.width *\n          (scaleX < 0 // * sin?\n            ? 1 - x / initialShapeBounds.width\n            : x / initialShapeBounds.width),\n        bounds.height *\n          (scaleY < 0 // * cos?\n            ? 1 - y / initialShapeBounds.height\n            : y / initialShapeBounds.height),\n        r,\n      ]\n    })\n\n    const newBounds = Utils.getBoundsFromPoints(shape.points)\n\n    const point = Vec.sub([bounds.minX, bounds.minY], [newBounds.minX, newBounds.minY])\n\n    return {\n      points,\n      point,\n    }\n  }\n\n  getBounds = (shape: T) => {\n    // The goal here is to avoid recalculating the bounds from the\n    // points array, which is expensive. However, we still need a\n    // new bounds if the point has changed, but we will reuse the\n    // previous bounds-from-points result if we can.\n\n    const pointsHaveChanged = !this.pointsBoundsCache.has(shape.points)\n    const pointHasChanged = !(this.pointCache[shape.id] === shape.point)\n\n    if (pointsHaveChanged) {\n      // If the points have changed, then bust the points cache\n      const bounds = Utils.getBoundsFromPoints(shape.points)\n      this.pointsBoundsCache.set(shape.points, bounds)\n      this.shapeBoundsCache.set(shape.id, Utils.translateBounds(bounds, shape.point))\n      this.pointCache[shape.id] = shape.point\n    } else if (pointHasChanged && !pointsHaveChanged) {\n      // If the point have has changed, then bust the point cache\n      this.pointCache[shape.id] = shape.point\n      this.shapeBoundsCache.set(\n        shape.id,\n        Utils.translateBounds(this.pointsBoundsCache.get(shape.points)!, shape.point)\n      )\n    }\n\n    return this.shapeBoundsCache.get(shape.id)!\n  }\n\n  shouldRender = (prev: T, next: T) => {\n    return (\n      next.points !== prev.points ||\n      next.style !== prev.style ||\n      next.isComplete !== prev.isComplete\n    )\n  }\n\n  hitTestPoint = (shape: T, point: number[]) => {\n    const ptA = Vec.sub(point, shape.point)\n    return Utils.pointInPolyline(ptA, shape.points)\n  }\n\n  hitTestLineSegment = (shape: T, A: number[], B: number[]): boolean => {\n    const { points, point } = shape\n    const ptA = Vec.sub(A, point)\n    const ptB = Vec.sub(B, point)\n    const bounds = this.getBounds(shape)\n\n    if (bounds.width < 8 && bounds.height < 8) {\n      return Vec.distanceToLineSegment(A, B, Utils.getBoundsCenter(bounds)) < 5 // divide by zoom\n    }\n\n    if (intersectLineSegmentBounds(ptA, ptB, bounds)) {\n      for (let i = 1; i < points.length; i++) {\n        if (intersectLineSegmentLineSegment(points[i - 1], points[i], ptA, ptB).didIntersect) {\n          return true\n        }\n      }\n    }\n\n    return false\n  }\n\n  hitTestBounds = (shape: T, bounds: TLBounds) => {\n    // Test axis-aligned shape\n    if (!shape.rotation) {\n      const shapeBounds = this.getBounds(shape)\n\n      return (\n        Utils.boundsContain(bounds, shapeBounds) ||\n        ((Utils.boundsContain(shapeBounds, bounds) ||\n          intersectBoundsBounds(shapeBounds, bounds).length > 0) &&\n          intersectBoundsPolyline(Utils.translateBounds(bounds, Vec.neg(shape.point)), shape.points)\n            .length > 0)\n      )\n    }\n\n    // Test rotated shape\n    const rBounds = this.getRotatedBounds(shape)\n\n    const rotatedBounds = Utils.getFromCache(this.rotatedCache, shape, () => {\n      const c = Utils.getBoundsCenter(Utils.getBoundsFromPoints(shape.points))\n      return shape.points.map((pt) => Vec.rotWith(pt, c, shape.rotation || 0))\n    })\n\n    return (\n      Utils.boundsContain(bounds, rBounds) ||\n      intersectBoundsPolyline(Utils.translateBounds(bounds, Vec.neg(shape.point)), rotatedBounds)\n        .length > 0\n    )\n  }\n}\n", "import { Utils } from '@tldraw/core'\nimport Vec from '@tldraw/vec'\nimport {\n  StrokeOptions,\n  StrokePoint,\n  getStrokeOutlinePoints,\n  getStrokePoints,\n} from 'perfect-freehand'\nimport { getShapeStyle } from '~state/shapes/shared'\nimport type { DrawShape } from '~types'\n\nconst simulatePressureSettings: StrokeOptions = {\n  easing: (t) => Math.sin((t * Math.PI) / 2),\n  simulatePressure: true,\n}\n\nconst realPressureSettings: StrokeOptions = {\n  easing: (t) => t * t,\n  simulatePressure: false,\n}\n\nexport function getFreehandOptions(shape: DrawShape) {\n  const styles = getShapeStyle(shape.style)\n\n  const options: StrokeOptions = {\n    size: 1 + styles.strokeWidth * 1.5,\n    thinning: 0.65,\n    streamline: 0.65,\n    smoothing: 0.65,\n    ...(shape.points[1][2] === 0.5 ? simulatePressureSettings : realPressureSettings),\n    last: shape.isComplete,\n  }\n\n  return options\n}\n\nexport function getFillPath(shape: DrawShape) {\n  if (shape.points.length < 2) return ''\n\n  return Utils.getSvgPathFromStroke(\n    getStrokePoints(shape.points, getFreehandOptions(shape)).map((pt) => pt.point)\n  )\n}\n\nexport function getDrawStrokePoints(shape: DrawShape, options: StrokeOptions) {\n  return getStrokePoints(shape.points, options)\n}\n\n/**\n * Get path data for a stroke with the DashStyle.Draw dash style.\n */\nexport function getDrawStrokePathTDSnapshot(shape: DrawShape) {\n  if (shape.points.length < 2) return ''\n  const options = getFreehandOptions(shape)\n  const strokePoints = getDrawStrokePoints(shape, options)\n  const path = Utils.getSvgPathFromStroke(getStrokeOutlinePoints(strokePoints, options))\n  return path\n}\n\n/**\n * Get SVG path data for a shape that has a DashStyle other than DashStyles.Draw.\n */\nexport function getSolidStrokePathTDSnapshot(shape: DrawShape) {\n  const { points } = shape\n  if (points.length < 2) return 'M 0 0 L 0 0'\n  const options = getFreehandOptions(shape)\n  const strokePoints = getDrawStrokePoints(shape, options)\n  const last = points[points.length - 1]\n  if (!Vec.isEqual(strokePoints[0].point, last)) strokePoints.push({ point: last } as StrokePoint)\n  const path = Utils.getSvgPathFromStrokePoints(strokePoints)\n  return path\n}\n", "import { SVGContainer, TLBounds, Utils } from '@tldraw/core'\nimport {\n  intersectEllipseBounds,\n  intersectLineSegmentEllipse,\n  intersectRayEllipse,\n} from '@tldraw/intersect'\nimport { Vec } from '@tldraw/vec'\nimport * as React from 'react'\nimport { GHOSTED_OPACITY, LABEL_POINT } from '~constants'\nimport { TDShapeUtil } from '~state/shapes/TDShapeUtil'\nimport { TextLabel, defaultStyle, getFontStyle, getShapeStyle } from '~state/shapes/shared'\nimport { styled } from '~styles'\nimport { DashStyle, EllipseShape, TDMeta, TDShape, TDShapeType, TransformInfo } from '~types'\nimport { DashedEllipse } from './components/DashedEllipse'\nimport { DrawEllipse } from './components/DrawEllipse'\nimport { getEllipseIndicatorPath } from './ellipseHelpers'\n\ntype T = EllipseShape\ntype E = HTMLDivElement\ntype M = TDMeta\n\nexport class EllipseUtil extends TDShapeUtil<T, E> {\n  type = TDShapeType.Ellipse as const\n\n  canBind = true\n\n  canClone = true\n\n  canEdit = true\n\n  getShape = (props: Partial<T>): T => {\n    return Utils.deepMerge<T>(\n      {\n        id: 'id',\n        type: TDShapeType.Ellipse,\n        name: 'Ellipse',\n        parentId: 'page',\n        childIndex: 1,\n        point: [0, 0],\n        radius: [1, 1],\n        rotation: 0,\n        style: defaultStyle,\n        label: '',\n        labelPoint: [0.5, 0.5],\n      },\n      props\n    )\n  }\n\n  Component = TDShapeUtil.Component<T, E, TDMeta>(\n    (\n      {\n        shape,\n        isGhost,\n        isSelected,\n        isBinding,\n        isEditing,\n        meta,\n        bounds,\n        events,\n        onShapeChange,\n        onShapeBlur,\n      },\n      ref\n    ) => {\n      const { id, radius, style, label = '', labelPoint = LABEL_POINT } = shape\n      const font = getFontStyle(shape.style)\n      const styles = getShapeStyle(style, meta.isDarkMode)\n      const strokeWidth = styles.strokeWidth\n      const sw = 1 + strokeWidth * 1.618\n      const rx = Math.max(0, radius[0] - sw / 2)\n      const ry = Math.max(0, radius[1] - sw / 2)\n      const Component = style.dash === DashStyle.Draw ? DrawEllipse : DashedEllipse\n      const handleLabelChange = React.useCallback(\n        (label: string) => onShapeChange?.({ id, label }),\n        [onShapeChange]\n      )\n      return (\n        <FullWrapper ref={ref} {...events}>\n          <TextLabel\n            isEditing={isEditing}\n            onChange={handleLabelChange}\n            onBlur={onShapeBlur}\n            font={font}\n            text={label}\n            color={styles.stroke}\n            offsetX={(labelPoint[0] - 0.5) * bounds.width}\n            offsetY={(labelPoint[1] - 0.5) * bounds.height}\n          />\n          <SVGContainer id={shape.id + '_svg'} opacity={isGhost ? GHOSTED_OPACITY : 1}>\n            {isBinding && (\n              <ellipse\n                className=\"tl-binding-indicator\"\n                cx={radius[0]}\n                cy={radius[1]}\n                rx={rx}\n                ry={ry}\n                strokeWidth={this.bindingDistance}\n              />\n            )}\n            <Component\n              id={id}\n              radius={radius}\n              style={style}\n              isSelected={isSelected}\n              isDarkMode={meta.isDarkMode}\n            />\n          </SVGContainer>\n        </FullWrapper>\n      )\n    }\n  )\n\n  Indicator = TDShapeUtil.Indicator<T, M>(({ shape }) => {\n    const { id, radius, style } = shape\n    const styles = getShapeStyle(style)\n    const strokeWidth = styles.strokeWidth\n    const sw = 1 + strokeWidth * 1.618\n    const rx = Math.max(0, radius[0] - sw / 2)\n    const ry = Math.max(0, radius[1] - sw / 2)\n    return style.dash === DashStyle.Draw ? (\n      <path d={getEllipseIndicatorPath(id, radius, style)} />\n    ) : (\n      <ellipse cx={radius[0]} cy={radius[1]} rx={rx} ry={ry} />\n    )\n  })\n\n  hitTestPoint = (shape: T, point: number[]): boolean => {\n    return (\n      Utils.pointInBounds(point, this.getRotatedBounds(shape)) &&\n      Utils.pointInEllipse(\n        point,\n        this.getCenter(shape),\n        shape.radius[0],\n        shape.radius[1],\n        shape.rotation || 0\n      )\n    )\n  }\n\n  hitTestLineSegment = (shape: T, A: number[], B: number[]): boolean => {\n    return intersectLineSegmentEllipse(\n      A,\n      B,\n      this.getCenter(shape),\n      shape.radius[0],\n      shape.radius[1],\n      shape.rotation || 0\n    ).didIntersect\n  }\n\n  getBounds = (shape: T) => {\n    return Utils.getFromCache(this.boundsCache, shape, () => {\n      return Utils.getRotatedEllipseBounds(\n        shape.point[0],\n        shape.point[1],\n        shape.radius[0],\n        shape.radius[1],\n        0\n      )\n    })\n  }\n\n  getRotatedBounds = (shape: T): TLBounds => {\n    return Utils.getRotatedEllipseBounds(\n      shape.point[0],\n      shape.point[1],\n      shape.radius[0],\n      shape.radius[1],\n      shape.rotation\n    )\n  }\n\n  hitTestBounds = (shape: T, bounds: TLBounds): boolean => {\n    const shapeBounds = this.getBounds(shape)\n\n    return (\n      Utils.boundsContained(shapeBounds, bounds) ||\n      intersectEllipseBounds(\n        this.getCenter(shape),\n        shape.radius[0],\n        shape.radius[1],\n        shape.rotation || 0,\n        bounds\n      ).length > 0\n    )\n  }\n\n  shouldRender = (prev: T, next: T): boolean => {\n    return next.radius !== prev.radius || next.style !== prev.style || next.label !== prev.label\n  }\n\n  getCenter = (shape: T): number[] => {\n    return Vec.add(shape.point, shape.radius)\n  }\n\n  getBindingPoint = <K extends TDShape>(\n    shape: T,\n    fromShape: K,\n    point: number[],\n    origin: number[],\n    direction: number[],\n    bindAnywhere: boolean\n  ) => {\n    {\n      const expandedBounds = this.getExpandedBounds(shape)\n      const center = this.getCenter(shape)\n      let bindingPoint: number[]\n      let distance: number\n      if (\n        !Utils.pointInEllipse(\n          point,\n          center,\n          shape.radius[0] + this.bindingDistance,\n          shape.radius[1] + this.bindingDistance\n        )\n      ) {\n        return\n      }\n      if (bindAnywhere) {\n        if (Vec.dist(point, this.getCenter(shape)) < 12) {\n          bindingPoint = [0.5, 0.5]\n        } else {\n          bindingPoint = Vec.divV(Vec.sub(point, [expandedBounds.minX, expandedBounds.minY]), [\n            expandedBounds.width,\n            expandedBounds.height,\n          ])\n        }\n        distance = 0\n      } else {\n        let intersection = intersectRayEllipse(\n          origin,\n          direction,\n          center,\n          shape.radius[0],\n          shape.radius[1],\n          shape.rotation || 0\n        ).points.sort((a, b) => Vec.dist(a, origin) - Vec.dist(b, origin))[0]\n        if (!intersection) {\n          intersection = intersectLineSegmentEllipse(\n            point,\n            center,\n            center,\n            shape.radius[0],\n            shape.radius[1],\n            shape.rotation || 0\n          ).points.sort((a, b) => Vec.dist(a, point) - Vec.dist(b, point))[0]\n        }\n        if (!intersection) {\n          return undefined\n        }\n        // The anchor is a point between the handle and the intersection\n        const anchor = Vec.med(point, intersection)\n        if (Vec.distanceToLineSegment(point, anchor, this.getCenter(shape)) < 12) {\n          // If we're close to the center, snap to the center\n          bindingPoint = [0.5, 0.5]\n        } else {\n          // Or else calculate a normalized point\n          bindingPoint = Vec.divV(Vec.sub(anchor, [expandedBounds.minX, expandedBounds.minY]), [\n            expandedBounds.width,\n            expandedBounds.height,\n          ])\n        }\n        if (\n          Utils.pointInEllipse(point, center, shape.radius[0], shape.radius[1], shape.rotation || 0)\n        ) {\n          // Pad the arrow out by 16 points\n          distance = this.bindingDistance / 2\n        } else {\n          // Find the distance between the point and the ellipse\n          const innerIntersection = intersectLineSegmentEllipse(\n            point,\n            center,\n            center,\n            shape.radius[0],\n            shape.radius[1],\n            shape.rotation || 0\n          ).points[0]\n          if (!innerIntersection) return undefined\n          distance = Math.max(this.bindingDistance / 2, Vec.dist(point, innerIntersection))\n        }\n      }\n      return {\n        point: bindingPoint,\n        distance,\n      }\n    }\n  }\n\n  transform = (\n    shape: T,\n    bounds: TLBounds,\n    { scaleX, scaleY, initialShape }: TransformInfo<T>\n  ): Partial<T> => {\n    const { rotation = 0 } = initialShape\n    return {\n      point: [bounds.minX, bounds.minY],\n      radius: [bounds.width / 2, bounds.height / 2],\n      rotation:\n        (scaleX < 0 && scaleY >= 0) || (scaleY < 0 && scaleX >= 0)\n          ? -(rotation || 0)\n          : rotation || 0,\n    }\n  }\n\n  transformSingle = (shape: T, bounds: TLBounds): Partial<T> => {\n    return {\n      point: Vec.toFixed([bounds.minX, bounds.minY]),\n      radius: Vec.div([bounds.width, bounds.height], 2),\n    }\n  }\n}\n\nconst FullWrapper = styled('div', { width: '100%', height: '100%' })\n", "import { Utils } from '@tldraw/core'\nimport * as React from 'react'\nimport { getShapeStyle } from '~state/shapes/shared'\nimport type { ShapeStyles } from '~types'\n\ninterface EllipseSvgProps {\n  radius: number[]\n  style: ShapeStyles\n  isSelected: boolean\n  isDarkMode: boolean\n}\n\nexport const DashedEllipse = React.memo(function DashedEllipse({\n  radius,\n  style,\n  isSelected,\n  isDarkMode,\n}: EllipseSvgProps) {\n  const { stroke, strokeWidth, fill } = getShapeStyle(style, isDarkMode)\n  const sw = 1 + strokeWidth * 1.618\n  const rx = Math.max(0, radius[0] - sw / 2)\n  const ry = Math.max(0, radius[1] - sw / 2)\n  const perimeter = Utils.perimeterOfEllipse(rx, ry)\n  const { strokeDasharray, strokeDashoffset } = Utils.getPerfectDashProps(\n    perimeter < 64 ? perimeter * 2 : perimeter,\n    strokeWidth * 1.618,\n    style.dash,\n    4\n  )\n\n  return (\n    <>\n      <ellipse\n        className={style.isFilled || isSelected ? 'tl-fill-hitarea' : 'tl-stroke-hitarea'}\n        cx={radius[0]}\n        cy={radius[1]}\n        rx={radius[0]}\n        ry={radius[1]}\n      />\n      <ellipse\n        cx={radius[0]}\n        cy={radius[1]}\n        rx={rx}\n        ry={ry}\n        fill={fill}\n        stroke={stroke}\n        strokeWidth={sw}\n        strokeDasharray={strokeDasharray}\n        strokeDashoffset={strokeDashoffset}\n        pointerEvents=\"none\"\n        strokeLinecap=\"round\"\n        strokeLinejoin=\"round\"\n      />\n    </>\n  )\n})\n", "import * as React from 'react'\nimport { getShapeStyle } from '~state/shapes/shared'\nimport type { ShapeStyles } from '~types'\nimport { getEllipseIndicatorPath, getEllipsePath } from '../ellipseHelpers'\n\ninterface EllipseSvgProps {\n  id: string\n  radius: number[]\n  style: ShapeStyles\n  isSelected: boolean\n  isDarkMode: boolean\n}\n\nexport const DrawEllipse = React.memo(function DrawEllipse({\n  id,\n  radius,\n  style,\n  isSelected,\n  isDarkMode,\n}: EllipseSvgProps) {\n  const { stroke, strokeWidth, fill } = getShapeStyle(style, isDarkMode)\n  const innerPath = getEllipsePath(id, radius, style)\n\n  return (\n    <>\n      <ellipse\n        className={style.isFilled || isSelected ? 'tl-fill-hitarea' : 'tl-stroke-hitarea'}\n        cx={radius[0]}\n        cy={radius[1]}\n        rx={radius[0]}\n        ry={radius[1]}\n      />\n      {style.isFilled && (\n        <path\n          d={getEllipseIndicatorPath(id, radius, style)}\n          stroke=\"none\"\n          fill={fill}\n          pointerEvents=\"none\"\n        />\n      )}\n      <path\n        d={innerPath}\n        fill={stroke}\n        stroke={stroke}\n        strokeWidth={strokeWidth}\n        pointerEvents=\"none\"\n        strokeLinecap=\"round\"\n        strokeLinejoin=\"round\"\n      />\n    </>\n  )\n})\n", "import { Utils } from '@tldraw/core'\nimport { getStrokeOutlinePoints, getStrokePoints } from 'perfect-freehand'\nimport { EASINGS } from '~constants'\nimport { getShapeStyle } from '~state/shapes/shared'\nimport type { ShapeStyles } from '~types'\n\nexport function getEllipseStrokePoints(id: string, radius: number[], style: ShapeStyles) {\n  const { strokeWidth } = getShapeStyle(style)\n  const getRandom = Utils.rng(id)\n  const rx = radius[0] + getRandom() * strokeWidth * 2\n  const ry = radius[1] + getRandom() * strokeWidth * 2\n  const perimeter = Utils.perimeterOfEllipse(rx, ry)\n  const points: number[][] = []\n  const start = Math.PI + Math.PI * getRandom()\n  const extra = Math.abs(getRandom())\n  const count = Math.max(16, perimeter / 10)\n  for (let i = 0; i < count; i++) {\n    const t = EASINGS.easeInOutSine(i / (count + 1))\n    const rads = start * 2 + Math.PI * (2 + extra) * t\n    const c = Math.cos(rads)\n    const s = Math.sin(rads)\n    points.push([rx * c + radius[0], ry * s + radius[1], t + 0.5 + getRandom() / 2])\n  }\n  return getStrokePoints(points, {\n    size: 1 + strokeWidth * 2,\n    thinning: 0.618,\n    end: { taper: perimeter / 8 },\n    start: { taper: perimeter / 12 },\n    streamline: 0,\n    simulatePressure: true,\n  })\n}\n\nexport function getEllipsePath(id: string, radius: number[], style: ShapeStyles) {\n  const { strokeWidth } = getShapeStyle(style)\n  const getRandom = Utils.rng(id)\n  const rx = radius[0] + getRandom() * strokeWidth * 2\n  const ry = radius[1] + getRandom() * strokeWidth * 2\n  const perimeter = Utils.perimeterOfEllipse(rx, ry)\n  return Utils.getSvgPathFromStroke(\n    getStrokeOutlinePoints(getEllipseStrokePoints(id, radius, style), {\n      size: 2 + strokeWidth * 2,\n      thinning: 0.618,\n      end: { taper: perimeter / 8 },\n      start: { taper: perimeter / 12 },\n      streamline: 0,\n      simulatePressure: true,\n    })\n  )\n}\n\nexport function getEllipseIndicatorPath(id: string, radius: number[], style: ShapeStyles) {\n  return Utils.getSvgPathFromStrokePoints(getEllipseStrokePoints(id, radius, style))\n}\n", "import { SVGContainer, Utils } from '@tldraw/core'\nimport * as React from 'react'\nimport { GHOSTED_OPACITY } from '~constants'\nimport { TDShapeUtil } from '~state/shapes/TDShapeUtil'\nimport { defaultStyle, getBoundsRectangle } from '~state/shapes/shared'\nimport { styled } from '~styles'\nimport { ColorStyle, GroupShape, TDMeta, TDShapeType } from '~types'\n\ntype T = GroupShape\ntype E = SVGSVGElement\n\nexport class GroupUtil extends TDShapeUtil<T, E> {\n  type = TDShapeType.Group as const\n\n  canBind = true\n\n  getShape = (props: Partial<T>): T => {\n    return Utils.deepMerge<T>(\n      {\n        id: 'id',\n        type: TDShapeType.Group,\n        name: 'Group',\n        parentId: 'page',\n        childIndex: 1,\n        point: [0, 0],\n        size: [100, 100],\n        rotation: 0,\n        children: [],\n        style: defaultStyle,\n      },\n      props\n    )\n  }\n\n  Component = TDShapeUtil.Component<T, E, TDMeta>(\n    ({ shape, isBinding, isGhost, isHovered, isSelected, events }, ref) => {\n      const { id, size } = shape\n\n      const sw = 2\n      const w = Math.max(0, size[0] - sw / 2)\n      const h = Math.max(0, size[1] - sw / 2)\n\n      const strokes: [number[], number[], number][] = [\n        [[sw / 2, sw / 2], [w, sw / 2], w - sw / 2],\n        [[w, sw / 2], [w, h], h - sw / 2],\n        [[w, h], [sw / 2, h], w - sw / 2],\n        [[sw / 2, h], [sw / 2, sw / 2], h - sw / 2],\n      ]\n\n      const paths = strokes.map(([start, end], i) => {\n        return <line key={id + '_' + i} x1={start[0]} y1={start[1]} x2={end[0]} y2={end[1]} />\n      })\n\n      return (\n        <SVGContainer ref={ref} {...events}>\n          {isBinding && (\n            <rect className=\"tl-binding-indicator\" strokeWidth={this.bindingDistance} />\n          )}\n          <g opacity={isGhost ? GHOSTED_OPACITY : 1}>\n            <rect\n              x={0}\n              y={0}\n              width={size[0]}\n              height={size[1]}\n              fill=\"transparent\"\n              pointerEvents=\"all\"\n            />\n            <ScaledLines\n              stroke={ColorStyle.Black}\n              opacity={isHovered || isSelected ? 1 : 0}\n              strokeLinecap=\"round\"\n              pointerEvents=\"stroke\"\n            >\n              {paths}\n            </ScaledLines>\n          </g>\n        </SVGContainer>\n      )\n    }\n  )\n\n  Indicator = TDShapeUtil.Indicator<T>(({ shape }) => {\n    const { id, size } = shape\n\n    const sw = 2\n    const w = Math.max(0, size[0] - sw / 2)\n    const h = Math.max(0, size[1] - sw / 2)\n\n    const strokes: [number[], number[], number][] = [\n      [[sw / 2, sw / 2], [w, sw / 2], w - sw / 2],\n      [[w, sw / 2], [w, h], h - sw / 2],\n      [[w, h], [sw / 2, h], w - sw / 2],\n      [[sw / 2, h], [sw / 2, sw / 2], h - sw / 2],\n    ]\n\n    const paths = strokes.map(([start, end], i) => {\n      return <line key={id + '_' + i} x1={start[0]} y1={start[1]} x2={end[0]} y2={end[1]} />\n    })\n\n    return (\n      <ScaledLines strokeLinecap=\"round\" pointerEvents=\"stroke\">\n        {paths}\n      </ScaledLines>\n    )\n  })\n\n  getBounds = (shape: T) => {\n    return getBoundsRectangle(shape, this.boundsCache)\n  }\n\n  shouldRender = (prev: T, next: T) => {\n    return next.size !== prev.size || next.style !== prev.style\n  }\n}\n\nconst ScaledLines = styled('g', {\n  strokeWidth: 'calc(1.5px * var(--tl-scale))',\n  strokeDasharray: `calc(1px * var(--tl-scale)), calc(3px * var(--tl-scale))`,\n})\n", "import { styled } from '@stitches/react'\nimport { HTMLContainer, Utils } from '@tldraw/core'\nimport * as React from 'react'\nimport { GHOSTED_OPACITY } from '~constants'\nimport { TDShapeUtil } from '~state/shapes/TDShapeUtil'\nimport {\n  defaultStyle,\n  getBoundsRectangle,\n  transformRectangle,\n  transformSingleRectangle,\n} from '~state/shapes/shared'\nimport { ImageShape, TDImageAsset, TDMeta, TDShapeType } from '~types'\n\ntype T = ImageShape\ntype E = HTMLDivElement\n\nexport class ImageUtil extends TDShapeUtil<T, E> {\n  type = TDShapeType.Image as const\n\n  canBind = true\n\n  canClone = true\n\n  isAspectRatioLocked = true\n\n  showCloneHandles = false\n\n  getShape = (props: Partial<T>): T => {\n    return Utils.deepMerge<T>(\n      {\n        id: 'image',\n        type: TDShapeType.Image,\n        name: 'Image',\n        parentId: 'page',\n        childIndex: 1,\n        point: [0, 0],\n        size: [1, 1],\n        rotation: 0,\n        style: { ...defaultStyle, isFilled: true },\n        assetId: 'assetId',\n      },\n      props\n    )\n  }\n\n  Component = TDShapeUtil.Component<T, E, TDMeta>(\n    ({ shape, asset = { src: '' }, isBinding, isGhost, meta, events, onShapeChange }, ref) => {\n      const { size, style } = shape\n      const { bindingDistance } = this\n\n      const rImage = React.useRef<HTMLImageElement>(null)\n      const rWrapper = React.useRef<HTMLDivElement>(null)\n\n      React.useLayoutEffect(() => {\n        const wrapper = rWrapper.current\n        if (!wrapper) return\n        const [width, height] = size\n        wrapper.style.width = `${width}px`\n        wrapper.style.height = `${height}px`\n      }, [size])\n\n      return (\n        <HTMLContainer ref={ref} {...events}>\n          {isBinding && (\n            <div\n              className=\"tl-binding-indicator\"\n              style={{\n                position: 'absolute',\n                top: `calc(${-bindingDistance}px * var(--tl-zoom))`,\n                left: `calc(${-bindingDistance}px * var(--tl-zoom))`,\n                width: `calc(100% + ${bindingDistance * 2}px * var(--tl-zoom))`,\n                height: `calc(100% + ${bindingDistance * 2}px * var(--tl-zoom))`,\n                backgroundColor: 'var(--tl-selectFill)',\n              }}\n            />\n          )}\n          <Wrapper\n            ref={rWrapper}\n            isDarkMode={meta.isDarkMode} //\n            isFilled={style.isFilled}\n            isGhost={isGhost}\n          >\n            <ImageElement\n              id={shape.id + '_image'}\n              ref={rImage}\n              src={(asset as TDImageAsset).src}\n              alt=\"tl_image_asset\"\n              draggable={false}\n            />\n          </Wrapper>\n        </HTMLContainer>\n      )\n    }\n  )\n\n  Indicator = TDShapeUtil.Indicator<T>(({ shape }) => {\n    const {\n      size: [width, height],\n    } = shape\n\n    return (\n      <rect x={0} y={0} rx={2} ry={2} width={Math.max(1, width)} height={Math.max(1, height)} />\n    )\n  })\n\n  getBounds = (shape: T) => {\n    return getBoundsRectangle(shape, this.boundsCache)\n  }\n\n  shouldRender = (prev: T, next: T) => {\n    return next.size !== prev.size || next.style !== prev.style\n  }\n\n  transform = transformRectangle\n\n  transformSingle = transformSingleRectangle\n\n  getSvgElement = (shape: ImageShape) => {\n    const bounds = this.getBounds(shape)\n    const elm = document.createElementNS('http://www.w3.org/2000/svg', 'image')\n    elm.setAttribute('width', `${bounds.width}`)\n    elm.setAttribute('height', `${bounds.height}`)\n    elm.setAttribute('xmlns:xlink', `http://www.w3.org/1999/xlink`)\n    return elm\n  }\n}\n\nconst Wrapper = styled('div', {\n  pointerEvents: 'all',\n  position: 'relative',\n  fontFamily: 'sans-serif',\n  fontSize: '2em',\n  height: '100%',\n  width: '100%',\n  borderRadius: '3px',\n  perspective: '800px',\n  overflow: 'hidden',\n  p: {\n    userSelect: 'none',\n  },\n  img: {\n    userSelect: 'none',\n  },\n  variants: {\n    isGhost: {\n      false: { opacity: 1 },\n      true: { transition: 'opacity .2s', opacity: GHOSTED_OPACITY },\n    },\n    isFilled: {\n      true: {},\n      false: {},\n    },\n    isDarkMode: {\n      true: {},\n      false: {},\n    },\n  },\n  compoundVariants: [\n    {\n      isFilled: true,\n      isDarkMode: true,\n      css: {\n        boxShadow:\n          '2px 3px 12px -2px rgba(0,0,0,.3), 1px 1px 4px rgba(0,0,0,.3), 1px 1px 2px rgba(0,0,0,.3)',\n      },\n    },\n    {\n      isFilled: true,\n      isDarkMode: false,\n      css: {\n        boxShadow:\n          '2px 3px 12px -2px rgba(0,0,0,.2), 1px 1px 4px rgba(0,0,0,.16),  1px 1px 2px rgba(0,0,0,.16)',\n      },\n    },\n  ],\n})\n\nconst ImageElement = styled('img', {\n  position: 'absolute',\n  top: 0,\n  left: 0,\n  width: '100%',\n  height: '100%',\n  maxWidth: '100%',\n  minWidth: '100%',\n  pointerEvents: 'none',\n  objectFit: 'cover',\n  userSelect: 'none',\n  borderRadius: 2,\n})\n", "import { SVGContainer, Utils } from '@tldraw/core'\nimport * as React from 'react'\nimport { GHOSTED_OPACITY, LABEL_POINT } from '~constants'\nimport { TDShapeUtil } from '~state/shapes/TDShapeUtil'\nimport {\n  TextLabel,\n  defaultStyle,\n  getBoundsRectangle,\n  getFontStyle,\n  getShapeStyle,\n  transformRectangle,\n  transformSingleRectangle,\n} from '~state/shapes/shared'\nimport { styled } from '~styles'\nimport { DashStyle, RectangleShape, TDMeta, TDShapeType } from '~types'\nimport { BindingIndicator } from './components/BindingIndicator'\nimport { DashedRectangle } from './components/DashedRectangle'\nimport { DrawRectangle } from './components/DrawRectangle'\nimport { getRectangleIndicatorPathTDSnapshot } from './rectangleHelpers'\n\ntype T = RectangleShape\ntype E = HTMLDivElement\n\nexport class RectangleUtil extends TDShapeUtil<T, E> {\n  type = TDShapeType.Rectangle as const\n\n  canBind = true\n\n  canClone = true\n\n  canEdit = true\n\n  getShape = (props: Partial<T>): T => {\n    return Utils.deepMerge<T>(\n      {\n        id: 'id',\n        type: TDShapeType.Rectangle,\n        name: 'Rectangle',\n        parentId: 'page',\n        childIndex: 1,\n        point: [0, 0],\n        size: [1, 1],\n        rotation: 0,\n        style: defaultStyle,\n        label: '',\n        labelPoint: [0.5, 0.5],\n      },\n      props\n    )\n  }\n\n  Component = TDShapeUtil.Component<T, E, TDMeta>(\n    (\n      {\n        shape,\n        isEditing,\n        isBinding,\n        isSelected,\n        isGhost,\n        meta,\n        bounds,\n        events,\n        onShapeBlur,\n        onShapeChange,\n      },\n      ref\n    ) => {\n      const { id, size, style, label = '', labelPoint = LABEL_POINT } = shape\n      const font = getFontStyle(style)\n      const styles = getShapeStyle(style, meta.isDarkMode)\n      const Component = style.dash === DashStyle.Draw ? DrawRectangle : DashedRectangle\n      const handleLabelChange = React.useCallback(\n        (label: string) => onShapeChange?.({ id, label }),\n        [onShapeChange]\n      )\n      return (\n        <FullWrapper ref={ref} {...events}>\n          <TextLabel\n            isEditing={isEditing}\n            onChange={handleLabelChange}\n            onBlur={onShapeBlur}\n            font={font}\n            text={label}\n            color={styles.stroke}\n            offsetX={(labelPoint[0] - 0.5) * bounds.width}\n            offsetY={(labelPoint[1] - 0.5) * bounds.height}\n          />\n          <SVGContainer id={shape.id + '_svg'} opacity={isGhost ? GHOSTED_OPACITY : 1}>\n            {isBinding && <BindingIndicator strokeWidth={styles.strokeWidth} size={size} />}\n            <Component\n              id={id}\n              style={style}\n              size={size}\n              isSelected={isSelected}\n              isDarkMode={meta.isDarkMode}\n            />\n          </SVGContainer>\n        </FullWrapper>\n      )\n    }\n  )\n\n  Indicator = TDShapeUtil.Indicator<T>(({ shape }) => {\n    const { id, style, size } = shape\n\n    const styles = getShapeStyle(style, false)\n    const sw = styles.strokeWidth\n\n    if (style.dash === DashStyle.Draw) {\n      return <path d={getRectangleIndicatorPathTDSnapshot(id, style, size)} />\n    }\n\n    return (\n      <rect\n        x={sw}\n        y={sw}\n        rx={1}\n        ry={1}\n        width={Math.max(1, size[0] - sw * 2)}\n        height={Math.max(1, size[1] - sw * 2)}\n      />\n    )\n  })\n\n  getBounds = (shape: T) => {\n    return getBoundsRectangle(shape, this.boundsCache)\n  }\n\n  shouldRender = (prev: T, next: T) => {\n    return next.size !== prev.size || next.style !== prev.style || next.label !== prev.label\n  }\n\n  transform = transformRectangle\n\n  transformSingle = transformSingleRectangle\n}\n\nconst FullWrapper = styled('div', { width: '100%', height: '100%' })\n", "import * as React from 'react'\nimport { BINDING_DISTANCE } from '~constants'\n\ninterface BindingIndicatorProps {\n  strokeWidth: number\n  size: number[]\n}\nexport function BindingIndicator({ strokeWidth, size }: BindingIndicatorProps) {\n  return (\n    <rect\n      className=\"tl-binding-indicator\"\n      x={strokeWidth}\n      y={strokeWidth}\n      width={Math.max(0, size[0] - strokeWidth / 2)}\n      height={Math.max(0, size[1] - strokeWidth / 2)}\n      strokeWidth={BINDING_DISTANCE * 2}\n    />\n  )\n}\n", "import { Utils } from '@tldraw/core'\nimport * as React from 'react'\nimport { BINDING_DISTANCE } from '~constants'\nimport { getShapeStyle } from '~state/shapes/shared'\nimport type { ShapeStyles } from '~types'\n\ninterface RectangleSvgProps {\n  id: string\n  style: ShapeStyles\n  isSelected: boolean\n  size: number[]\n  isDarkMode: boolean\n}\n\nexport const DashedRectangle = React.memo(function DashedRectangle({\n  id,\n  style,\n  size,\n  isSelected,\n  isDarkMode,\n}: RectangleSvgProps) {\n  const { stroke, strokeWidth, fill } = getShapeStyle(style, isDarkMode)\n\n  const sw = 1 + strokeWidth * 1.618\n\n  const w = Math.max(0, size[0] - sw / 2)\n  const h = Math.max(0, size[1] - sw / 2)\n\n  const strokes: [number[], number[], number][] = [\n    [[sw / 2, sw / 2], [w, sw / 2], w - sw / 2],\n    [[w, sw / 2], [w, h], h - sw / 2],\n    [[w, h], [sw / 2, h], w - sw / 2],\n    [[sw / 2, h], [sw / 2, sw / 2], h - sw / 2],\n  ]\n\n  const paths = strokes.map(([start, end, length], i) => {\n    const { strokeDasharray, strokeDashoffset } = Utils.getPerfectDashProps(\n      length,\n      strokeWidth * 1.618,\n      style.dash\n    )\n\n    return (\n      <line\n        key={id + '_' + i}\n        x1={start[0]}\n        y1={start[1]}\n        x2={end[0]}\n        y2={end[1]}\n        strokeDasharray={strokeDasharray}\n        strokeDashoffset={strokeDashoffset}\n      />\n    )\n  })\n\n  return (\n    <>\n      <rect\n        className={isSelected || style.isFilled ? 'tl-fill-hitarea' : 'tl-stroke-hitarea'}\n        x={sw / 2}\n        y={sw / 2}\n        width={w}\n        height={h}\n        strokeWidth={BINDING_DISTANCE}\n      />\n      {style.isFilled && (\n        <rect x={sw / 2} y={sw / 2} width={w} height={h} fill={fill} pointerEvents=\"none\" />\n      )}\n      <g pointerEvents=\"none\" stroke={stroke} strokeWidth={sw} strokeLinecap=\"round\">\n        {paths}\n      </g>\n    </>\n  )\n})\n", "import * as React from 'react'\nimport { getShapeStyle } from '~state/shapes/shared'\nimport type { ShapeStyles } from '~types'\nimport { getRectangleIndicatorPathTDSnapshot, getRectanglePath } from '../rectangleHelpers'\n\ninterface RectangleSvgProps {\n  id: string\n  style: ShapeStyles\n  isSelected: boolean\n  isDarkMode: boolean\n  size: number[]\n}\n\nexport const DrawRectangle = React.memo(function DrawRectangle({\n  id,\n  style,\n  size,\n  isSelected,\n  isDarkMode,\n}: RectangleSvgProps) {\n  const { isFilled } = style\n  const { stroke, strokeWidth, fill } = getShapeStyle(style, isDarkMode)\n  const pathTDSnapshot = getRectanglePath(id, style, size)\n  const innerPath = getRectangleIndicatorPathTDSnapshot(id, style, size)\n\n  return (\n    <>\n      <path\n        className={style.isFilled || isSelected ? 'tl-fill-hitarea' : 'tl-stroke-hitarea'}\n        d={innerPath}\n      />\n      {isFilled && <path d={innerPath} fill={fill} pointerEvents=\"none\" />}\n      <path\n        d={pathTDSnapshot}\n        fill={stroke}\n        stroke={stroke}\n        strokeWidth={strokeWidth}\n        pointerEvents=\"none\"\n      />\n    </>\n  )\n})\n", "import { Utils } from '@tldraw/core'\nimport Vec from '@tldraw/vec'\nimport getStroke, { getStrokePoints } from 'perfect-freehand'\nimport { getShapeStyle } from '~state/shapes/shared'\nimport type { ShapeStyles } from '~types'\n\nfunction getRectangleDrawPoints(id: string, style: ShapeStyles, size: number[]) {\n  const styles = getShapeStyle(style)\n\n  const getRandom = Utils.rng(id)\n\n  const sw = styles.strokeWidth\n\n  // Dimensions\n  const w = Math.max(0, size[0])\n  const h = Math.max(0, size[1])\n\n  // Random corner offsets\n  const offsets = Array.from(Array(4)).map(() => {\n    return [getRandom() * sw * 0.75, getRandom() * sw * 0.75]\n  })\n\n  // Corners\n  const tl = Vec.add([sw / 2, sw / 2], offsets[0])\n  const tr = Vec.add([w - sw / 2, sw / 2], offsets[1])\n  const br = Vec.add([w - sw / 2, h - sw / 2], offsets[2])\n  const bl = Vec.add([sw / 2, h - sw / 2], offsets[3])\n\n  // Which side to start drawing first\n  const rm = Math.round(Math.abs(getRandom() * 2 * 4))\n\n  // Corner radii\n  const rx = Math.min(w / 4, sw * 2)\n  const ry = Math.min(h / 4, sw * 2)\n\n  // Number of points per side\n  const px = Math.max(8, Math.floor(w / 16))\n  const py = Math.max(8, Math.floor(h / 16))\n\n  // Inset each line by the corner radii and let the freehand algo\n  // interpolate points for the corners.\n  const lines = Utils.rotateArray(\n    [\n      Vec.pointsBetween(Vec.add(tl, [rx, 0]), Vec.sub(tr, [rx, 0]), px),\n      Vec.pointsBetween(Vec.add(tr, [0, ry]), Vec.sub(br, [0, ry]), py),\n      Vec.pointsBetween(Vec.sub(br, [rx, 0]), Vec.add(bl, [rx, 0]), px),\n      Vec.pointsBetween(Vec.sub(bl, [0, ry]), Vec.add(tl, [0, ry]), py),\n    ],\n    rm\n  )\n\n  // For the final points, include the first half of the first line again,\n  // so that the line wraps around and avoids ending on a sharp corner.\n  // This has a bit of finesse and magic\u2014if you change the points between\n  // function, then you'll likely need to change this one too.\n\n  const points = [...lines.flat(), ...lines[0]].slice(\n    5,\n    Math.floor((rm % 2 === 0 ? px : py) / -2) + 3\n  )\n\n  return {\n    points,\n  }\n}\n\nfunction getDrawStrokeInfo(id: string, style: ShapeStyles, size: number[]) {\n  const { points } = getRectangleDrawPoints(id, style, size)\n  const { strokeWidth } = getShapeStyle(style)\n  const options = {\n    size: strokeWidth,\n    thinning: 0.65,\n    streamline: 0.3,\n    smoothing: 1,\n    simulatePressure: false,\n    last: true,\n  }\n  return { points, options }\n}\n\nexport function getRectanglePath(id: string, style: ShapeStyles, size: number[]) {\n  const { points, options } = getDrawStrokeInfo(id, style, size)\n  const stroke = getStroke(points, options)\n  return Utils.getSvgPathFromStroke(stroke)\n}\n\nexport function getRectangleIndicatorPathTDSnapshot(\n  id: string,\n  style: ShapeStyles,\n  size: number[]\n) {\n  const { points, options } = getDrawStrokeInfo(id, style, size)\n  return Utils.getSvgPathFromStrokePoints(getStrokePoints(points, options))\n}\n", "import { HTMLContainer, TLBounds, Utils } from '@tldraw/core'\nimport { Vec } from '@tldraw/vec'\nimport * as React from 'react'\nimport { stopPropagation } from '~components/stopPropagation'\nimport { GHOSTED_OPACITY, LETTER_SPACING } from '~constants'\nimport { TLDR } from '~state/TLDR'\nimport { TDShapeUtil } from '~state/shapes/TDShapeUtil'\nimport {\n  TextAreaUtils,\n  defaultTextStyle,\n  getBoundsRectangle,\n  getFontFace,\n  getStickyFontSize,\n  getStickyFontStyle,\n  getStickyShapeStyle,\n  getTextSvgElement,\n} from '~state/shapes/shared'\nimport { styled } from '~styles'\nimport { AlignStyle, StickyShape, TDMeta, TDShapeType, TransformInfo } from '~types'\n\ntype T = StickyShape\ntype E = HTMLDivElement\n\nexport class StickyUtil extends TDShapeUtil<T, E> {\n  type = TDShapeType.Sticky as const\n\n  canBind = true\n\n  canEdit = true\n\n  canClone = true\n\n  hideResizeHandles = true\n\n  showCloneHandles = true\n\n  getShape = (props: Partial<T>): T => {\n    return Utils.deepMerge<T>(\n      {\n        id: 'id',\n        type: TDShapeType.Sticky,\n        name: 'Sticky',\n        parentId: 'page',\n        childIndex: 1,\n        point: [0, 0],\n        size: [200, 200],\n        text: '',\n        rotation: 0,\n        style: defaultTextStyle,\n      },\n      props\n    )\n  }\n\n  Component = TDShapeUtil.Component<T, E, TDMeta>(\n    ({ shape, meta, events, isGhost, isBinding, isEditing, onShapeBlur, onShapeChange }, ref) => {\n      const font = getStickyFontStyle(shape.style)\n\n      const { color, fill } = getStickyShapeStyle(shape.style, meta.isDarkMode)\n\n      const rContainer = React.useRef<HTMLDivElement>(null)\n\n      const rTextArea = React.useRef<HTMLTextAreaElement>(null)\n\n      const rText = React.useRef<HTMLDivElement>(null)\n\n      const rIsMounted = React.useRef(false)\n\n      const handlePointerDown = React.useCallback((e: React.PointerEvent) => {\n        e.stopPropagation()\n      }, [])\n\n      const onChange = React.useCallback(\n        (text: string) => {\n          onShapeChange?.({\n            id: shape.id,\n            type: shape.type,\n            text: TLDR.normalizeText(text),\n          })\n        },\n        [shape.id]\n      )\n\n      const handleTextChange = React.useCallback(\n        (e: React.ChangeEvent<HTMLTextAreaElement>) => {\n          onChange(e.currentTarget.value)\n        },\n        [onShapeChange, onChange]\n      )\n\n      const handleKeyDown = React.useCallback(\n        (e: React.KeyboardEvent<HTMLTextAreaElement>) => {\n          if (e.key === 'Escape') {\n            e.preventDefault()\n            e.stopPropagation()\n            onShapeBlur?.()\n            return\n          }\n\n          if (e.key === 'Tab' && shape.text.length === 0) {\n            e.preventDefault()\n            return\n          }\n\n          if (!(e.key === 'Meta' || e.metaKey)) {\n            e.stopPropagation()\n          } else if (e.key === 'z' && e.metaKey) {\n            if (e.shiftKey) {\n              document.execCommand('redo', false)\n            } else {\n              document.execCommand('undo', false)\n            }\n            e.stopPropagation()\n            e.preventDefault()\n            return\n          }\n          if ((e.metaKey || e.ctrlKey) && e.key === '=') {\n            e.preventDefault()\n          }\n          if (e.key === 'Tab') {\n            e.preventDefault()\n            if (e.shiftKey) {\n              TextAreaUtils.unindent(e.currentTarget)\n            } else {\n              TextAreaUtils.indent(e.currentTarget)\n            }\n\n            onShapeChange?.({ ...shape, text: TLDR.normalizeText(e.currentTarget.value) })\n          }\n        },\n        [shape, onShapeChange]\n      )\n\n      const handleBlur = React.useCallback((e: React.FocusEvent<HTMLTextAreaElement>) => {\n        e.currentTarget.setSelectionRange(0, 0)\n        onShapeBlur?.()\n      }, [])\n\n      const handleFocus = React.useCallback(\n        (e: React.FocusEvent<HTMLTextAreaElement>) => {\n          if (!isEditing) return\n          if (!rIsMounted.current) return\n          e.currentTarget.select()\n        },\n        [isEditing]\n      )\n\n      // Focus when editing changes to true\n      React.useEffect(() => {\n        if (isEditing) {\n          rIsMounted.current = true\n          const elm = rTextArea.current!\n          elm.focus()\n          elm.select()\n        }\n      }, [isEditing])\n\n      // Resize to fit text\n      React.useEffect(() => {\n        const text = rText.current!\n\n        const { size } = shape\n        const { offsetHeight: currTextHeight } = text\n        const minTextHeight = MIN_CONTAINER_HEIGHT - PADDING * 2\n        const prevTextHeight = size[1] - PADDING * 2\n\n        // Same size? We can quit here\n        if (currTextHeight === prevTextHeight) return\n\n        if (currTextHeight > minTextHeight) {\n          // Snap the size to the text content if the text only when the\n          // text is larger than the minimum text height.\n          onShapeChange?.({ id: shape.id, size: [size[0], currTextHeight + PADDING * 2] })\n          return\n        }\n\n        if (currTextHeight < minTextHeight && size[1] > MIN_CONTAINER_HEIGHT) {\n          // If we're smaller than the minimum height and the container\n          // is too tall, snap it down to the minimum container height\n          onShapeChange?.({ id: shape.id, size: [size[0], MIN_CONTAINER_HEIGHT] })\n          return\n        }\n\n        const textarea = rTextArea.current\n        textarea?.focus()\n      }, [shape.text, shape.size[1], shape.style])\n\n      const style = {\n        font,\n        color,\n        textShadow: meta.isDarkMode\n          ? `0.5px 0.5px 2px rgba(255, 255, 255,.25)`\n          : `0.5px 0.5px 2px rgba(255, 255, 255,.5)`,\n      }\n\n      return (\n        <HTMLContainer ref={ref} {...events}>\n          <StyledStickyContainer\n            ref={rContainer}\n            isDarkMode={meta.isDarkMode}\n            isGhost={isGhost}\n            style={{ backgroundColor: fill, ...style }}\n          >\n            {isBinding && (\n              <div\n                className=\"tl-binding-indicator\"\n                style={{\n                  position: 'absolute',\n                  top: -this.bindingDistance,\n                  left: -this.bindingDistance,\n                  width: `calc(100% + ${this.bindingDistance * 2}px)`,\n                  height: `calc(100% + ${this.bindingDistance * 2}px)`,\n                  backgroundColor: 'var(--tl-selectFill)',\n                }}\n              />\n            )}\n            <StyledText ref={rText} isEditing={isEditing} alignment={shape.style.textAlign}>\n              {shape.text}&#8203;\n            </StyledText>\n            {isEditing && (\n              <StyledTextArea\n                ref={rTextArea}\n                onPointerDown={handlePointerDown}\n                value={shape.text}\n                onChange={handleTextChange}\n                onKeyDown={handleKeyDown}\n                onFocus={handleFocus}\n                onBlur={handleBlur}\n                tabIndex={-1}\n                autoComplete=\"false\"\n                autoCapitalize=\"false\"\n                autoCorrect=\"false\"\n                autoSave=\"false\"\n                autoFocus\n                spellCheck={true}\n                alignment={shape.style.textAlign}\n                onContextMenu={stopPropagation}\n                onCopy={stopPropagation}\n                onPaste={stopPropagation}\n                onCut={stopPropagation}\n              />\n            )}\n          </StyledStickyContainer>\n        </HTMLContainer>\n      )\n    }\n  )\n\n  Indicator = TDShapeUtil.Indicator<T>(({ shape }) => {\n    const {\n      size: [width, height],\n    } = shape\n\n    return (\n      <rect x={0} y={0} rx={3} ry={3} width={Math.max(1, width)} height={Math.max(1, height)} />\n    )\n  })\n\n  getBounds = (shape: T) => {\n    return getBoundsRectangle(shape, this.boundsCache)\n  }\n\n  shouldRender = (prev: T, next: T) => {\n    return next.size !== prev.size || next.style !== prev.style || next.text !== prev.text\n  }\n\n  transform = (\n    shape: T,\n    bounds: TLBounds,\n    { scaleX, scaleY, transformOrigin }: TransformInfo<T>\n  ): Partial<T> => {\n    const point = Vec.toFixed([\n      bounds.minX +\n        (bounds.width - shape.size[0]) * (scaleX < 0 ? 1 - transformOrigin[0] : transformOrigin[0]),\n      bounds.minY +\n        (bounds.height - shape.size[1]) *\n          (scaleY < 0 ? 1 - transformOrigin[1] : transformOrigin[1]),\n    ])\n\n    return {\n      point,\n    }\n  }\n\n  transformSingle = (shape: T): Partial<T> => {\n    return shape\n  }\n\n  getSvgElement = (shape: T, isDarkMode: boolean): SVGElement | void => {\n    const bounds = this.getBounds(shape)\n\n    const style = getStickyShapeStyle(shape.style, isDarkMode)\n\n    const fontSize = getStickyFontSize(shape.style.size) * (shape.style.scale ?? 1)\n    const fontFamily = getFontFace(shape.style.font).slice(1, -1)\n    const textAlign = shape.style.textAlign ?? AlignStyle.Start\n\n    const textElm = getTextSvgElement(\n      shape.text,\n      fontSize,\n      fontFamily,\n      textAlign,\n      bounds.width - PADDING * 2,\n      true\n    )\n\n    textElm.setAttribute('fill', style.color)\n    textElm.setAttribute('transform', `translate(${PADDING}, ${PADDING})`)\n\n    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g')\n    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect')\n    rect.setAttribute('width', bounds.width + '')\n    rect.setAttribute('height', bounds.height + '')\n    rect.setAttribute('fill', style.fill)\n    rect.setAttribute('rx', '3')\n    rect.setAttribute('ry', '3')\n\n    g.appendChild(rect)\n    g.appendChild(textElm)\n\n    return g\n  }\n}\n\n/* -------------------------------------------------- */\n/*                       Helpers                      */\n/* -------------------------------------------------- */\n\nconst PADDING = 16\nconst MIN_CONTAINER_HEIGHT = 200\n\nconst StyledStickyContainer = styled('div', {\n  pointerEvents: 'all',\n  position: 'relative',\n  backgroundColor: 'rgba(255, 220, 100)',\n  fontFamily: 'sans-serif',\n  height: '100%',\n  width: '100%',\n  padding: PADDING + 'px',\n  borderRadius: '3px',\n  perspective: '800px',\n  variants: {\n    isGhost: {\n      false: { opacity: 1 },\n      true: { transition: 'opacity .2s', opacity: GHOSTED_OPACITY },\n    },\n    isDarkMode: {\n      true: {\n        boxShadow:\n          '2px 3px 12px -2px rgba(0,0,0,.3), 1px 1px 4px rgba(0,0,0,.3), 1px 1px 2px rgba(0,0,0,.3)',\n      },\n      false: {\n        boxShadow:\n          '2px 3px 12px -2px rgba(0,0,0,.2), 1px 1px 4px rgba(0,0,0,.16),  1px 1px 2px rgba(0,0,0,.16)',\n      },\n    },\n  },\n})\n\nconst commonTextWrapping = {\n  whiteSpace: 'pre-wrap',\n  overflowWrap: 'break-word',\n  letterSpacing: LETTER_SPACING,\n}\n\nconst StyledText = styled('div', {\n  position: 'absolute',\n  top: PADDING,\n  left: PADDING,\n  width: `calc(100% - ${PADDING * 2}px)`,\n  height: 'fit-content',\n  font: 'inherit',\n  pointerEvents: 'none',\n  userSelect: 'none',\n  variants: {\n    isEditing: {\n      true: {\n        opacity: 1,\n      },\n      false: {\n        opacity: 1,\n      },\n    },\n    alignment: {\n      [AlignStyle.Start]: {\n        textAlign: 'left',\n      },\n      [AlignStyle.Middle]: {\n        textAlign: 'center',\n      },\n      [AlignStyle.End]: {\n        textAlign: 'right',\n      },\n      [AlignStyle.Justify]: {\n        textAlign: 'justify',\n      },\n    },\n  },\n  ...commonTextWrapping,\n})\n\nconst StyledTextArea = styled('textarea', {\n  width: '100%',\n  height: '100%',\n  border: 'none',\n  overflow: 'hidden',\n  background: 'none',\n  outline: 'none',\n  textAlign: 'left',\n  font: 'inherit',\n  padding: 0,\n  color: 'transparent',\n  verticalAlign: 'top',\n  resize: 'none',\n  caretColor: 'black',\n  ...commonTextWrapping,\n  variants: {\n    alignment: {\n      [AlignStyle.Start]: {\n        textAlign: 'left',\n      },\n      [AlignStyle.Middle]: {\n        textAlign: 'center',\n      },\n      [AlignStyle.End]: {\n        textAlign: 'right',\n      },\n      [AlignStyle.Justify]: {\n        textAlign: 'justify',\n      },\n    },\n  },\n  '&:focus': {\n    outline: 'none',\n    border: 'none',\n  },\n})\n", "import { HTMLContainer, TLBounds, Utils } from '@tldraw/core'\nimport { Vec } from '@tldraw/vec'\nimport * as React from 'react'\nimport { stopPropagation } from '~components/stopPropagation'\nimport { BINDING_DISTANCE, GHOSTED_OPACITY, LETTER_SPACING } from '~constants'\nimport { TLDR } from '~state/TLDR'\nimport { TDShapeUtil } from '~state/shapes/TDShapeUtil'\nimport {\n  TextAreaUtils,\n  defaultTextStyle,\n  getFontFace,\n  getFontSize,\n  getFontStyle,\n  getShapeStyle,\n  getTextAlign,\n  getTextSvgElement,\n} from '~state/shapes/shared'\nimport { styled } from '~styles'\nimport { AlignStyle, TDMeta, TDShapeType, TextShape, TransformInfo } from '~types'\n\ntype T = TextShape\ntype E = HTMLDivElement\n\nexport class TextUtil extends TDShapeUtil<T, E> {\n  type = TDShapeType.Text as const\n\n  isAspectRatioLocked = true\n\n  canEdit = true\n\n  canBind = true\n\n  canClone = true\n\n  bindingDistance = BINDING_DISTANCE / 2\n\n  getShape = (props: Partial<T>): T => {\n    return Utils.deepMerge<T>(\n      {\n        id: 'id',\n        type: TDShapeType.Text,\n        name: 'Text',\n        parentId: 'page',\n        childIndex: 1,\n        point: [0, 0],\n        rotation: 0,\n        text: ' ',\n        style: defaultTextStyle,\n      },\n      props\n    )\n  }\n\n  texts = new Map<string, string>()\n\n  Component = TDShapeUtil.Component<T, E, TDMeta>(\n    ({ shape, isBinding, isGhost, isEditing, onShapeBlur, onShapeChange, meta, events }, ref) => {\n      const { text, style } = shape\n      const styles = getShapeStyle(style, meta.isDarkMode)\n      const font = getFontStyle(shape.style)\n      const rInput = React.useRef<HTMLTextAreaElement>(null)\n      const rIsMounted = React.useRef(false)\n\n      const rEditedText = React.useRef(text)\n\n      React.useLayoutEffect(() => {\n        if (text !== rEditedText.current) {\n          let delta = [0, 0]\n          this.texts.set(shape.id, text)\n          const currentBounds = this.getBounds(shape)\n          const nextBounds = this.getBounds(shape)\n          switch (shape.style.textAlign) {\n            case AlignStyle.Start: {\n              break\n            }\n            case AlignStyle.Middle: {\n              delta = Vec.div([nextBounds.width - currentBounds.width, 0], 2)\n              break\n            }\n            case AlignStyle.End: {\n              delta = [nextBounds.width - currentBounds.width, 0]\n              break\n            }\n          }\n\n          rEditedText.current = text\n\n          onShapeChange?.({\n            ...shape,\n            id: shape.id,\n            point: Vec.sub(shape.point, delta),\n            text,\n          })\n        }\n      }, [text])\n\n      const handleChange = React.useCallback(\n        (e: React.ChangeEvent<HTMLTextAreaElement>) => {\n          let delta = [0, 0]\n          const newText = TLDR.normalizeText(e.currentTarget.value)\n          const currentBounds = this.getBounds(shape)\n          this.texts.set(shape.id, newText)\n          const nextBounds = this.getBounds({\n            ...shape,\n            text: newText,\n          })\n\n          switch (shape.style.textAlign) {\n            case AlignStyle.Start: {\n              break\n            }\n            case AlignStyle.Middle: {\n              delta = Vec.div([nextBounds.width - currentBounds.width, 0], 2)\n              break\n            }\n            case AlignStyle.End: {\n              delta = [nextBounds.width - currentBounds.width, 0]\n              break\n            }\n          }\n\n          rEditedText.current = newText\n\n          onShapeChange?.({\n            ...shape,\n            id: shape.id,\n            point: Vec.sub(shape.point, delta),\n            text: newText,\n          })\n        },\n        [shape.id, shape.point]\n      )\n\n      const handleKeyDown = React.useCallback(\n        (e: React.KeyboardEvent<HTMLTextAreaElement>) => {\n          if (e.key === 'Escape') {\n            e.preventDefault()\n            e.stopPropagation()\n            onShapeBlur?.()\n            return\n          }\n\n          if (e.key === 'Tab' && shape.text.length === 0) {\n            e.preventDefault()\n            return\n          }\n\n          if (e.key === 'Enter' && (e.metaKey || e.ctrlKey)) {\n            e.preventDefault()\n            e.stopPropagation()\n            rInput.current!.blur()\n            return\n          }\n\n          if (!(e.key === 'Meta' || e.metaKey)) {\n            e.stopPropagation()\n          } else if (e.key === 'z' && e.metaKey) {\n            if (e.shiftKey) {\n              document.execCommand('redo', false)\n            } else {\n              document.execCommand('undo', false)\n            }\n            e.stopPropagation()\n            e.preventDefault()\n            return\n          }\n          if ((e.metaKey || e.ctrlKey) && e.key === '=') {\n            e.preventDefault()\n          }\n          if (e.key === 'Tab') {\n            e.preventDefault()\n            if (e.shiftKey) {\n              TextAreaUtils.unindent(e.currentTarget)\n            } else {\n              TextAreaUtils.indent(e.currentTarget)\n            }\n\n            onShapeChange?.({ ...shape, text: TLDR.normalizeText(e.currentTarget.value) })\n          }\n        },\n        [shape, onShapeChange]\n      )\n\n      const handleBlur = React.useCallback((e: React.FocusEvent<HTMLTextAreaElement>) => {\n        e.currentTarget.setSelectionRange(0, 0)\n        onShapeBlur?.()\n      }, [])\n\n      const handleFocus = React.useCallback(\n        (e: React.FocusEvent<HTMLTextAreaElement>) => {\n          if (!isEditing) return\n          if (!rIsMounted.current) return\n          if (document.activeElement === e.currentTarget) {\n            e.currentTarget.select()\n          }\n        },\n        [isEditing]\n      )\n\n      const handlePointerDown = React.useCallback(\n        (e: React.PointerEvent<HTMLDivElement | HTMLTextAreaElement>) => {\n          if (isEditing) {\n            e.stopPropagation()\n          }\n        },\n        [isEditing]\n      )\n\n      const rWasEditing = React.useRef(isEditing)\n\n      React.useEffect(() => {\n        if (isEditing) {\n          rWasEditing.current = true\n          this.texts.set(shape.id, text)\n          requestAnimationFrame(() => {\n            rIsMounted.current = true\n            const elm = rInput.current\n            if (elm) {\n              elm.focus()\n              elm.select()\n            }\n          })\n        } else if (rWasEditing.current) {\n          rWasEditing.current = false\n          onShapeBlur?.()\n        }\n      }, [isEditing])\n\n      return (\n        <HTMLContainer ref={ref} {...events}>\n          <Wrapper isGhost={isGhost} isEditing={isEditing} onPointerDown={handlePointerDown}>\n            <InnerWrapper\n              style={{\n                font,\n                color: styles.stroke,\n                textAlign: getTextAlign(style.textAlign),\n              }}\n            >\n              {isBinding && (\n                <div\n                  className=\"tl-binding-indicator\"\n                  style={{\n                    position: 'absolute',\n                    top: -this.bindingDistance,\n                    left: -this.bindingDistance,\n                    width: `calc(100% + ${this.bindingDistance * 2}px)`,\n                    height: `calc(100% + ${this.bindingDistance * 2}px)`,\n                    backgroundColor: 'var(--tl-selectFill)',\n                  }}\n                />\n              )}\n              {isEditing ? (\n                <TextArea\n                  ref={rInput}\n                  style={{\n                    font,\n                    color: styles.stroke,\n                  }}\n                  name=\"text\"\n                  tabIndex={-1}\n                  autoComplete=\"false\"\n                  autoCapitalize=\"false\"\n                  autoCorrect=\"false\"\n                  autoSave=\"false\"\n                  autoFocus\n                  placeholder=\"\"\n                  spellCheck=\"true\"\n                  wrap=\"off\"\n                  dir=\"auto\"\n                  datatype=\"wysiwyg\"\n                  defaultValue={text}\n                  color={styles.stroke}\n                  onFocus={handleFocus}\n                  onChange={handleChange}\n                  onKeyDown={handleKeyDown}\n                  onBlur={handleBlur}\n                  onPointerDown={handlePointerDown}\n                  onContextMenu={stopPropagation}\n                  onCopy={stopPropagation}\n                  onPaste={stopPropagation}\n                  onCut={stopPropagation}\n                />\n              ) : (\n                text\n              )}\n              &#8203;\n            </InnerWrapper>\n          </Wrapper>\n        </HTMLContainer>\n      )\n    }\n  )\n\n  Indicator = TDShapeUtil.Indicator<T>(({ shape }) => {\n    const { width, height } = this.getBounds(shape)\n    return <rect x={0} y={0} width={width} height={height} />\n  })\n\n  getBounds = (shape: T) => {\n    const bounds = Utils.getFromCache(this.boundsCache, shape, () => {\n      if (!melm) {\n        // We're in SSR\n        return { minX: 0, minY: 0, maxX: 10, maxY: 10, width: 10, height: 10 }\n      }\n\n      if (!melm.parentNode) document.body.appendChild(melm)\n\n      melm.style.font = getFontStyle(shape.style)\n      melm.textContent = this.texts.get(shape.id) ?? shape.text\n\n      // In tests, offsetWidth and offsetHeight will be 0\n      const width = melm.offsetWidth || 1\n      const height = melm.offsetHeight || 1\n\n      return {\n        minX: 0,\n        maxX: width,\n        minY: 0,\n        maxY: height,\n        width,\n        height,\n      }\n    })\n\n    return Utils.translateBounds(bounds, shape.point)\n  }\n\n  shouldRender = (prev: T, next: T): boolean => {\n    return (\n      next.text !== prev.text || next.style.scale !== prev.style.scale || next.style !== prev.style\n    )\n  }\n\n  transform = (\n    shape: T,\n    bounds: TLBounds,\n    { initialShape, scaleX, scaleY }: TransformInfo<T>\n  ): Partial<T> => {\n    const {\n      rotation = 0,\n      style: { scale = 1 },\n    } = initialShape\n\n    const nextScale = scale * Math.abs(Math.min(scaleX, scaleY))\n\n    return {\n      point: [bounds.minX, bounds.minY],\n      rotation:\n        (scaleX < 0 && scaleY >= 0) || (scaleY < 0 && scaleX >= 0) ? -(rotation || 0) : rotation,\n      style: {\n        ...initialShape.style,\n        scale: nextScale,\n      },\n    }\n  }\n\n  transformSingle = (\n    shape: T,\n    bounds: TLBounds,\n    { initialShape, scaleX, scaleY }: TransformInfo<T>\n  ): Partial<T> | void => {\n    const {\n      style: { scale = 1 },\n    } = initialShape\n\n    return {\n      point: Vec.toFixed([bounds.minX, bounds.minY]),\n      style: {\n        ...initialShape.style,\n        scale: scale * Math.max(Math.abs(scaleY), Math.abs(scaleX)),\n      },\n    }\n  }\n\n  onDoubleClickBoundsHandle = (shape: T) => {\n    const center = this.getCenter(shape)\n\n    const newCenter = this.getCenter({\n      ...shape,\n      style: {\n        ...shape.style,\n        scale: 1,\n      },\n    })\n\n    return {\n      style: {\n        ...shape.style,\n        scale: 1,\n      },\n      point: Vec.toFixed(Vec.add(shape.point, Vec.sub(center, newCenter))),\n    }\n  }\n\n  getSvgElement = (shape: T, isDarkMode: boolean): SVGElement | void => {\n    const bounds = this.getBounds(shape)\n    const style = getShapeStyle(shape.style, isDarkMode)\n\n    const fontSize = getFontSize(shape.style.size, shape.style.font) * (shape.style.scale ?? 1)\n    const fontFamily = getFontFace(shape.style.font).slice(1, -1)\n    const textAlign = shape.style.textAlign ?? AlignStyle.Middle\n\n    const textElm = getTextSvgElement(\n      shape.text,\n      fontSize,\n      fontFamily,\n      textAlign,\n      bounds.width,\n      false\n    )\n\n    textElm.setAttribute('fill', style.stroke)\n\n    return textElm\n  }\n}\n\n/* -------------------------------------------------- */\n/*                       Helpers                      */\n/* -------------------------------------------------- */\n\nlet melm: any\n\nfunction getMeasurementDiv() {\n  // A div used for measurement\n  document.getElementById('__textMeasure')?.remove()\n\n  const pre = document.createElement('pre')\n  pre.id = '__textMeasure'\n\n  Object.assign(pre.style, {\n    whiteSpace: 'pre',\n    width: 'auto',\n    border: '1px solid transparent',\n    padding: '4px',\n    margin: '0px',\n    letterSpacing: LETTER_SPACING,\n    opacity: '0',\n    position: 'absolute',\n    top: '-500px',\n    left: '0px',\n    zIndex: '9999',\n    pointerEvents: 'none',\n    userSelect: 'none',\n    alignmentBaseline: 'mathematical',\n    dominantBaseline: 'mathematical',\n  })\n\n  pre.tabIndex = -1\n\n  document.body.appendChild(pre)\n  return pre\n}\n\nif (typeof window !== 'undefined') {\n  melm = getMeasurementDiv()\n}\n\nconst Wrapper = styled('div', {\n  width: '100%',\n  height: '100%',\n  variants: {\n    isGhost: {\n      false: { opacity: 1 },\n      true: { transition: 'opacity .2s', opacity: GHOSTED_OPACITY },\n    },\n    isEditing: {\n      false: {\n        pointerEvents: 'all',\n        userSelect: 'all',\n      },\n      true: {\n        pointerEvents: 'none',\n        userSelect: 'none',\n      },\n    },\n  },\n})\n\nconst commonTextWrapping = {\n  whiteSpace: 'pre-wrap',\n  overflowWrap: 'break-word',\n}\n\nconst InnerWrapper = styled('div', {\n  position: 'absolute',\n  width: '100%',\n  height: '100%',\n  padding: '4px',\n  zIndex: 1,\n  minHeight: 1,\n  minWidth: 1,\n  lineHeight: 1,\n  letterSpacing: LETTER_SPACING,\n  outline: 0,\n  fontWeight: '500',\n  backfaceVisibility: 'hidden',\n  userSelect: 'none',\n  pointerEvents: 'none',\n  WebkitUserSelect: 'none',\n  WebkitTouchCallout: 'none',\n  isEditing: {\n    false: {},\n    true: {\n      pointerEvents: 'all',\n      background: '$boundsBg',\n      userSelect: 'text',\n      WebkitUserSelect: 'text',\n    },\n  },\n  ...commonTextWrapping,\n})\n\nconst TextArea = styled('textarea', {\n  position: 'absolute',\n  top: 0,\n  left: 0,\n  zIndex: 1,\n  width: '100%',\n  height: '100%',\n  border: 'none',\n  padding: '4px',\n  resize: 'none',\n  textAlign: 'inherit',\n  minHeight: 'inherit',\n  minWidth: 'inherit',\n  lineHeight: 'inherit',\n  letterSpacing: 'inherit',\n  outline: 0,\n  fontWeight: 'inherit',\n  overflow: 'hidden',\n  backfaceVisibility: 'hidden',\n  display: 'inline-block',\n  pointerEvents: 'all',\n  background: '$boundsBg',\n  userSelect: 'text',\n  WebkitUserSelect: 'text',\n  ...commonTextWrapping,\n  '&:focus': {\n    outline: 'none',\n    border: 'none',\n  },\n})\n", "import { SVGContainer, TLBounds, Utils } from '@tldraw/core'\nimport {\n  intersectBoundsPolygon,\n  intersectLineSegmentPolyline,\n  intersectRayLineSegment,\n} from '@tldraw/intersect'\nimport Vec from '@tldraw/vec'\nimport * as React from 'react'\nimport { BINDING_DISTANCE, GHOSTED_OPACITY, LABEL_POINT } from '~constants'\nimport { TDShapeUtil } from '~state/shapes/TDShapeUtil'\nimport {\n  TextLabel,\n  defaultStyle,\n  getBoundsRectangle,\n  getFontStyle,\n  getShapeStyle,\n  transformRectangle,\n  transformSingleRectangle,\n} from '~state/shapes/shared'\nimport { styled } from '~styles'\nimport { DashStyle, TDMeta, TDShape, TDShapeType, TriangleShape } from '~types'\nimport { DashedTriangle } from './components/DashedTriangle'\nimport { DrawTriangle } from './components/DrawTriangle'\nimport { TriangleBindingIndicator } from './components/TriangleBindingIndicator'\nimport { getTriangleCentroid, getTrianglePoints } from './triangleHelpers'\n\ntype T = TriangleShape\ntype E = HTMLDivElement\n\nexport class TriangleUtil extends TDShapeUtil<T, E> {\n  type = TDShapeType.Triangle as const\n\n  canBind = true\n\n  canClone = true\n\n  canEdit = true\n\n  getShape = (props: Partial<T>): T => {\n    return Utils.deepMerge<T>(\n      {\n        id: 'id',\n        type: TDShapeType.Triangle,\n        name: 'Triangle',\n        parentId: 'page',\n        childIndex: 1,\n        point: [0, 0],\n        size: [1, 1],\n        rotation: 0,\n        style: defaultStyle,\n        label: '',\n        labelPoint: [0.5, 0.5],\n      },\n      props\n    )\n  }\n\n  Component = TDShapeUtil.Component<T, E, TDMeta>(\n    (\n      {\n        shape,\n        bounds,\n        isBinding,\n        isEditing,\n        isSelected,\n        isGhost,\n        meta,\n        events,\n        onShapeChange,\n        onShapeBlur,\n      },\n      ref\n    ) => {\n      const { id, label = '', size, style, labelPoint = LABEL_POINT } = shape\n      const font = getFontStyle(style)\n      const styles = getShapeStyle(style, meta.isDarkMode)\n      const Component = style.dash === DashStyle.Draw ? DrawTriangle : DashedTriangle\n      const handleLabelChange = React.useCallback(\n        (label: string) => onShapeChange?.({ id, label }),\n        [onShapeChange]\n      )\n      const offsetY = React.useMemo(() => {\n        const center = Vec.div(size, 2)\n        const centroid = getTriangleCentroid(size)\n        return (centroid[1] - center[1]) * 0.72\n      }, [size])\n      return (\n        <FullWrapper ref={ref} {...events}>\n          <TextLabel\n            font={font}\n            text={label}\n            color={styles.stroke}\n            offsetX={(labelPoint[0] - 0.5) * bounds.width}\n            offsetY={offsetY + (labelPoint[1] - 0.5) * bounds.height}\n            isEditing={isEditing}\n            onChange={handleLabelChange}\n            onBlur={onShapeBlur}\n          />\n          <SVGContainer id={shape.id + '_svg'} opacity={isGhost ? GHOSTED_OPACITY : 1}>\n            {isBinding && <TriangleBindingIndicator size={size} />}\n            <Component\n              id={id}\n              style={style}\n              size={size}\n              isSelected={isSelected}\n              isDarkMode={meta.isDarkMode}\n            />\n          </SVGContainer>\n        </FullWrapper>\n      )\n    }\n  )\n\n  Indicator = TDShapeUtil.Indicator<T>(({ shape }) => {\n    const { size } = shape\n    return <polygon points={getTrianglePoints(size).join()} />\n  })\n\n  private getPoints(shape: T) {\n    const {\n      rotation = 0,\n      point: [x, y],\n      size: [w, h],\n    } = shape\n    return [\n      [x + w / 2, y],\n      [x, y + h],\n      [x + w, y + h],\n    ].map((pt) => Vec.rotWith(pt, this.getCenter(shape), rotation))\n  }\n\n  shouldRender = (prev: T, next: T) => {\n    return next.size !== prev.size || next.style !== prev.style || next.label !== prev.label\n  }\n\n  getBounds = (shape: T) => {\n    return getBoundsRectangle(shape, this.boundsCache)\n  }\n\n  getExpandedBounds = (shape: T) => {\n    return Utils.getBoundsFromPoints(\n      getTrianglePoints(shape.size, this.bindingDistance).map((pt) => Vec.add(pt, shape.point))\n    )\n  }\n\n  hitTestLineSegment = (shape: T, A: number[], B: number[]): boolean => {\n    return intersectLineSegmentPolyline(A, B, this.getPoints(shape)).didIntersect\n  }\n\n  hitTestBounds = (shape: T, bounds: TLBounds): boolean => {\n    return (\n      Utils.boundsContained(this.getBounds(shape), bounds) ||\n      intersectBoundsPolygon(bounds, this.getPoints(shape)).length > 0\n    )\n  }\n\n  getBindingPoint = <K extends TDShape>(\n    shape: T,\n    fromShape: K,\n    point: number[],\n    origin: number[],\n    direction: number[],\n    bindAnywhere: boolean\n  ) => {\n    // Algorithm time! We need to find the binding point (a normalized point inside of the shape, or around the shape, where the arrow will point to) and the distance from the binding shape to the anchor.\n\n    const expandedBounds = this.getExpandedBounds(shape)\n\n    if (!Utils.pointInBounds(point, expandedBounds)) return\n\n    const points = getTrianglePoints(shape.size).map((pt) => Vec.add(pt, shape.point))\n\n    const expandedPoints = getTrianglePoints(shape.size, this.bindingDistance).map((pt) =>\n      Vec.add(pt, shape.point)\n    )\n\n    const closestDistanceToEdge = Utils.pointsToLineSegments(points, true)\n      .map(([a, b]) => Vec.distanceToLineSegment(a, b, point))\n      .sort((a, b) => a - b)[0]\n\n    if (\n      !(Utils.pointInPolygon(point, expandedPoints) || closestDistanceToEdge < this.bindingDistance)\n    )\n      return\n\n    const intersections = Utils.pointsToLineSegments(expandedPoints.concat([expandedPoints[0]]))\n      .map((segment) => intersectRayLineSegment(origin, direction, segment[0], segment[1]))\n      .filter((intersection) => intersection.didIntersect)\n      .flatMap((intersection) => intersection.points)\n\n    if (!intersections.length) return\n\n    // The center of the triangle\n    const center = Vec.add(getTriangleCentroid(shape.size), shape.point)\n\n    // Find furthest intersection between ray from origin through point and expanded bounds. TODO: What if the shape has a curve? In that case, should we intersect the circle-from-three-points instead?\n    const intersection = intersections.sort((a, b) => Vec.dist(b, origin) - Vec.dist(a, origin))[0]\n\n    // The point between the handle and the intersection\n    const middlePoint = Vec.med(point, intersection)\n\n    let anchor: number[]\n    let distance: number\n\n    if (bindAnywhere) {\n      anchor = Vec.dist(point, center) < BINDING_DISTANCE / 2 ? center : point\n      distance = 0\n    } else {\n      if (Vec.distanceToLineSegment(point, middlePoint, center) < BINDING_DISTANCE / 2) {\n        anchor = center\n      } else {\n        anchor = middlePoint\n      }\n\n      if (Utils.pointInPolygon(point, points)) {\n        distance = this.bindingDistance\n      } else {\n        distance = Math.max(this.bindingDistance, closestDistanceToEdge)\n      }\n    }\n\n    const bindingPoint = Vec.divV(Vec.sub(anchor, [expandedBounds.minX, expandedBounds.minY]), [\n      expandedBounds.width,\n      expandedBounds.height,\n    ])\n\n    return {\n      point: Vec.clampV(bindingPoint, 0, 1),\n      distance,\n    }\n  }\n\n  transform = transformRectangle\n\n  transformSingle = transformSingleRectangle\n}\n\nconst FullWrapper = styled('div', { width: '100%', height: '100%' })\n", "import { Utils } from '@tldraw/core'\nimport Vec from '@tldraw/vec'\nimport * as React from 'react'\nimport { getShapeStyle } from '~state/shapes/shared'\nimport type { ShapeStyles } from '~types'\nimport { getTrianglePoints } from '../triangleHelpers'\n\ninterface TriangleSvgProps {\n  id: string\n  size: number[]\n  style: ShapeStyles\n  isSelected: boolean\n  isDarkMode: boolean\n}\n\nexport const DashedTriangle = React.memo(function DashedTriangle({\n  id,\n  size,\n  style,\n  isSelected,\n  isDarkMode,\n}: TriangleSvgProps) {\n  const { stroke, strokeWidth, fill } = getShapeStyle(style, isDarkMode)\n  const sw = 1 + strokeWidth * 1.618\n  const points = getTrianglePoints(size)\n  const sides = Utils.pointsToLineSegments(points, true)\n  const paths = sides.map(([start, end], i) => {\n    const { strokeDasharray, strokeDashoffset } = Utils.getPerfectDashProps(\n      Vec.dist(start, end),\n      strokeWidth * 1.618,\n      style.dash\n    )\n\n    return (\n      <line\n        key={id + '_' + i}\n        x1={start[0]}\n        y1={start[1]}\n        x2={end[0]}\n        y2={end[1]}\n        stroke={stroke}\n        strokeWidth={sw}\n        strokeLinecap=\"round\"\n        strokeDasharray={strokeDasharray}\n        strokeDashoffset={strokeDashoffset}\n      />\n    )\n  })\n\n  const bgPath = points.join()\n\n  return (\n    <>\n      <polygon\n        className={style.isFilled || isSelected ? 'tl-fill-hitarea' : 'tl-stroke-hitarea'}\n        points={bgPath}\n      />\n      {style.isFilled && <polygon fill={fill} points={bgPath} pointerEvents=\"none\" />}\n      <g pointerEvents=\"stroke\">{paths}</g>\n    </>\n  )\n})\n", "import { Utils } from '@tldraw/core'\nimport Vec from '@tldraw/vec'\nimport getStroke, { getStrokePoints } from 'perfect-freehand'\nimport { getOffsetPolygon, getShapeStyle } from '~state/shapes/shared'\nimport type { ShapeStyles } from '~types'\n\nexport function getTrianglePoints(size: number[], offset = 0, rotation = 0) {\n  const [w, h] = size\n  let points = [\n    [w / 2, 0],\n    [w, h],\n    [0, h],\n  ]\n  if (offset) points = getOffsetPolygon(points, offset)\n  if (rotation) points = points.map((pt) => Vec.rotWith(pt, [w / 2, h / 2], rotation))\n\n  return points\n}\n\nexport function getTriangleCentroid(size: number[]) {\n  const [w, h] = size\n  const points = [\n    [w / 2, 0],\n    [w, h],\n    [0, h],\n  ]\n  return [\n    (points[0][0] + points[1][0] + points[2][0]) / 3,\n    (points[0][1] + points[1][1] + points[2][1]) / 3,\n  ]\n}\n\nfunction getTriangleDrawPoints(id: string, size: number[], strokeWidth: number) {\n  const [w, h] = size\n  const getRandom = Utils.rng(id)\n  // Random corner offsets\n  const offsets = Array.from(Array(3)).map(() => {\n    return [getRandom() * strokeWidth * 0.75, getRandom() * strokeWidth * 0.75]\n  })\n  // Corners\n  const corners = [\n    Vec.add([w / 2, 0], offsets[0]),\n    Vec.add([w, h], offsets[1]),\n    Vec.add([0, h], offsets[2]),\n  ]\n  // Which side to start drawing first\n  const rm = Math.round(Math.abs(getRandom() * 2 * 3))\n  // Number of points per side\n  // Inset each line by the corner radii and let the freehand algo\n  // interpolate points for the corners.\n  const lines = Utils.rotateArray(\n    [\n      Vec.pointsBetween(corners[0], corners[1], 32),\n      Vec.pointsBetween(corners[1], corners[2], 32),\n      Vec.pointsBetween(corners[2], corners[0], 32),\n    ],\n    rm\n  )\n  // For the final points, include the first half of the first line again,\n  // so that the line wraps around and avoids ending on a sharp corner.\n  // This has a bit of finesse and magic\u2014if you change the points between\n  // function, then you'll likely need to change this one too.\n  const points = [...lines.flat(), ...lines[0]]\n  return {\n    points,\n  }\n}\n\nfunction getDrawStrokeInfo(id: string, size: number[], style: ShapeStyles) {\n  const { strokeWidth } = getShapeStyle(style)\n  const { points } = getTriangleDrawPoints(id, size, strokeWidth)\n  const options = {\n    size: strokeWidth,\n    thinning: 0.65,\n    streamline: 0.3,\n    smoothing: 1,\n    simulatePressure: false,\n    last: true,\n  }\n  return { points, options }\n}\n\nexport function getTrianglePath(id: string, size: number[], style: ShapeStyles) {\n  const { points, options } = getDrawStrokeInfo(id, size, style)\n  const stroke = getStroke(points, options)\n  return Utils.getSvgPathFromStroke(stroke)\n}\n\nexport function getTriangleIndicatorPathTDSnapshot(id: string, size: number[], style: ShapeStyles) {\n  const { points, options } = getDrawStrokeInfo(id, size, style)\n  return Utils.getSvgPathFromStrokePoints(getStrokePoints(points, options))\n}\n", "import * as React from 'react'\nimport { getShapeStyle } from '~state/shapes/shared'\nimport type { ShapeStyles } from '~types'\nimport { getTriangleIndicatorPathTDSnapshot, getTrianglePath } from '../triangleHelpers'\n\ninterface TriangleSvgProps {\n  id: string\n  size: number[]\n  style: ShapeStyles\n  isSelected: boolean\n  isDarkMode: boolean\n}\n\nexport const DrawTriangle = React.memo(function DrawTriangle({\n  id,\n  size,\n  style,\n  isSelected,\n  isDarkMode,\n}: TriangleSvgProps) {\n  const { stroke, strokeWidth, fill } = getShapeStyle(style, isDarkMode)\n  const pathTDSnapshot = getTrianglePath(id, size, style)\n  const indicatorPath = getTriangleIndicatorPathTDSnapshot(id, size, style)\n  return (\n    <>\n      <path\n        className={style.isFilled || isSelected ? 'tl-fill-hitarea' : 'tl-stroke-hitarea'}\n        d={indicatorPath}\n      />\n      {style.isFilled && <path d={indicatorPath} fill={fill} pointerEvents=\"none\" />}\n      <path\n        d={pathTDSnapshot}\n        fill={stroke}\n        stroke={stroke}\n        strokeWidth={strokeWidth}\n        pointerEvents=\"none\"\n      />\n    </>\n  )\n})\n", "import * as React from 'react'\nimport { BINDING_DISTANCE } from '~constants'\nimport { getTrianglePoints } from '../triangleHelpers'\n\ninterface TriangleBindingIndicatorProps {\n  size: number[]\n}\n\nexport function TriangleBindingIndicator({ size }: TriangleBindingIndicatorProps) {\n  const trianglePoints = getTrianglePoints(size).join()\n  return (\n    <polygon\n      className=\"tl-binding-indicator\"\n      points={trianglePoints}\n      strokeWidth={BINDING_DISTANCE * 2}\n    />\n  )\n}\n", "import { styled } from '@stitches/react'\nimport { HTMLContainer, Utils } from '@tldraw/core'\nimport * as React from 'react'\nimport { GHOSTED_OPACITY } from '~constants'\nimport { TDShapeUtil } from '~state/shapes/TDShapeUtil'\nimport {\n  defaultStyle,\n  getBoundsRectangle,\n  transformRectangle,\n  transformSingleRectangle,\n} from '~state/shapes/shared'\nimport { TDMeta, TDShapeType, TDVideoAsset, VideoShape } from '~types'\n\ntype T = VideoShape\ntype E = HTMLDivElement\n\nexport class VideoUtil extends TDShapeUtil<T, E> {\n  type = TDShapeType.Video as const\n  canBind = true\n  canEdit = true\n  canClone = true\n  isAspectRatioLocked = true\n  showCloneHandles = false\n  isStateful = true // don't unmount\n\n  getShape = (props: Partial<T>): T => {\n    return Utils.deepMerge<T>(\n      {\n        id: 'video',\n        type: TDShapeType.Video,\n        name: 'Video',\n        parentId: 'page',\n        childIndex: 1,\n        point: [0, 0],\n        size: [1, 1],\n        rotation: 0,\n        style: defaultStyle,\n        assetId: 'assetId',\n        isPlaying: true,\n        currentTime: 0,\n      },\n      props\n    )\n  }\n\n  Component = TDShapeUtil.Component<T, E, TDMeta>(\n    (\n      { shape, asset = { src: '' }, isBinding, isEditing, isGhost, meta, events, onShapeChange },\n      ref\n    ) => {\n      const rVideo = React.useRef<HTMLVideoElement>(null)\n      const rWrapper = React.useRef<HTMLDivElement>(null)\n\n      const { currentTime = 0, size, isPlaying, style } = shape\n\n      React.useLayoutEffect(() => {\n        const wrapper = rWrapper.current\n        if (!wrapper) return\n        const [width, height] = size\n        wrapper.style.width = `${width}px`\n        wrapper.style.height = `${height}px`\n      }, [size])\n\n      React.useLayoutEffect(() => {\n        const video = rVideo.current\n        if (!video) return\n        if (isPlaying) video.play()\n        // throws error on safari\n        else video.pause()\n      }, [isPlaying])\n\n      React.useLayoutEffect(() => {\n        const video = rVideo.current\n        if (!video) return\n        if (currentTime !== video.currentTime) {\n          video.currentTime = currentTime\n        }\n      }, [currentTime])\n\n      const handlePlay = React.useCallback(() => {\n        onShapeChange?.({ id: shape.id, isPlaying: true })\n      }, [])\n\n      const handlePause = React.useCallback(() => {\n        onShapeChange?.({ id: shape.id, isPlaying: false })\n      }, [])\n\n      const handleSetCurrentTime = React.useCallback(() => {\n        const video = rVideo.current\n        if (!video) return\n        if (!isEditing) return\n        onShapeChange?.({ id: shape.id, currentTime: video.currentTime })\n      }, [isEditing])\n\n      return (\n        <HTMLContainer ref={ref} {...events}>\n          {isBinding && (\n            <div\n              className=\"tl-binding-indicator\"\n              style={{\n                position: 'absolute',\n                top: -this.bindingDistance,\n                left: -this.bindingDistance,\n                width: `calc(100% + ${this.bindingDistance * 2}px)`,\n                height: `calc(100% + ${this.bindingDistance * 2}px)`,\n                backgroundColor: 'var(--tl-selectFill)',\n              }}\n            />\n          )}\n          <Wrapper\n            ref={rWrapper}\n            isDarkMode={meta.isDarkMode}\n            isGhost={isGhost}\n            isFilled={style.isFilled}\n          >\n            <VideoElement\n              ref={rVideo}\n              id={shape.id + '_video'}\n              muted\n              loop\n              playsInline\n              disableRemotePlayback\n              disablePictureInPicture\n              controls={isEditing}\n              autoPlay={isPlaying}\n              onPlay={handlePlay}\n              onPause={handlePause}\n              onTimeUpdate={handleSetCurrentTime}\n            >\n              <source src={(asset as TDVideoAsset).src} />\n            </VideoElement>\n          </Wrapper>\n        </HTMLContainer>\n      )\n    }\n  )\n\n  Indicator = TDShapeUtil.Indicator<T>(({ shape }) => {\n    const {\n      size: [width, height],\n    } = shape\n\n    return (\n      <rect x={0} y={0} rx={2} ry={2} width={Math.max(1, width)} height={Math.max(1, height)} />\n    )\n  })\n\n  getBounds = (shape: T) => {\n    return getBoundsRectangle(shape, this.boundsCache)\n  }\n\n  shouldRender = (prev: T, next: T) => {\n    return next.size !== prev.size || next.style !== prev.style || next.isPlaying !== prev.isPlaying\n  }\n\n  getSvgElement = (shape: VideoShape) => {\n    const bounds = this.getBounds(shape)\n    const elm = document.createElementNS('http://www.w3.org/2000/svg', 'image')\n    elm.setAttribute('width', `${bounds.width}`)\n    elm.setAttribute('height', `${bounds.height}`)\n    elm.setAttribute('xmlns:xlink', `http://www.w3.org/1999/xlink`)\n    return elm\n  }\n\n  transform = transformRectangle\n\n  transformSingle = transformSingleRectangle\n}\n\nconst Wrapper = styled('div', {\n  pointerEvents: 'all',\n  position: 'relative',\n  fontFamily: 'sans-serif',\n  fontSize: '2em',\n  height: '100%',\n  width: '100%',\n  borderRadius: '3px',\n  perspective: '800px',\n  overflow: 'hidden',\n  p: {\n    userSelect: 'none',\n  },\n  img: {\n    userSelect: 'none',\n  },\n  variants: {\n    isGhost: {\n      false: { opacity: 1 },\n      true: { transition: 'opacity .2s', opacity: GHOSTED_OPACITY },\n    },\n    isFilled: {\n      true: {},\n      false: {},\n    },\n    isDarkMode: {\n      true: {},\n      false: {},\n    },\n  },\n  compoundVariants: [\n    {\n      isFilled: true,\n      isDarkMode: true,\n      css: {\n        boxShadow:\n          '2px 3px 12px -2px rgba(0,0,0,.3), 1px 1px 4px rgba(0,0,0,.3), 1px 1px 2px rgba(0,0,0,.3)',\n      },\n    },\n    {\n      isFilled: true,\n      isDarkMode: false,\n      css: {\n        boxShadow:\n          '2px 3px 12px -2px rgba(0,0,0,.2), 1px 1px 4px rgba(0,0,0,.16),  1px 1px 2px rgba(0,0,0,.16)',\n      },\n    },\n  ],\n})\n\nconst VideoElement = styled('video', {\n  position: 'absolute',\n  top: 0,\n  left: 0,\n  width: '100%',\n  height: '100%',\n  maxWidth: '100%',\n  minWidth: '100%',\n  pointerEvents: 'none',\n  objectFit: 'cover',\n  userSelect: 'none',\n  borderRadius: 2,\n})\n", "import type { TDShapeUtil } from '~state/shapes/TDShapeUtil'\nimport { TDShape, TDShapeType } from '~types'\nimport { ArrowUtil } from './ArrowUtil'\nimport { DrawUtil } from './DrawUtil'\nimport { EllipseUtil } from './EllipseUtil'\nimport { GroupUtil } from './GroupUtil'\nimport { ImageUtil } from './ImageUtil'\nimport { RectangleUtil } from './RectangleUtil'\nimport { StickyUtil } from './StickyUtil'\nimport { TextUtil } from './TextUtil'\nimport { TriangleUtil } from './TriangleUtil'\nimport { VideoUtil } from './VideoUtil'\n\nexport const Rectangle = new RectangleUtil()\nexport const Triangle = new TriangleUtil()\nexport const Ellipse = new EllipseUtil()\nexport const Draw = new DrawUtil()\nexport const Arrow = new ArrowUtil()\nexport const Text = new TextUtil()\nexport const Group = new GroupUtil()\nexport const Sticky = new StickyUtil()\nexport const Image = new ImageUtil()\nexport const Video = new VideoUtil()\n\nexport const shapeUtils = {\n  [TDShapeType.Rectangle]: Rectangle,\n  [TDShapeType.Triangle]: Triangle,\n  [TDShapeType.Ellipse]: Ellipse,\n  [TDShapeType.Draw]: Draw,\n  [TDShapeType.Arrow]: Arrow,\n  [TDShapeType.Text]: Text,\n  [TDShapeType.Group]: Group,\n  [TDShapeType.Sticky]: Sticky,\n  [TDShapeType.Image]: Image,\n  [TDShapeType.Video]: Video,\n}\n\nexport const getShapeUtil = <T extends TDShape>(shape: T | T['type']) => {\n  if (typeof shape === 'string') return shapeUtils[shape] as unknown as TDShapeUtil<T>\n  return shapeUtils[shape.type] as unknown as TDShapeUtil<T>\n}\n", "import * as DropdownMenu from '@radix-ui/react-dropdown-menu'\nimport { CheckIcon, PlusIcon } from '@radix-ui/react-icons'\nimport * as React from 'react'\nimport { FormattedMessage, useIntl } from 'react-intl'\nimport { Divider } from '~components/Primitives/Divider'\nimport { DMContent } from '~components/Primitives/DropdownMenu'\nimport { RowButton } from '~components/Primitives/RowButton'\nimport { SmallIcon } from '~components/Primitives/SmallIcon'\nimport { ToolButton } from '~components/Primitives/ToolButton'\nimport { useTldrawApp } from '~hooks'\nimport { styled } from '~styles'\nimport type { TDSnapshot } from '~types'\nimport { PageOptionsDialog } from '../PageOptionsDialog'\n\nconst sortedSelector = (s: TDSnapshot) =>\n  Object.values(s.document.pages).sort((a, b) => (a.childIndex || 0) - (b.childIndex || 0))\n\nconst currentPageNameSelector = (s: TDSnapshot) => s.document.pages[s.appState.currentPageId].name\n\nconst currentPageIdSelector = (s: TDSnapshot) => s.document.pages[s.appState.currentPageId].id\n\nexport function PageMenu() {\n  const app = useTldrawApp()\n\n  const intl = useIntl()\n\n  const rIsOpen = React.useRef(false)\n\n  const [isOpen, setIsOpen] = React.useState(false)\n\n  React.useEffect(() => {\n    if (rIsOpen.current !== isOpen) {\n      rIsOpen.current = isOpen\n    }\n  }, [isOpen])\n\n  const handleClose = React.useCallback(() => {\n    setIsOpen(false)\n  }, [setIsOpen])\n\n  const handleOpenChange = React.useCallback(\n    (isOpen: boolean) => {\n      if (rIsOpen.current !== isOpen) {\n        setIsOpen(isOpen)\n      }\n    },\n    [setIsOpen]\n  )\n  const currentPageName = app.useStore(currentPageNameSelector)\n\n  return (\n    <DropdownMenu.Root dir=\"ltr\" open={isOpen} onOpenChange={handleOpenChange}>\n      <DropdownMenu.Trigger dir=\"ltr\" asChild id=\"TD-Page\">\n        <ToolButton variant=\"text\">{currentPageName || intl.formatMessage({ id: 'page' })}</ToolButton>\n      </DropdownMenu.Trigger>\n      <DMContent variant=\"menu\" align=\"start\" sideOffset={4}>\n        {isOpen && <PageMenuContent onClose={handleClose} />}\n      </DMContent>\n    </DropdownMenu.Root>\n  )\n}\n\nfunction PageMenuContent({ onClose }: { onClose: () => void }) {\n  const app = useTldrawApp()\n  const intl = useIntl()\n\n  const sortedPages = app.useStore(sortedSelector)\n\n  const currentPageId = app.useStore(currentPageIdSelector)\n\n  const defaultPageName = intl.formatMessage({ id: 'page' })\n\n  const handleCreatePage = React.useCallback(() => {\n    const pageName =\n    defaultPageName + ' ' + (Object.keys(app.document.pages).length + 1)\n    app.createPage(undefined, pageName)\n  }, [app])\n\n  const handleChangePage = React.useCallback(\n    (id: string) => {\n      onClose()\n      app.changePage(id)\n    },\n    [app]\n  )\n\n  const [dragId, setDragId] = React.useState<null | string>(null)\n\n  const [dropIndex, setDropIndex] = React.useState<null | number>(null)\n\n  const handleDragStart = React.useCallback((ev: React.DragEvent<HTMLDivElement>) => {\n    setDragId(ev.currentTarget.id)\n    setDropIndex(sortedPages.findIndex((p) => p.id === ev.currentTarget.id))\n    ev.dataTransfer.effectAllowed = 'move'\n  }, [])\n\n  const handleDrag = React.useCallback(\n    (ev: React.DragEvent<HTMLDivElement>) => {\n      ev.preventDefault()\n\n      let dropIndex = sortedPages.findIndex((p) => p.id === ev.currentTarget.id)\n\n      const rect = ev.currentTarget.getBoundingClientRect()\n      const ny = (ev.clientY - rect.top) / rect.height\n\n      dropIndex = ny < 0.5 ? dropIndex : dropIndex + 1\n\n      setDropIndex(dropIndex)\n    },\n    [dragId, sortedPages]\n  )\n\n  const handleDrop = React.useCallback(() => {\n    if (dragId !== null && dropIndex !== null) {\n      app.movePage(dragId, dropIndex)\n    }\n\n    setDragId(null)\n    setDropIndex(null)\n  }, [dragId, dropIndex])\n\n  return (\n    <>\n      <DropdownMenu.RadioGroup dir=\"ltr\" value={currentPageId} onValueChange={handleChangePage}>\n        {sortedPages.map((page, i) => (\n          <ButtonWithOptions\n            key={page.id}\n            isDropAbove={i === dropIndex && i === 0}\n            isDropBelow={dropIndex !== null && i === dropIndex - 1}\n          >\n            <DropdownMenu.RadioItem\n              title={page.name || defaultPageName}\n              value={page.id}\n              key={page.id}\n              id={page.id}\n              asChild\n              onDragOver={handleDrag}\n              onDragStart={handleDragStart}\n              // onDrag={handleDrag}\n              onDrop={handleDrop}\n              draggable={true}\n            >\n              <PageButton>\n                <span id={page.id}>{page.name || defaultPageName}</span>\n                <DropdownMenu.ItemIndicator>\n                  <SmallIcon>\n                    <CheckIcon />\n                  </SmallIcon>\n                </DropdownMenu.ItemIndicator>\n              </PageButton>\n            </DropdownMenu.RadioItem>\n            <PageOptionsDialog page={page} onClose={onClose} />\n          </ButtonWithOptions>\n        ))}\n      </DropdownMenu.RadioGroup>\n      <Divider />\n      <DropdownMenu.Item onSelect={handleCreatePage} asChild>\n        <RowButton>\n          <span>\n            <FormattedMessage id=\"create.page\" />\n          </span>\n          <SmallIcon>\n            <PlusIcon />\n          </SmallIcon>\n        </RowButton>\n      </DropdownMenu.Item>\n    </>\n  )\n}\n\nconst ButtonWithOptions = styled('div', {\n  position: 'relative',\n  display: 'grid',\n  gridTemplateColumns: '1fr auto',\n  gridAutoFlow: 'column',\n  margin: 0,\n\n  '& > *[data-shy=\"true\"]': {\n    opacity: 0,\n  },\n\n  '&:hover > *[data-shy=\"true\"]': {\n    opacity: 1,\n  },\n\n  variants: {\n    isDropAbove: {\n      true: {\n        '&::after': {\n          content: '',\n          display: 'block',\n          position: 'absolute',\n          top: 0,\n          width: '100%',\n          height: '1px',\n          backgroundColor: '$selected',\n          zIndex: 999,\n          pointerEvents: 'none',\n        },\n      },\n    },\n    isDropBelow: {\n      true: {\n        '&::after': {\n          content: '',\n          display: 'block',\n          position: 'absolute',\n          width: '100%',\n          height: '1px',\n          top: '100%',\n          backgroundColor: '$selected',\n          zIndex: 999,\n          pointerEvents: 'none',\n        },\n      },\n    },\n  },\n})\n\nexport const PageButton = styled(RowButton, {\n  minWidth: 128,\n})\n", "import * as Dialog from '@radix-ui/react-alert-dialog'\nimport { MixerVerticalIcon, Pencil1Icon } from '@radix-ui/react-icons'\nimport * as React from 'react'\nimport { FormattedMessage, useIntl } from 'react-intl'\nimport { Divider } from '~components/Primitives/Divider'\nimport { IconButton } from '~components/Primitives/IconButton/IconButton'\nimport { RowButton, RowButtonProps } from '~components/Primitives/RowButton'\nimport { SmallIcon } from '~components/Primitives/SmallIcon'\nimport { TextField } from '~components/Primitives/TextField'\nimport { breakpoints } from '~components/breakpoints'\nimport { useContainer, useTldrawApp } from '~hooks'\nimport { styled } from '~styles'\nimport type { TDPage, TDSnapshot } from '~types'\n\nconst canDeleteSelector = (s: TDSnapshot) => {\n  return Object.keys(s.document.pages).length > 1\n}\n\ninterface PageOptionsDialogProps {\n  page: TDPage\n  onOpen?: () => void\n  onClose?: () => void\n}\n\nexport function PageOptionsDialog({ page, onOpen, onClose }: PageOptionsDialogProps) {\n  const app = useTldrawApp()\n  const intl = useIntl()\n\n  const [isOpen, setIsOpen] = React.useState(false)\n  const [pageName, setPageName] = React.useState(page.name || 'Page')\n\n  const canDelete = app.useStore(canDeleteSelector)\n\n  const rInput = React.useRef<HTMLInputElement>(null)\n\n  const handleClose = React.useCallback(() => {\n    setIsOpen(false)\n  }, [])\n\n  const handleDuplicate = React.useCallback(() => {\n    app.duplicatePage(page.id)\n  }, [app])\n\n  const handleDelete = React.useCallback(() => {\n    if (window.confirm(`Are you sure you want to delete this page?`)) {\n      app.deletePage(page.id)\n    }\n  }, [app])\n\n  const handleOpenChange = React.useCallback(\n    (isOpen: boolean) => {\n      setIsOpen(isOpen)\n\n      if (isOpen) {\n        onOpen?.()\n        return\n      }\n    },\n    [app]\n  )\n\n  function stopPropagation(e: React.KeyboardEvent<HTMLDivElement>) {\n    e.stopPropagation()\n  }\n\n  const rInitialName = React.useRef(page.name || 'Page')\n  const rCurrentName = React.useRef(rInitialName.current)\n\n  const handleTextFieldChange = React.useCallback((event: React.ChangeEvent<HTMLInputElement>) => {\n    const value = event.target.value.trimStart()\n    rCurrentName.current = value\n    setPageName(value)\n  }, [])\n\n  const handleTextFieldKeyDown = React.useCallback((e: React.KeyboardEvent<HTMLInputElement>) => {\n    switch (e.key) {\n      case 'Enter': {\n        if (rCurrentName.current === rInitialName.current) {\n          setIsOpen(false)\n        } else {\n          rInitialName.current = rCurrentName.current\n          app.renamePage(page.id, rCurrentName.current.trim())\n          setIsOpen(false)\n        }\n\n        break\n      }\n      case 'Escape': {\n        // If the name hasn't changed, close the menu\n        if (rCurrentName.current === rInitialName.current) {\n          setIsOpen(false)\n          return\n        }\n\n        // If the name has changed, revert the change\n        rCurrentName.current = rInitialName.current\n        setPageName(rInitialName.current)\n\n        // ...and refocus the input\n        requestAnimationFrame(() => {\n          const elm = rInput.current\n          if (elm) {\n            elm.focus()\n            elm.setSelectionRange(0, elm.value.length)\n          }\n        })\n        break\n      }\n    }\n  }, [])\n\n  const rWasOpen = React.useRef(false)\n\n  React.useEffect(() => {\n    if (isOpen) {\n      rWasOpen.current = true\n      rInitialName.current = page.name || 'Page'\n      rCurrentName.current = rInitialName.current\n\n      requestAnimationFrame(() => {\n        const elm = rInput.current\n        if (elm) {\n          elm.focus()\n          elm.setSelectionRange(0, elm.value.length)\n        }\n      })\n    } else if (rWasOpen.current) {\n      onClose?.()\n    }\n\n    return () => {\n      if (rCurrentName.current !== rInitialName.current) {\n        rInitialName.current = rCurrentName.current\n        app.renamePage(page.id, rCurrentName.current)\n      }\n    }\n  }, [isOpen])\n\n  const container = useContainer()\n\n  return (\n    <Dialog.Root open={isOpen} onOpenChange={handleOpenChange}>\n      <Dialog.Trigger asChild data-shy=\"true\">\n        <IconButton bp={breakpoints}>\n          <SmallIcon>\n            <MixerVerticalIcon />\n          </SmallIcon>\n        </IconButton>\n      </Dialog.Trigger>\n      <Dialog.Portal container={container.current}>\n        <StyledDialogOverlay onPointerDown={handleClose} />\n        <StyledDialogContent dir=\"ltr\" onKeyDown={stopPropagation} onKeyUp={stopPropagation}>\n          <TextField\n            ref={rInput}\n            placeholder={intl.formatMessage({ id: 'page.name' })}\n            value={pageName}\n            onChange={handleTextFieldChange}\n            onKeyDown={handleTextFieldKeyDown}\n            icon={<Pencil1Icon />}\n          />\n          <Divider />\n          <DialogAction onSelect={handleDuplicate}>\n            <FormattedMessage id=\"duplicate\" />\n          </DialogAction>\n          <DialogAction disabled={!canDelete} onSelect={handleDelete}>\n            <FormattedMessage id=\"delete\" />\n          </DialogAction>\n          <Divider />\n          <Dialog.Cancel asChild>\n            <RowButton>\n              <FormattedMessage id=\"cancel\" />\n            </RowButton>\n          </Dialog.Cancel>\n        </StyledDialogContent>\n      </Dialog.Portal>\n    </Dialog.Root>\n  )\n}\n\n/* -------------------------------------------------- */\n/*                       Dialog                       */\n/* -------------------------------------------------- */\n\nexport const StyledDialogContent = styled(Dialog.Content, {\n  position: 'absolute',\n  top: '50%',\n  left: '50%',\n  transform: 'translate(-50%, -50%)',\n  minWidth: 240,\n  maxWidth: 'fit-content',\n  maxHeight: '85vh',\n  marginTop: '-5vh',\n  pointerEvents: 'all',\n  backgroundColor: '$panel',\n  padding: '$1',\n  borderRadius: '$2',\n  font: '$ui',\n  zIndex: 999999,\n  '&:focus': {\n    outline: 'none',\n  },\n})\n\nexport const StyledDialogOverlay = styled(Dialog.Overlay, {\n  backgroundColor: 'rgba(0, 0, 0, .15)',\n  position: 'absolute',\n  pointerEvents: 'all',\n  inset: 0,\n  zIndex: 999998,\n})\n\nfunction DialogAction({\n  onSelect,\n  ...rest\n}: RowButtonProps & { onSelect: (e: React.SyntheticEvent<HTMLButtonElement, Event>) => void }) {\n  return (\n    <Dialog.Action asChild onClick={onSelect} onSelect={onSelect}>\n      <RowButton {...rest} />\n    </Dialog.Action>\n  )\n}\n", "import * as DropdownMenu from '@radix-ui/react-dropdown-menu'\nimport {\n  TextAlignCenterIcon,\n  TextAlignJustifyIcon,\n  TextAlignLeftIcon,\n  TextAlignRightIcon,\n} from '@radix-ui/react-icons'\nimport * as React from 'react'\nimport { FormattedMessage, useIntl } from 'react-intl'\nimport { Divider } from '~components/Primitives/Divider'\nimport { DMCheckboxItem, DMContent, DMRadioItem } from '~components/Primitives/DropdownMenu'\nimport { ToolButton } from '~components/Primitives/ToolButton'\nimport {\n  CircleIcon,\n  DashDashedIcon,\n  DashDottedIcon,\n  DashDrawIcon,\n  DashSolidIcon,\n  SizeLargeIcon,\n  SizeMediumIcon,\n  SizeSmallIcon,\n} from '~components/Primitives/icons'\nimport { breakpoints } from '~components/breakpoints'\nimport { preventEvent } from '~components/preventEvent'\nimport { useTldrawApp } from '~hooks'\nimport { defaultTextStyle, fills, strokes } from '~state/shapes/shared'\nimport { styled } from '~styles'\nimport {\n  AlignStyle,\n  ColorStyle,\n  DashStyle,\n  FontStyle,\n  ShapeStyles,\n  SizeStyle,\n  TDShapeType,\n  TDSnapshot,\n} from '~types'\n\nconst currentStyleSelector = (s: TDSnapshot) => s.appState.currentStyle\nconst selectedIdsSelector = (s: TDSnapshot) =>\n  s.document.pageStates[s.appState.currentPageId].selectedIds\n\nconst STYLE_KEYS = Object.keys(defaultTextStyle) as (keyof ShapeStyles)[]\n\nconst DASH_ICONS = {\n  [DashStyle.Draw]: <DashDrawIcon />,\n  [DashStyle.Solid]: <DashSolidIcon />,\n  [DashStyle.Dashed]: <DashDashedIcon />,\n  [DashStyle.Dotted]: <DashDottedIcon />,\n}\n\nconst SIZE_ICONS = {\n  [SizeStyle.Small]: <SizeSmallIcon />,\n  [SizeStyle.Medium]: <SizeMediumIcon />,\n  [SizeStyle.Large]: <SizeLargeIcon />,\n}\n\nconst ALIGN_ICONS = {\n  [AlignStyle.Start]: <TextAlignLeftIcon />,\n  [AlignStyle.Middle]: <TextAlignCenterIcon />,\n  [AlignStyle.End]: <TextAlignRightIcon />,\n  [AlignStyle.Justify]: <TextAlignJustifyIcon />,\n}\n\nconst themeSelector = (s: TDSnapshot) => (s.settings.isDarkMode ? 'dark' : 'light')\n\nconst keepOpenSelector = (s: TDSnapshot) => s.settings.keepStyleMenuOpen\n\nconst optionsSelector = (s: TDSnapshot) => {\n  const { activeTool, currentPageId: pageId } = s.appState\n  switch (activeTool) {\n    case 'select': {\n      const page = s.document.pages[pageId]\n      let hasText = false\n      let hasLabel = false\n      for (const id of s.document.pageStates[pageId].selectedIds) {\n        if ('text' in page.shapes[id]) hasText = true\n        if ('label' in page.shapes[id]) hasLabel = true\n      }\n      return hasText ? 'text' : hasLabel ? 'label' : ''\n    }\n    case TDShapeType.Text: {\n      return 'text'\n    }\n    case TDShapeType.Rectangle: {\n      return 'label'\n    }\n    case TDShapeType.Ellipse: {\n      return 'label'\n    }\n    case TDShapeType.Triangle: {\n      return 'label'\n    }\n    case TDShapeType.Arrow: {\n      return 'label'\n    }\n    case TDShapeType.Line: {\n      return 'label'\n    }\n  }\n\n  return false\n}\n\nexport const StyleMenu = React.memo(function ColorMenu() {\n  const app = useTldrawApp()\n\n  const intl = useIntl()\n\n  const theme = app.useStore(themeSelector)\n\n  const keepOpen = app.useStore(keepOpenSelector)\n\n  const options = app.useStore(optionsSelector)\n\n  const currentStyle = app.useStore(currentStyleSelector)\n\n  const selectedIds = app.useStore(selectedIdsSelector)\n\n  const [displayedStyle, setDisplayedStyle] = React.useState(currentStyle)\n\n  const rDisplayedStyle = React.useRef(currentStyle)\n\n  React.useEffect(() => {\n    const {\n      appState: { currentStyle },\n      page,\n      selectedIds,\n    } = app\n    let commonStyle = {} as ShapeStyles\n    if (selectedIds.length <= 0) {\n      commonStyle = currentStyle\n    } else {\n      const overrides = new Set<string>([])\n      app.selectedIds\n        .map((id) => page.shapes[id])\n        .forEach((shape) => {\n          STYLE_KEYS.forEach((key) => {\n            if (overrides.has(key)) return\n            if (commonStyle[key] === undefined) {\n              // @ts-ignore\n              commonStyle[key] = shape.style[key]\n            } else {\n              if (commonStyle[key] === shape.style[key]) return\n              // @ts-ignore\n              commonStyle[key] = shape.style[key]\n              overrides.add(key)\n            }\n          })\n        })\n    }\n    // Until we can work out the correct logic for deciding whether or not to\n    // update the selected style, do a string comparison. Yuck!\n    if (JSON.stringify(commonStyle) !== JSON.stringify(rDisplayedStyle.current)) {\n      rDisplayedStyle.current = commonStyle\n      setDisplayedStyle(commonStyle)\n    }\n  }, [currentStyle, selectedIds])\n\n  const handleToggleKeepOpen = React.useCallback((checked: boolean) => {\n    app.setSetting('keepStyleMenuOpen', checked)\n  }, [])\n\n  const handleToggleFilled = React.useCallback((checked: boolean) => {\n    app.style({ isFilled: checked })\n  }, [])\n\n  const handleDashChange = React.useCallback((value: string) => {\n    app.style({ dash: value as DashStyle })\n  }, [])\n\n  const handleSizeChange = React.useCallback((value: string) => {\n    app.style({ size: value as SizeStyle })\n  }, [])\n\n  const handleFontChange = React.useCallback((value: string) => {\n    app.style({ font: value as FontStyle })\n  }, [])\n\n  const handleTextAlignChange = React.useCallback((value: string) => {\n    app.style({ textAlign: value as AlignStyle })\n  }, [])\n\n  const handleMenuOpenChange = React.useCallback(\n    (open: boolean) => {\n      app.setMenuOpen(open)\n    },\n    [app]\n  )\n\n  return (\n    <DropdownMenu.Root\n      dir=\"ltr\"\n      onOpenChange={handleMenuOpenChange}\n      open={keepOpen ? true : undefined}\n      modal={false}\n    >\n      <DropdownMenu.Trigger asChild id=\"TD-Styles\">\n        <ToolButton aria-label={intl.formatMessage({ id: 'styles' })} variant=\"text\">\n          <FormattedMessage id=\"styles\" />\n          <OverlapIcons\n            style={{\n              color: strokes[theme][displayedStyle.color as ColorStyle],\n            }}\n          >\n            {displayedStyle.isFilled && (\n              <CircleIcon\n                size={16}\n                stroke=\"none\"\n                fill={fills[theme][displayedStyle.color as ColorStyle]}\n              />\n            )}\n            {DASH_ICONS[displayedStyle.dash]}\n          </OverlapIcons>\n        </ToolButton>\n      </DropdownMenu.Trigger>\n      <DMContent id=\"TD-StylesMenu\" side=\"bottom\" align=\"end\" sideOffset={4} alignOffset={4}>\n        <StyledRow variant=\"tall\" id=\"TD-Styles-Color-Container\">\n          <span>\n            <FormattedMessage id=\"style.menu.color\" />\n          </span>\n          <ColorGrid>\n            {Object.keys(strokes.light).map((style: string) => (\n              <DropdownMenu.Item\n                key={style}\n                onSelect={preventEvent}\n                asChild\n                id={`TD-Styles-Color-Swatch-${style}`}\n              >\n                <ToolButton\n                  variant=\"icon\"\n                  isActive={displayedStyle.color === style}\n                  onClick={() => app.style({ color: style as ColorStyle })}\n                  aria-label={intl.formatMessage({ id: style })}\n                >\n                  <CircleIcon\n                    size={18}\n                    strokeWidth={2.5}\n                    fill={\n                      displayedStyle.isFilled ? fills[theme][style as ColorStyle] : 'transparent'\n                    }\n                    stroke={strokes.light[style as ColorStyle]}\n                  />\n                </ToolButton>\n              </DropdownMenu.Item>\n            ))}\n          </ColorGrid>\n        </StyledRow>\n        <DMCheckboxItem\n          variant=\"styleMenu\"\n          checked={!!displayedStyle.isFilled}\n          onCheckedChange={handleToggleFilled}\n          id=\"TD-Styles-Fill\"\n        >\n          <FormattedMessage id=\"style.menu.fill\" />\n        </DMCheckboxItem>\n        <StyledRow id=\"TD-Styles-Dash-Container\">\n          <FormattedMessage id=\"style.menu.dash\" />\n          <StyledGroup dir=\"ltr\" value={displayedStyle.dash} onValueChange={handleDashChange}>\n            {Object.values(DashStyle).map((style) => (\n              <DMRadioItem\n                key={style}\n                isActive={style === displayedStyle.dash}\n                value={style}\n                onSelect={preventEvent}\n                bp={breakpoints}\n                id={`TD-Styles-Dash-${style}`}\n                aria-label={intl.formatMessage({ id: style })}\n              >\n                {DASH_ICONS[style as DashStyle]}\n              </DMRadioItem>\n            ))}\n          </StyledGroup>\n        </StyledRow>\n        <StyledRow id=\"TD-Styles-Size-Container\">\n          <FormattedMessage id=\"style.menu.size\" />\n          <StyledGroup dir=\"ltr\" value={displayedStyle.size} onValueChange={handleSizeChange}>\n            {Object.values(SizeStyle).map((sizeStyle) => (\n              <DMRadioItem\n                key={sizeStyle}\n                isActive={sizeStyle === displayedStyle.size}\n                value={sizeStyle}\n                onSelect={preventEvent}\n                bp={breakpoints}\n                id={`TD-Styles-Dash-${sizeStyle}`}\n                aria-label={intl.formatMessage({ id: sizeStyle })}\n              >\n                {SIZE_ICONS[sizeStyle as SizeStyle]}\n              </DMRadioItem>\n            ))}\n          </StyledGroup>\n        </StyledRow>\n        {(options === 'text' || options === 'label') && (\n          <>\n            <Divider />\n            <StyledRow id=\"TD-Styles-Font-Container\">\n              <FormattedMessage id=\"style.menu.font\" />\n              <StyledGroup dir=\"ltr\" value={displayedStyle.font} onValueChange={handleFontChange}>\n                {Object.values(FontStyle).map((fontStyle) => (\n                  <DMRadioItem\n                    key={fontStyle}\n                    isActive={fontStyle === displayedStyle.font}\n                    value={fontStyle}\n                    onSelect={preventEvent}\n                    bp={breakpoints}\n                    id={`TD-Styles-Font-${fontStyle}`}\n                  >\n                    <FontIcon fontStyle={fontStyle}>Aa</FontIcon>\n                  </DMRadioItem>\n                ))}\n              </StyledGroup>\n            </StyledRow>\n            {options === 'text' && (\n              <StyledRow id=\"TD-Styles-Align-Container\">\n                <FormattedMessage id=\"style.menu.align\" />\n                <StyledGroup\n                  dir=\"ltr\"\n                  value={displayedStyle.textAlign}\n                  onValueChange={handleTextAlignChange}\n                >\n                  {Object.values(AlignStyle).map((style) => (\n                    <DMRadioItem\n                      key={style}\n                      isActive={style === displayedStyle.textAlign}\n                      value={style}\n                      onSelect={preventEvent}\n                      bp={breakpoints}\n                      id={`TD-Styles-Align-${style}`}\n                    >\n                      {ALIGN_ICONS[style]}\n                    </DMRadioItem>\n                  ))}\n                </StyledGroup>\n              </StyledRow>\n            )}\n          </>\n        )}\n        <Divider />\n        <DMCheckboxItem\n          variant=\"styleMenu\"\n          checked={keepOpen}\n          onCheckedChange={handleToggleKeepOpen}\n          id=\"TD-Styles-Keep-Open\"\n        >\n          <FormattedMessage id=\"style.menu.keep.open\" />\n        </DMCheckboxItem>\n      </DMContent>\n    </DropdownMenu.Root>\n  )\n})\n\nconst ColorGrid = styled('div', {\n  display: 'grid',\n  gridTemplateColumns: 'repeat(4, auto)',\n  gap: 0,\n})\n\nexport const StyledRow = styled('div', {\n  position: 'relative',\n  width: '100%',\n  background: 'none',\n  border: 'none',\n  cursor: 'pointer',\n  minHeight: '32px',\n  outline: 'none',\n  color: '$text',\n  fontFamily: '$ui',\n  fontWeight: 400,\n  fontSize: '$1',\n  padding: '$2 0 $2 $3',\n  borderRadius: 4,\n  userSelect: 'none',\n  margin: 0,\n  display: 'flex',\n  gap: '$3',\n  flexDirection: 'row',\n  alignItems: 'center',\n  justifyContent: 'space-between',\n  variants: {\n    variant: {\n      tall: {\n        alignItems: 'flex-start',\n        padding: '0 0 0 $3',\n        '& > span': {\n          paddingTop: '$4',\n        },\n      },\n    },\n  },\n})\n\nconst StyledGroup = styled(DropdownMenu.DropdownMenuRadioGroup, {\n  display: 'flex',\n  flexDirection: 'row',\n  gap: '$1',\n})\n\nconst OverlapIcons = styled('div', {\n  display: 'grid',\n  '& > *': {\n    gridColumn: 1,\n    gridRow: 1,\n  },\n})\n\nconst FontIcon = styled('div', {\n  width: 32,\n  height: 32,\n  display: 'flex',\n  alignItems: 'center',\n  justifyContent: 'center',\n  fontSize: '$3',\n  variants: {\n    fontStyle: {\n      [FontStyle.Script]: {\n        fontFamily: 'Caveat Brush',\n      },\n      [FontStyle.Sans]: {\n        fontFamily: 'Recursive',\n      },\n      [FontStyle.Serif]: {\n        fontFamily: 'Georgia',\n      },\n      [FontStyle.Mono]: {\n        fontFamily: 'Recursive Mono',\n      },\n    },\n  },\n})\n", "import * as DropdownMenu from '@radix-ui/react-dropdown-menu'\nimport * as React from 'react'\nimport { FormattedMessage } from 'react-intl'\nimport { DMContent, DMItem } from '~components/Primitives/DropdownMenu'\nimport { ToolButton } from '~components/Primitives/ToolButton'\nimport { preventEvent } from '~components/preventEvent'\nimport { useTldrawApp } from '~hooks'\nimport { styled } from '~styles'\nimport type { TDSnapshot } from '~types'\n\nconst zoomSelector = (s: TDSnapshot) => s.document.pageStates[s.appState.currentPageId].camera.zoom\n\nexport const ZoomMenu = function ZoomMenu() {\n  const app = useTldrawApp()\n\n  const zoom = app.useStore(zoomSelector)\n\n  return (\n    <DropdownMenu.Root dir=\"ltr\">\n      <DropdownMenu.Trigger dir=\"ltr\" asChild id=\"TD-Zoom\">\n        <FixedWidthToolButton onDoubleClick={app.resetZoom} variant=\"text\">\n          {Math.round(zoom * 100)}%\n        </FixedWidthToolButton>\n      </DropdownMenu.Trigger>\n      <DMContent align=\"end\">\n        <DMItem onSelect={preventEvent} onClick={app.zoomIn} kbd=\"#+\" id=\"TD-Zoom-Zoom_In\">\n          <FormattedMessage id=\"zoom.in\" />\n        </DMItem>\n        <DMItem onSelect={preventEvent} onClick={app.zoomOut} kbd=\"#\u2212\" id=\"TD-Zoom-Zoom_Out\">\n          <FormattedMessage id=\"zoom.out\" />\n        </DMItem>\n        <DMItem onSelect={preventEvent} onClick={app.resetZoom} kbd=\"\u21E70\" id=\"TD-Zoom-Zoom_To_100%\">\n          <FormattedMessage id=\"zoom.to\" /> 100%\n        </DMItem>\n        <DMItem onSelect={preventEvent} onClick={app.zoomToFit} kbd=\"\u21E71\" id=\"TD-Zoom-To_Fit\">\n          <FormattedMessage id=\"zoom.to.fit\" />\n        </DMItem>\n        <DMItem\n          onSelect={preventEvent}\n          onClick={app.zoomToSelection}\n          kbd=\"\u21E72\"\n          id=\"TD-Zoom-To_Selection\"\n        >\n          <FormattedMessage id=\"zoom.to.selection\" />\n        </DMItem>\n      </DMContent>\n    </DropdownMenu.Root>\n  )\n}\n\nconst FixedWidthToolButton = styled(ToolButton, {\n  minWidth: 56,\n})\n", "import React, { RefObject } from 'react'\n\nexport function useCursor(ref: RefObject<HTMLDivElement>) {\n  React.useEffect(() => {\n    let isPointing = false\n    let isSpacePanning = false\n\n    const elm = ref.current\n    if (!elm) return\n\n    const onKeyDown = (e: KeyboardEvent) => {\n      if (e.key === ' ' && !isSpacePanning) {\n        isSpacePanning = true\n\n        if (isPointing) {\n          elm.setAttribute('style', 'cursor: grabbing !important')\n        } else {\n          elm.setAttribute('style', 'cursor: grab !important')\n        }\n      }\n    }\n\n    const onKeyUp = (e: KeyboardEvent) => {\n      if (e.key === ' ') {\n        isSpacePanning = false\n        elm.setAttribute('style', 'cursor: initial')\n      }\n    }\n\n    const onPointerDown = (e: PointerEvent) => {\n      isPointing = true\n\n      // On middle mouse down\n      if (e.button === 1) {\n        elm.setAttribute('style', 'cursor: grabbing !important')\n      }\n\n      // On left mouse down\n      if (e.button === 0) {\n        if (isSpacePanning) {\n          elm.setAttribute('style', 'cursor: grabbing !important')\n        }\n      }\n    }\n\n    const onPointerUp = () => {\n      isPointing = false\n\n      if (isSpacePanning) {\n        elm.setAttribute('style', 'cursor: grab !important')\n      } else {\n        elm.setAttribute('style', 'cursor: initial')\n      }\n    }\n\n    elm.addEventListener('keydown', onKeyDown)\n    elm.addEventListener('keyup', onKeyUp)\n    elm.addEventListener('pointerdown', onPointerDown)\n    elm.addEventListener('pointerup', onPointerUp)\n\n    return () => {\n      elm.removeEventListener('keydown', onKeyDown)\n      elm.removeEventListener('keyup', onKeyUp)\n      elm.removeEventListener('pointerdown', onPointerDown)\n      elm.removeEventListener('pointerup', onPointerUp)\n    }\n  }, [ref.current])\n}\n", "import {\n  TLBounds,\n  TLBoundsEventHandler,\n  TLBoundsHandleEventHandler,\n  TLCanvasEventHandler,\n  TLDropEventHandler,\n  TLKeyboardEventHandler,\n  TLPageState,\n  TLPinchEventHandler,\n  TLPointerEventHandler,\n  TLShape,\n  TLShapeCloneHandler,\n  TLWheelEventHandler,\n  Utils,\n} from '@tldraw/core'\nimport { Vec } from '@tldraw/vec'\nimport {\n  FIT_TO_SCREEN_PADDING,\n  GRID_SIZE,\n  IMAGE_EXTENSIONS,\n  SVG_EXPORT_PADDING,\n  USER_COLORS,\n  VIDEO_EXTENSIONS,\n  isLinux,\n} from '~constants'\nimport { DialogState } from '~hooks'\nimport { shapeUtils } from '~state/shapes'\nimport { defaultStyle } from '~state/shapes/shared'\nimport {\n  AlignStyle,\n  AlignType,\n  ArrowShape,\n  DistributeType,\n  FlipType,\n  GroupShape,\n  MoveType,\n  SessionType,\n  ShapeStyles,\n  StretchType,\n  TDAsset,\n  TDAssetType,\n  TDAssets,\n  TDBinding,\n  TDDocument,\n  TDExport,\n  TDExportBackground,\n  TDExportType,\n  TDPage,\n  TDShape,\n  TDShapeType,\n  TDSnapshot,\n  TDStatus,\n  TDToolType,\n  TDUser,\n  TldrawCommand,\n  TldrawPatch,\n} from '~types'\nimport { getClipboard, setClipboard } from './IdbClipboard'\nimport { StateManager } from './StateManager'\nimport { deepCopy } from './StateManager/copy'\nimport { TLDR } from './TLDR'\nimport * as Commands from './commands'\nimport {\n  fileToBase64,\n  fileToText,\n  getImageSizeFromSrc,\n  getVideoSizeFromSrc,\n  loadFileHandle,\n  migrate,\n  openAssetsFromFileSystem,\n  openFromFileSystem,\n  saveToFileSystem,\n} from './data'\nimport { SessionArgsOfType, TldrawSession, getSession } from './sessions'\nimport { clearPrevSize } from './shapes/shared/getTextSize'\nimport { ArrowTool } from './tools/ArrowTool'\nimport type { BaseTool } from './tools/BaseTool'\nimport { DrawTool } from './tools/DrawTool'\nimport { EllipseTool } from './tools/EllipseTool'\nimport { EraseTool } from './tools/EraseTool'\nimport { LineTool } from './tools/LineTool'\nimport { RectangleTool } from './tools/RectangleTool'\nimport { SelectTool } from './tools/SelectTool'\nimport { StickyTool } from './tools/StickyTool'\nimport { TextTool } from './tools/TextTool'\nimport { TriangleTool } from './tools/TriangleTool'\n\nconst uuid = Utils.uniqueId()\n\nexport interface TDCallbacks {\n  /**\n   * (optional) A callback to run when the component mounts.\n   */\n  onMount?: (app: TldrawApp) => void\n  /**\n   * (optional) A callback to run when the component's state changes.\n   */\n  onChange?: (app: TldrawApp, reason?: string) => void\n  /**\n   * (optional) A callback to run when the user creates a new project through the menu or through a keyboard shortcut.\n   */\n  onNewProject?: (\n    app: TldrawApp,\n    openDialog: (\n      dialogState: DialogState,\n      onYes: () => void,\n      onNo: () => void,\n      onCancel: () => void\n    ) => void,\n    e?: KeyboardEvent\n  ) => void\n  /**\n   * (optional) A callback to run when the user saves a project through the menu or through a keyboard shortcut.\n   */\n  onSaveProject?: (app: TldrawApp, e?: KeyboardEvent) => void\n  /**\n   * (optional) A callback to run when the user saves a project as a new project through the menu or through a keyboard shortcut.\n   */\n  onSaveProjectAs?: (app: TldrawApp, e?: KeyboardEvent) => void\n  /**\n   * (optional) A callback to run when the user opens new project through the menu or through a keyboard shortcut.\n   */\n  onOpenProject?: (\n    app: TldrawApp,\n    openDialog: (\n      dialogState: DialogState,\n      onYes: () => void,\n      onNo: () => void,\n      onCancel: () => void\n    ) => void,\n    e?: KeyboardEvent\n  ) => void\n  /**\n   * (optional) A callback to run when the opens a file to upload.\n   */\n  onOpenMedia?: (app: TldrawApp) => void\n  /**\n   * (optional) A callback to run when the state is patched.\n   */\n  onPatch?: (app: TldrawApp, patch: TldrawPatch, reason?: string) => void\n  /**\n   * (optional) A callback to run when the state is changed with a command.\n   */\n  onCommand?: (app: TldrawApp, command: TldrawCommand, reason?: string) => void\n  /**\n   * (optional) A callback to run when the state is persisted.\n   */\n  onPersist?: (app: TldrawApp) => void\n  /**\n   * (optional) A callback to run when the user undos.\n   */\n  onUndo?: (app: TldrawApp) => void\n  /**\n   * (optional) A callback to run when the user redos.\n   */\n  onRedo?: (app: TldrawApp) => void\n  /**\n   * (optional) A callback to run when the user changes the current page's shapes.\n   */\n  onChangePage?: (\n    app: TldrawApp,\n    shapes: Record<string, TDShape | undefined>,\n    bindings: Record<string, TDBinding | undefined>,\n    assets: Record<string, TDAsset | undefined>,\n    addToHistory: boolean\n  ) => void\n  /**\n   * (optional) A callback to run when the user creates a new project.\n   */\n  onChangePresence?: (app: TldrawApp, user: TDUser) => void\n  /**\n   * (optional) A callback to run when an asset will be deleted.\n   */\n  onAssetDelete?: (app: TldrawApp, assetId: string) => void\n  /**\n   * (optional) A callback to run when an asset will be created. Should return the value for the image/video's `src` property.\n   */\n  onAssetCreate?: (app: TldrawApp, file: File, id: string) => Promise<string | false>\n  /**\n   * (optional) A callback to run when an asset will be uploaded. Should return the value for the image/video's `src` property.\n   */\n  onAssetUpload?: (app: TldrawApp, file: File, id: string) => Promise<string | false>\n  /**\n   * (optional) A callback to run when the user exports their page or selection.\n   */\n  onExport?: (app: TldrawApp, info: TDExport) => Promise<void>\n  /**\n   * (optional) A callback to run when a session begins.\n   */\n  onSessionStart?: (app: TldrawApp, id: string) => void\n  /**\n   * (optional) A callback to run when a session ends.\n   */\n  onSessionEnd?: (app: TldrawApp, id: string) => void\n}\n\nexport class TldrawApp extends StateManager<TDSnapshot> {\n  callbacks: TDCallbacks = {}\n\n  tools = {\n    select: new SelectTool(this),\n    erase: new EraseTool(this),\n    [TDShapeType.Text]: new TextTool(this),\n    [TDShapeType.Draw]: new DrawTool(this),\n    [TDShapeType.Ellipse]: new EllipseTool(this),\n    [TDShapeType.Rectangle]: new RectangleTool(this),\n    [TDShapeType.Triangle]: new TriangleTool(this),\n    [TDShapeType.Line]: new LineTool(this),\n    [TDShapeType.Arrow]: new ArrowTool(this),\n    [TDShapeType.Sticky]: new StickyTool(this),\n  }\n\n  currentTool: BaseTool = this.tools.select\n\n  session?: TldrawSession\n\n  readOnly = false\n\n  isDirty = false\n\n  isCreating = false\n\n  originPoint = [0, 0]\n\n  currentPoint = [0, 0]\n\n  previousPoint = [0, 0]\n\n  shiftKey = false\n\n  altKey = false\n\n  metaKey = false\n\n  ctrlKey = false\n\n  spaceKey = false\n\n  isPointing = false\n\n  isForcePanning = false\n\n  isErasingWithPen = false\n\n  isPastePrevented = false\n\n  editingStartTime = -1\n\n  fileSystemHandle: FileSystemFileHandle | null = null\n\n  viewport = Utils.getBoundsFromPoints([\n    [0, 0],\n    [100, 100],\n  ])\n\n  rendererBounds = Utils.getBoundsFromPoints([\n    [0, 0],\n    [100, 100],\n  ])\n\n  selectHistory = {\n    stack: [[]] as string[][],\n    pointer: 0,\n  }\n\n  clipboard?: {\n    shapes: TDShape[]\n    bindings: TDBinding[]\n    assets: TDAsset[]\n  }\n\n  rotationInfo = {\n    selectedIds: [] as string[],\n    center: [0, 0],\n  }\n\n  constructor(id?: string, callbacks = {} as TDCallbacks) {\n    super(TldrawApp.defaultState, id, TldrawApp.version, (prev, next, prevVersion) => {\n      return migrate(\n        {\n          ...next,\n          document: { ...next.document, ...prev.document, version: prevVersion },\n        },\n        TldrawApp.version\n      )\n    })\n\n    this.callbacks = callbacks\n  }\n\n  /* -------------------- Internal -------------------- */\n\n  protected migrate = (state: TDSnapshot): TDSnapshot => {\n    return migrate(state, TldrawApp.version)\n  }\n\n  protected onReady = () => {\n    this.loadDocument(this.document)\n\n    loadFileHandle().then((fileHandle) => {\n      this.fileSystemHandle = fileHandle\n    })\n\n    try {\n      this.patchState({\n        ...migrate(this.state, TldrawApp.version),\n        appState: {\n          status: TDStatus.Idle,\n        },\n      })\n    } catch (e) {\n      console.error('The data appears to be corrupted. Resetting!', e)\n      localStorage.setItem(this.document.id + '_corrupted', JSON.stringify(this.document))\n\n      this.patchState({\n        ...TldrawApp.defaultState,\n        appState: {\n          ...TldrawApp.defaultState.appState,\n          status: TDStatus.Idle,\n        },\n      })\n    }\n\n    this.callbacks.onMount?.(this)\n  }\n\n  /**\n   * Cleanup the state after each state change.\n   * @param state The new state\n   * @param prev The previous state\n   * @protected\n   * @returns The final state\n   */\n  protected cleanup = (state: TDSnapshot, prev: TDSnapshot): TDSnapshot => {\n    const next: TDSnapshot = { ...state }\n\n    // Remove deleted shapes and bindings (in Commands, these will be set to undefined)\n    if (next.document !== prev.document) {\n      Object.entries(next.document.pages).forEach(([pageId, page]) => {\n        if (page === undefined) {\n          // If page is undefined, delete the page and pagestate\n          delete next.document.pages[pageId]\n          delete next.document.pageStates[pageId]\n          return\n        }\n\n        const prevPage = prev.document.pages[pageId]\n\n        const changedShapes: Record<string, TDShape | undefined> = {}\n\n        if (!prevPage || page.shapes !== prevPage.shapes || page.bindings !== prevPage.bindings) {\n          page.shapes = { ...page.shapes }\n          page.bindings = { ...page.bindings }\n\n          const groupsToUpdate = new Set<GroupShape>()\n\n          // If shape is undefined, delete the shape\n          Object.entries(page.shapes).forEach(([id, shape]) => {\n            let parentId: string\n\n            if (!shape) {\n              parentId = prevPage?.shapes[id]?.parentId\n              delete page.shapes[id]\n            } else {\n              parentId = shape.parentId\n            }\n\n            if (page.id === next.appState.currentPageId) {\n              if (prevPage?.shapes[id] !== shape) {\n                changedShapes[id] = shape\n              }\n            }\n\n            // If the shape is the child of a group, then update the group\n            // (unless the group is being deleted too)\n            if (parentId && parentId !== pageId) {\n              const group = page.shapes[parentId]\n              if (group !== undefined) {\n                groupsToUpdate.add(page.shapes[parentId] as GroupShape)\n              }\n            }\n          })\n\n          // If binding is undefined, delete the binding\n          Object.keys(page.bindings).forEach((id) => {\n            if (!page.bindings[id]) {\n              delete page.bindings[id]\n            }\n          })\n\n          next.document.pages[pageId] = page\n\n          // Get bindings related to the changed shapes\n          const bindingsToUpdate = TLDR.getRelatedBindings(next, Object.keys(changedShapes), pageId)\n\n          const visitedShapes = new Set<ArrowShape>()\n\n          // Update all of the bindings we've just collected\n          bindingsToUpdate.forEach((binding) => {\n            if (!page.bindings[binding.id]) {\n              return\n            }\n\n            const toShape = page.shapes[binding.toId]\n            const fromShape = page.shapes[binding.fromId] as ArrowShape\n\n            if (!(toShape && fromShape)) {\n              delete next.document.pages[pageId].bindings[binding.id]\n              return\n            }\n\n            if (visitedShapes.has(fromShape)) {\n              return\n            }\n            // We only need to update the binding's \"from\" shape (an arrow)\n            const fromDelta = TLDR.updateArrowBindings(page, fromShape)\n            visitedShapes.add(fromShape)\n\n            if (fromDelta) {\n              const nextShape = {\n                ...fromShape,\n                ...fromDelta,\n              } as ArrowShape\n              page.shapes[fromShape.id] = nextShape\n            }\n          })\n\n          groupsToUpdate.forEach((group) => {\n            if (!group) throw Error('no group!')\n            const children = group.children.filter((id) => page.shapes[id] !== undefined)\n\n            const commonBounds = Utils.getCommonBounds(\n              children\n                .map((id) => page.shapes[id])\n                .filter(Boolean)\n                .map((shape) => TLDR.getRotatedBounds(shape))\n            )\n\n            page.shapes[group.id] = {\n              ...group,\n              point: [commonBounds.minX, commonBounds.minY],\n              size: [commonBounds.width, commonBounds.height],\n              children,\n            }\n          })\n        }\n\n        // Clean up page state, preventing hovers on deleted shapes\n\n        const nextPageState: TLPageState = {\n          ...next.document.pageStates[pageId],\n        }\n\n        if (!nextPageState.brush) {\n          delete nextPageState.brush\n        }\n\n        if (nextPageState.hoveredId && !page.shapes[nextPageState.hoveredId]) {\n          delete nextPageState.hoveredId\n        }\n\n        if (nextPageState.bindingId && !page.bindings[nextPageState.bindingId]) {\n          TLDR.warn(`Could not find the binding of ${pageId}`)\n          delete nextPageState.bindingId\n        }\n\n        if (nextPageState.editingId && !page.shapes[nextPageState.editingId]) {\n          TLDR.warn('Could not find the editing shape!')\n          delete nextPageState.editingId\n        }\n\n        next.document.pageStates[pageId] = nextPageState\n      })\n    }\n\n    Object.keys(next.document.assets ?? {}).forEach((id) => {\n      if (!next.document.assets?.[id]) {\n        delete next.document.assets?.[id]\n      }\n    })\n\n    const currentPageId = next.appState.currentPageId\n\n    const currentPageState = next.document.pageStates[currentPageId]\n\n    if (next.room && next.room !== prev.room) {\n      const room = { ...next.room, users: { ...next.room.users } }\n\n      // Remove any exited users\n      if (prev.room) {\n        Object.values(prev.room.users)\n          .filter(Boolean)\n          .forEach((user) => {\n            if (room.users[user.id] === undefined) {\n              delete room.users[user.id]\n            }\n          })\n      }\n\n      next.room = room\n    }\n\n    if (next.room) {\n      next.room.users[next.room.userId] = {\n        ...next.room.users[next.room.userId],\n        point: this.currentPoint,\n        selectedIds: currentPageState.selectedIds,\n      }\n    }\n\n    // Temporary block on editing pages while in readonly mode.\n    // This is a broad solution but not a very good one: the UX\n    // for interacting with a readOnly document will be more nuanced.\n    if (this.readOnly) {\n      next.document.pages = prev.document.pages\n    }\n\n    return next\n  }\n\n  private broadcastPatch = (patch: TldrawPatch, addToHistory: boolean) => {\n    const changedShapes: Record<string, TDShape | undefined> = {}\n    const changedBindings: Record<string, TDBinding | undefined> = {}\n    const changedAssets: Record<string, TDAsset | undefined> = {}\n\n    const shapes = patch?.document?.pages?.[this.currentPageId]?.shapes\n    const bindings = patch?.document?.pages?.[this.currentPageId]?.bindings\n    const assets = patch?.document?.assets\n\n    if (shapes) {\n      Object.keys(shapes).forEach((id) => {\n        changedShapes[id!] = this.getShape(id, this.currentPageId)\n      })\n    }\n\n    if (bindings) {\n      Object.keys(bindings).forEach((id) => {\n        changedBindings[id] = this.getBinding(id, this.currentPageId)\n      })\n    }\n\n    if (assets) {\n      Object.keys(assets).forEach((id) => {\n        changedAssets[id] = this.document.assets[id]\n      })\n    }\n\n    this.callbacks.onChangePage?.(this, changedShapes, changedBindings, changedAssets, addToHistory)\n  }\n\n  onPatch = (state: TDSnapshot, patch: TldrawPatch, id?: string) => {\n    if (\n      (this.callbacks.onChangePage && patch?.document?.pages?.[this.currentPageId]) ||\n      patch?.document?.assets\n    ) {\n      if (\n        patch?.document?.assets ||\n        (this.session &&\n          this.session.type !== SessionType.Brush &&\n          this.session.type !== SessionType.Erase &&\n          this.session.type !== SessionType.Draw)\n      ) {\n        this.broadcastPatch(patch, false)\n      }\n    }\n\n    this.callbacks.onPatch?.(this, patch, id)\n  }\n\n  onCommand = (state: TDSnapshot, command: TldrawCommand, id?: string) => {\n    this.clearSelectHistory()\n    this.isDirty = true\n    this.callbacks.onCommand?.(this, command, id)\n  }\n\n  onReplace = () => {\n    this.clearSelectHistory()\n    this.isDirty = false\n  }\n\n  onUndo = () => {\n    this.rotationInfo.selectedIds = [...this.selectedIds]\n    this.callbacks.onUndo?.(this)\n  }\n\n  onRedo = () => {\n    this.rotationInfo.selectedIds = [...this.selectedIds]\n    this.callbacks.onRedo?.(this)\n  }\n\n  onPersist = (state: TDSnapshot, patch: TldrawPatch) => {\n    // If we are part of a room, send our changes to the server\n\n    this.callbacks.onPersist?.(this)\n    this.broadcastPatch(patch, true)\n  }\n\n  private prevSelectedIds = this.selectedIds\n\n  /**\n   * Clear the selection history after each new command, undo or redo.\n   * @param state\n   * @param id\n   */\n  protected onStateDidChange = (_state: TDSnapshot, id?: string): void => {\n    this.callbacks.onChange?.(this, id)\n\n    if (this.room && this.selectedIds !== this.prevSelectedIds) {\n      this.callbacks.onChangePresence?.(this, {\n        ...this.room.users[this.room.userId],\n        selectedIds: this.selectedIds,\n        session: !!this.session,\n      })\n      this.prevSelectedIds = this.selectedIds\n    }\n  }\n\n  private preventPaste = () => {\n    if (this.isPastePrevented) return\n\n    const prevent = (event: ClipboardEvent) => event.stopImmediatePropagation()\n\n    const enable = () => {\n      setTimeout(() => {\n        document.removeEventListener('paste', prevent, { capture: true })\n        this.isPastePrevented = false\n      }, 50)\n    }\n\n    document.addEventListener('paste', prevent, { capture: true })\n    window.addEventListener('pointerup', enable, { once: true })\n    this.isPastePrevented = true\n  }\n\n  /* ----------- Managing Multiplayer State ----------- */\n\n  private justSent = false\n\n  getReservedContent = (coreReservedIds: string[], pageId = this.currentPageId) => {\n    const { bindings } = this.document.pages[pageId]\n\n    // We want to know which shapes we need to\n    const reservedShapes: Record<string, TDShape> = {}\n    const reservedBindings: Record<string, TDBinding> = {}\n\n    // Quick lookup maps for bindings\n    const bindingsArr = Object.values(bindings)\n    const boundTos = new Map(bindingsArr.map((binding) => [binding.toId, binding]))\n    const boundFroms = new Map(bindingsArr.map((binding) => [binding.fromId, binding]))\n    const bindingMaps = [boundTos, boundFroms]\n\n    // Unique set of shape ids that are going to be reserved\n    const reservedShapeIds: string[] = []\n\n    if (this.session) coreReservedIds.forEach((id) => reservedShapeIds.push(id))\n    if (this.pageState.editingId) reservedShapeIds.push(this.pageState.editingId)\n\n    const strongReservedShapeIds = new Set(reservedShapeIds)\n\n    // Which shape ids have we already visited?\n    const visited = new Set<string>()\n\n    // Time to visit every reserved shape and every related shape and binding.\n    while (reservedShapeIds.length > 0) {\n      const id = reservedShapeIds.pop()\n      if (!id) break\n      if (visited.has(id)) continue\n\n      // Add to set so that we don't process this id a second time\n      visited.add(id)\n\n      // Get the shape and reserve it\n      const shape = this.getShape(id)\n      reservedShapes[id] = shape\n\n      if (shape.parentId !== pageId) reservedShapeIds.push(shape.parentId)\n\n      // If the shape has children, add the shape's children to the list of ids to process\n      if (shape.children) reservedShapeIds.push(...shape.children)\n\n      // If there are binding for this shape, reserve the bindings and\n      // add its related shapes to the list of ids to process\n      bindingMaps\n        .map((map) => map.get(shape.id)!)\n        .filter(Boolean)\n        .forEach((binding) => {\n          reservedBindings[binding.id] = binding\n          reservedShapeIds.push(binding.toId, binding.fromId)\n        })\n    }\n\n    return { reservedShapes, reservedBindings, strongReservedShapeIds }\n  }\n\n  /**\n   * Manually patch in page content.\n   */\n  public replacePageContent = (\n    shapes: Record<string, TDShape>,\n    bindings: Record<string, TDBinding>,\n    assets: Record<string, TDAsset>,\n    pageId = this.currentPageId\n  ): this => {\n    if (this.justSent) {\n      // The incoming update was caused by an update that the client sent, noop.\n      this.justSent = false\n      return this\n    }\n\n    const page = this.document.pages[this.currentPageId]\n\n    Object.values(shapes).forEach((shape) => {\n      if (shape.parentId !== pageId && !(page.shapes[shape.parentId] || shapes[shape.parentId])) {\n        console.warn('Added a shape without a parent on the page')\n        shape.parentId = pageId\n      }\n    })\n\n    this.useStore.setState((current) => {\n      const { hoveredId, editingId, bindingId, selectedIds } = current.document.pageStates[pageId]\n\n      const coreReservedIds = [...selectedIds]\n\n      const editingShape = editingId && current.document.pages[this.currentPageId].shapes[editingId]\n      if (editingShape) coreReservedIds.push(editingShape.id)\n\n      const { reservedShapes, reservedBindings, strongReservedShapeIds } = this.getReservedContent(\n        coreReservedIds,\n        this.currentPageId\n      )\n\n      // Merge in certain changes to reserved shapes\n      Object.values(reservedShapes)\n        // Don't merge updates to shapes with text (Text or Sticky)\n        .filter((reservedShape) => !('text' in reservedShape))\n        .forEach((reservedShape) => {\n          const incomingShape = shapes[reservedShape.id]\n          if (!incomingShape) return\n\n          // If the shape isn't \"strongly reserved\", then use the incoming shape;\n          // note that this is only if the incoming shape exists! If the shape was\n          // deleted in the incoming shapes, then we'll keep out reserved shape.\n          // This logic would need more work for arrows, because the incoming shape\n          // include a binding change that we'll need to resolve with our reserved bindings.\n          if (\n            !(\n              reservedShape.type === TDShapeType.Arrow ||\n              strongReservedShapeIds.has(reservedShape.id)\n            )\n          ) {\n            shapes[reservedShape.id] = incomingShape\n            return\n          }\n\n          // Only allow certain merges.\n\n          // Allow decorations (of an arrow) to be changed\n          if ('decorations' in incomingShape && 'decorations' in reservedShape) {\n            shapes[reservedShape.id] = { ...reservedShape, decorations: incomingShape.decorations }\n          }\n\n          // Allow the shape's style to be changed\n          reservedShape.style = incomingShape.style\n        })\n\n      // Use the incoming shapes / bindings as comparisons for what\n      // will have changed. This is important because we want to restore\n      // related shapes that may not have changed on our side, but which\n      // were deleted on the server.\n\n      const nextShapes = {\n        ...shapes,\n        ...reservedShapes,\n      }\n\n      if (editingShape) {\n        nextShapes[editingShape.id] = editingShape\n      }\n\n      const nextBindings = {\n        ...bindings,\n        ...reservedBindings,\n      }\n      const nextAssets = {\n        ...assets,\n      }\n\n      const next: TDSnapshot = {\n        ...current,\n        document: {\n          ...current.document,\n          pages: {\n            [pageId]: {\n              ...current.document.pages[pageId],\n              shapes: nextShapes,\n              bindings: nextBindings,\n            },\n          },\n          assets: nextAssets,\n          pageStates: {\n            ...current.document.pageStates,\n            [pageId]: {\n              ...current.document.pageStates[pageId],\n              selectedIds: selectedIds.filter((id) => nextShapes[id] !== undefined),\n              hoveredId: hoveredId\n                ? nextShapes[hoveredId] === undefined\n                  ? undefined\n                  : hoveredId\n                : undefined,\n              editingId: editingId,\n              bindingId: bindingId\n                ? nextBindings[bindingId] === undefined\n                  ? undefined\n                  : bindingId\n                : undefined,\n            },\n          },\n        },\n      }\n      const page = next.document.pages[pageId]\n\n      // Get bindings related to the changed shapes\n      const bindingsToUpdate = TLDR.getRelatedBindings(next, Object.keys(nextShapes), pageId)\n\n      const visitedShapes = new Set<ArrowShape>()\n\n      // Update all of the bindings we've just collected\n      bindingsToUpdate.forEach((binding) => {\n        if (!page.bindings[binding.id]) {\n          return\n        }\n\n        const fromShape = page.shapes[binding.fromId] as ArrowShape\n\n        if (visitedShapes.has(fromShape)) {\n          return\n        }\n\n        // We only need to update the binding's \"from\" shape (an arrow)\n        const fromDelta = TLDR.updateArrowBindings(page, fromShape)\n        visitedShapes.add(fromShape)\n\n        if (fromDelta) {\n          const nextShape = {\n            ...fromShape,\n            ...fromDelta,\n          } as TDShape\n\n          page.shapes[fromShape.id] = nextShape\n        }\n      })\n\n      Object.values(nextShapes).forEach((shape) => {\n        if (shape.type !== TDShapeType.Group) return\n\n        const children = shape.children.filter((id) => page.shapes[id] !== undefined)\n\n        const commonBounds = Utils.getCommonBounds(\n          children\n            .map((id) => page.shapes[id])\n            .filter(Boolean)\n            .map((shape) => TLDR.getRotatedBounds(shape))\n        )\n\n        page.shapes[shape.id] = {\n          ...shape,\n          point: [commonBounds.minX, commonBounds.minY],\n          size: [commonBounds.width, commonBounds.height],\n          children,\n        }\n      })\n\n      this.state.document = next.document\n\n      return next\n    }, true)\n\n    return this\n  }\n\n  /**\n   * Set the current status.\n   * @param status The new status to set.\n   * @private\n   * @returns\n   */\n  setStatus(status: string) {\n    return this.patchState(\n      {\n        appState: { status },\n      },\n      `set_status:${status}`\n    )\n  }\n\n  /**\n   * Update the bounding box when the renderer's bounds change.\n   * @param bounds\n   */\n  updateBounds = (bounds: TLBounds) => {\n    this.rendererBounds = bounds\n    const { point, zoom } = this.camera\n    this.updateViewport(point, zoom)\n\n    if (!this.readOnly && this.session) {\n      this.session.update()\n    }\n  }\n\n  updateViewport = (point: number[], zoom: number) => {\n    const { width, height } = this.rendererBounds\n    const [minX, minY] = Vec.sub(Vec.div([0, 0], zoom), point)\n    const [maxX, maxY] = Vec.sub(Vec.div([width, height], zoom), point)\n\n    this.viewport = {\n      minX,\n      minY,\n      maxX,\n      maxY,\n      width: maxX - minX,\n      height: maxY - minY,\n    }\n  }\n\n  /**\n   * Set or clear the editing id\n   * @param id [string]\n   */\n  setEditingId = (id?: string, isCreating = false) => {\n    if (this.readOnly) return\n\n    if (id) {\n      // Start a new editing session\n      this.startSession(SessionType.Edit, id, isCreating)\n    } else {\n      // If we're clearing the editing id and we don't have one, bail\n      if (!this.pageState.editingId) return\n\n      // If we're clearing the editing id and we do have one, complete the session\n      this.completeSession()\n    }\n\n    this.editingStartTime = performance.now()\n\n    this.patchState(\n      {\n        document: {\n          pageStates: {\n            [this.currentPageId]: {\n              editingId: id,\n            },\n          },\n        },\n      },\n      `set_editing_id`\n    )\n  }\n\n  /**\n   * Set or clear the hovered id\n   * @param id [string]\n   */\n  setHoveredId = (id?: string) => {\n    this.patchState(\n      {\n        document: {\n          pageStates: {\n            [this.currentPageId]: {\n              hoveredId: id,\n            },\n          },\n        },\n      },\n      `set_hovered_id`\n    )\n  }\n\n  /* -------------------------------------------------- */\n  /*                    Settings & UI                   */\n  /* -------------------------------------------------- */\n\n  /**\n   * Set a setting.\n   */\n  setSetting = <T extends keyof TDSnapshot['settings'], V extends TDSnapshot['settings'][T]>(\n    name: T,\n    value: V | ((value: V) => V)\n  ): this => {\n    if (this.session) return this\n\n    const patch = {\n      settings: {\n        [name]: typeof value === 'function' ? value(this.settings[name] as V) : value,\n      },\n    }\n\n    this.patchState(patch, `settings:${name}`)\n\n    this.persist(patch)\n    return this\n  }\n\n  /**\n   * Toggle pen mode.\n   */\n  toggleFocusMode = (): this => {\n    if (this.session) return this\n    const patch = {\n      settings: {\n        isFocusMode: !this.settings.isFocusMode,\n      },\n    }\n\n    this.patchState(patch, `settings:toggled_focus_mode`)\n\n    this.persist(patch)\n    return this\n  }\n\n  /**\n   * Toggle pen mode.\n   */\n  togglePenMode = (): this => {\n    if (this.session) return this\n    const patch = {\n      settings: {\n        isPenMode: !this.settings.isPenMode,\n      },\n    }\n    this.patchState(patch, `settings:toggled_pen_mode`)\n    this.persist(patch)\n    return this\n  }\n\n  /**\n   * Toggle dark mode.\n   */\n  toggleDarkMode = (): this => {\n    if (this.session) return this\n    const patch = { settings: { isDarkMode: !this.settings.isDarkMode } }\n    this.patchState(patch, `settings:toggled_dark_mode`)\n    this.persist(patch)\n    return this\n  }\n\n  /**\n   * Toggle zoom snap.\n   */\n  toggleZoomSnap = () => {\n    if (this.session) return this\n    const patch = { settings: { isZoomSnap: !this.settings.isZoomSnap } }\n    this.patchState(patch, `settings:toggled_zoom_snap`)\n    this.persist(patch)\n    return this\n  }\n\n  /**\n   * Toggle debug mode.\n   */\n  toggleDebugMode = () => {\n    if (this.session) return this\n    const patch = { settings: { isDebugMode: !this.settings.isDebugMode } }\n    this.patchState(patch, `settings:toggled_debug`)\n    this.persist(patch)\n    return this\n  }\n\n  /**\n   * Toggles the state if menu is opened\n   */\n  setMenuOpen = (isOpen: boolean): this => {\n    const patch = { appState: { isMenuOpen: isOpen } }\n    this.patchState(patch, 'ui:toggled_menu_opened')\n    this.persist(patch)\n    return this\n  }\n\n  /**\n   * Toggles the state if something is loading\n   */\n  setIsLoading = (isLoading: boolean): this => {\n    const patch = { appState: { isLoading } }\n    this.patchState(patch, 'ui:toggled_is_loading')\n    this.persist(patch)\n    return this\n  }\n\n  setDisableAssets = (disableAssets: boolean): this => {\n    this.patchState({ appState: { disableAssets } }, 'ui:toggled_disable_images')\n    return this\n  }\n\n  get isMenuOpen(): boolean {\n    return this.appState.isMenuOpen\n  }\n\n  get isLoading(): boolean {\n    return this.appState.isLoading\n  }\n\n  get disableAssets(): boolean {\n    return this.appState.disableAssets\n  }\n\n  /**\n   * Toggle grids.\n   */\n  toggleGrid = (): this => {\n    if (this.session) return this\n    const patch = { settings: { showGrid: !this.settings.showGrid } }\n    this.patchState(patch, 'settings:toggled_grid')\n    this.persist(patch)\n    return this\n  }\n\n  /**\n   * Select a tool.\n   * @param tool The tool to select, or \"select\".\n   */\n  selectTool = (type: TDToolType): this => {\n    if (this.readOnly || this.session) return this\n\n    this.isPointing = false // reset pointer state, in case something weird happened\n\n    const tool = this.tools[type]\n\n    if (tool === this.currentTool) {\n      this.patchState({\n        appState: {\n          isToolLocked: false,\n        },\n      })\n      return this\n    }\n\n    this.currentTool.onExit()\n    tool.previous = this.currentTool.type\n    this.currentTool = tool\n    this.currentTool.onEnter()\n\n    return this.patchState(\n      {\n        appState: {\n          activeTool: type,\n          isToolLocked: false,\n        },\n      },\n      `selected_tool:${type}`\n    )\n  }\n\n  /**\n   * Toggle the tool lock option.\n   */\n  toggleToolLock = (): this => {\n    if (this.session) return this\n    return this.patchState(\n      {\n        appState: {\n          isToolLocked: !this.appState.isToolLocked,\n        },\n      },\n      `toggled_tool_lock`\n    )\n  }\n\n  /* -------------------------------------------------- */\n  /*                      Document                      */\n  /* -------------------------------------------------- */\n\n  /**\n   * Reset the document to a blank state.\n   */\n  resetDocument = (): this => {\n    if (this.session) return this\n    this.session = undefined\n    this.currentTool = this.tools.select\n\n    const doc = TldrawApp.defaultDocument\n\n    // Set the default page name to the localized version of \"Page\"\n    doc.pages['page'].name = 'Page 1'\n\n    this.resetHistory().clearSelectHistory().loadDocument(TldrawApp.defaultDocument).persist({})\n\n    return this\n  }\n\n  /**\n   *\n   * @param document\n   */\n  updateUsers = (users: TDUser[], isOwnUpdate = false) => {\n    this.patchState(\n      {\n        room: {\n          users: Object.fromEntries(users.map((user) => [user.id, user])),\n        },\n      },\n      isOwnUpdate ? 'room:self:update' : 'room:user:update'\n    )\n  }\n\n  removeUser = (userId: string) => {\n    this.patchState({\n      room: {\n        users: {\n          [userId]: undefined,\n        },\n      },\n    })\n  }\n\n  /**\n   * Merge a new document patch into the current document.\n   * @param document\n   */\n  mergeDocument = (document: TDDocument): this => {\n    // If it's a new document, do a full change.\n    if (this.document.id !== document.id) {\n      this.replaceState({\n        ...migrate(\n          {\n            ...this.state,\n            document,\n          },\n          TldrawApp.version\n        ),\n        appState: {\n          ...this.appState,\n          currentPageId: Object.keys(document.pages)[0],\n        },\n      })\n      return this\n    }\n\n    // Have we deleted any pages? If so, drop everything and change\n    // to the first page. This is an edge case.\n    const currentPageStates = { ...this.document.pageStates }\n\n    // Update the app state's current page id if needed\n    const nextAppState = {\n      ...this.appState,\n      currentPageId: document.pages[this.currentPageId]\n        ? this.currentPageId\n        : Object.keys(document.pages)[0],\n      pages: Object.values(document.pages).map((page, i) => ({\n        id: page.id,\n        name: page.name,\n        childIndex: page.childIndex || i,\n      })),\n    }\n\n    // Reset the history (for now)\n    this.resetHistory()\n\n    Object.keys(this.document.pages).forEach((pageId) => {\n      if (!document.pages[pageId]) {\n        if (pageId === this.appState.currentPageId) {\n          this.cancelSession()\n          this.selectNone()\n        }\n\n        currentPageStates[pageId] = undefined as unknown as TLPageState\n      }\n    })\n\n    // Don't allow the selected ids to be deleted during a session\u2014if\n    // they've been removed, put them back in the client's document.\n    if (this.session) {\n      this.selectedIds\n        .filter((id) => !document.pages[this.currentPageId].shapes[id])\n        .forEach((id) => (document.pages[this.currentPageId].shapes[id] = this.page.shapes[id]))\n    }\n\n    // For other pages, remove any selected ids that were deleted.\n    Object.entries(currentPageStates).forEach(([pageId, pageState]) => {\n      pageState.selectedIds = pageState.selectedIds.filter(\n        (id) => !!document.pages[pageId].shapes[id]\n      )\n    })\n\n    // If the user is currently creating a shape (ie drawing), then put that\n    // shape back onto the page for the client.\n    const { editingId } = this.pageState\n\n    if (editingId) {\n      document.pages[this.currentPageId].shapes[editingId] = this.page.shapes[editingId]\n      currentPageStates[this.currentPageId].selectedIds = [editingId]\n    }\n\n    return this.replaceState(\n      {\n        ...migrate(\n          { ...this.state, document: { ...document, pageStates: currentPageStates } },\n          TldrawApp.version\n        ),\n        appState: nextAppState,\n      },\n      'merge'\n    )\n  }\n\n  /**\n   * Update the current document.\n   * @param document\n   */\n  updateDocument = (document: TDDocument, reason = 'updated_document'): this => {\n    const prevState = this.state\n\n    const nextState = {\n      ...prevState,\n      document: {\n        ...prevState.document,\n        assets: document.assets,\n      },\n    }\n\n    if (!document.pages[this.currentPageId]) {\n      nextState.appState = {\n        ...prevState.appState,\n        currentPageId: Object.keys(document.pages)[0],\n      }\n    }\n\n    let i = 1\n\n    for (const nextPage of Object.values(document.pages)) {\n      if (nextPage !== prevState.document.pages[nextPage.id]) {\n        nextState.document.pages[nextPage.id] = nextPage\n\n        if (!nextPage.name) {\n          nextState.document.pages[nextPage.id].name = `Page ${i + 1}`\n          i++\n        }\n      }\n    }\n\n    for (const nextPageState of Object.values(document.pageStates)) {\n      if (nextPageState !== prevState.document.pageStates[nextPageState.id]) {\n        nextState.document.pageStates[nextPageState.id] = nextPageState\n\n        const nextPage = document.pages[nextPageState.id]\n        const keysToCheck = ['bindingId', 'editingId', 'hoveredId', 'pointedId'] as const\n\n        for (const key of keysToCheck) {\n          if (!nextPage.shapes[key]) {\n            nextPageState[key] = undefined\n          }\n        }\n\n        nextPageState.selectedIds = nextPageState.selectedIds.filter(\n          (id) => !!document.pages[nextPage.id].shapes[id]\n        )\n      }\n    }\n\n    return this.replaceState(\n      migrate(nextState, nextState.document.version || 0),\n      `${reason}:${document.id}`\n    )\n  }\n\n  /**\n   * Load a fresh room into the state.\n   * @param roomId\n   */\n  loadRoom = (roomId: string): this => {\n    this.patchState({\n      room: {\n        id: roomId,\n        userId: uuid,\n        users: {\n          [uuid]: {\n            id: uuid,\n            color: USER_COLORS[Math.floor(Math.random() * USER_COLORS.length)],\n            point: [100, 100],\n            selectedIds: [],\n            activeShapes: [],\n          },\n        },\n      },\n    })\n    return this\n  }\n\n  /**\n   * Load a new document.\n   * @param document The document to load\n   */\n  loadDocument = (document: TDDocument): this => {\n    this.setIsLoading(true)\n    this.selectNone()\n    this.resetHistory()\n    this.clearSelectHistory()\n    this.session = undefined\n\n    const state = {\n      ...TldrawApp.defaultState,\n      settings: {\n        ...this.state.settings,\n      },\n      document,\n      appState: {\n        ...TldrawApp.defaultState.appState,\n        ...this.state.appState,\n        currentPageId: Object.keys(document.pages)[0],\n        disableAssets: this.disableAssets,\n      },\n    }\n\n    this.replaceState(migrate(state, TldrawApp.version), 'loaded_document')\n    const { point, zoom } = this.camera\n    this.updateViewport(point, zoom)\n    this.setIsLoading(false)\n    return this\n  }\n\n  /**\n   * load content from URL\n   * @param page\n   * @param pageState\n   * @returns\n   */\n  loadPageFromURL = (page: TDPage, pageState: Record<string, TLPageState>) => {\n    const pageId = page.id\n    const nextDocument = {\n      ...this.state.document,\n      pageStates: {\n        ...this.state.document.pageStates,\n        [pageId]: pageState,\n      },\n      pages: {\n        ...this.document.pages,\n        [pageId]: page,\n      },\n    }\n    this.loadDocument(nextDocument as TDDocument)\n    this.persist({})\n  }\n\n  // Should we move this to the app layer? onSave, onSaveAs, etc?\n\n  /**\n   * Create a new project.\n   */\n  newProject = () => {\n    if (!this.isLocal) return\n    this.fileSystemHandle = null\n    this.resetDocument()\n  }\n\n  /**\n   * Save the current project.\n   */\n  saveProject = async () => {\n    if (this.readOnly) return\n    const fileHandle = await saveToFileSystem(\n      migrate(this.state, TldrawApp.version).document,\n      this.fileSystemHandle\n    )\n    this.fileSystemHandle = fileHandle\n    this.persist({})\n    this.isDirty = false\n    return this\n  }\n\n  /**\n   * Save the current project as a new file.\n   */\n  saveProjectAs = async (filename?: string) => {\n    try {\n      const fileHandle = await saveToFileSystem(this.document, null, filename)\n      this.fileSystemHandle = fileHandle\n      this.persist({})\n      this.isDirty = false\n    } catch (e: any) {\n      // Likely cancelled\n      console.error(e.message)\n    }\n    return this\n  }\n\n  /**\n   * Load a project from the filesystem.\n   * @todo\n   */\n  openProject = async () => {\n    if (!this.isLocal) return\n\n    try {\n      const result = await openFromFileSystem()\n      if (!result) {\n        throw Error()\n      }\n\n      const { fileHandle, document } = result\n      this.loadDocument(document)\n      this.fileSystemHandle = fileHandle\n      this.zoomToFit()\n      this.persist({})\n    } catch (e) {\n      console.error(e)\n    } finally {\n      this.persist({})\n    }\n  }\n\n  /**\n   * Upload media from file\n   */\n  openAsset = async () => {\n    if (!this.disableAssets)\n      try {\n        const file = await openAssetsFromFileSystem()\n        if (Array.isArray(file)) {\n          this.addMediaFromFiles(file, this.centerPoint)\n        } else {\n          if (!file) return\n          this.addMediaFromFiles([file])\n        }\n      } catch (e) {\n        console.error(e)\n      } finally {\n        this.persist({})\n      }\n  }\n\n  /**\n   * Sign out of the current account.\n   * Should move to the www layer.\n   * @todo\n   */\n  signOut = () => {\n    // todo\n  }\n  /* -------------------- Getters --------------------- */\n\n  /**\n   * Get the current app state.\n   */\n  getAppState = (): TDSnapshot['appState'] => {\n    return this.appState\n  }\n\n  /**\n   * Get a page.\n   * @param pageId (optional) The page's id.\n   */\n  getPage = (pageId = this.currentPageId): TDPage => {\n    return TLDR.getPage(this.state, pageId || this.currentPageId)\n  }\n\n  /**\n   * Get the shapes (as an array) from a given page.\n   * @param pageId (optional) The page's id.\n   */\n  getShapes = (pageId = this.currentPageId): TDShape[] => {\n    return TLDR.getShapes(this.state, pageId || this.currentPageId)\n  }\n\n  /**\n   * Get the bindings from a given page.\n   * @param pageId (optional) The page's id.\n   */\n  getBindings = (pageId = this.currentPageId): TDBinding[] => {\n    return TLDR.getBindings(this.state, pageId || this.currentPageId)\n  }\n\n  /**\n   * Get a shape from a given page.\n   * @param id The shape's id.\n   * @param pageId (optional) The page's id.\n   */\n  getShape = <T extends TDShape = TDShape>(id: string, pageId = this.currentPageId): T => {\n    return TLDR.getShape<T>(this.state, id, pageId)\n  }\n\n  /**\n   * Get the bounds of a shape on a given page.\n   * @param id The shape's id.\n   * @param pageId (optional) The page's id.\n   */\n  getShapeBounds = (id: string, pageId = this.currentPageId): TLBounds => {\n    return TLDR.getBounds(this.getShape(id, pageId))\n  }\n\n  /**\n   * Get a binding from a given page.\n   * @param id The binding's id.\n   * @param pageId (optional) The page's id.\n   */\n  getBinding = (id: string, pageId = this.currentPageId): TDBinding => {\n    return TLDR.getBinding(this.state, id, pageId)\n  }\n\n  /**\n   * Get the page state for a given page.\n   * @param pageId (optional) The page's id.\n   */\n  getPageState = (pageId = this.currentPageId): TLPageState => {\n    return TLDR.getPageState(this.state, pageId || this.currentPageId)\n  }\n\n  /**\n   * Turn a screen point into a point on the page.\n   * @param point The screen point\n   * @param pageId (optional) The page to use\n   */\n  getPagePoint = (point: number[], pageId = this.currentPageId): number[] => {\n    const { camera } = this.getPageState(pageId)\n    return Vec.sub(Vec.div(point, camera.zoom), camera.point)\n  }\n\n  /**\n   * Get the current undo/redo stack.\n   */\n  get history() {\n    return this.stack.slice(0, this.pointer + 1)\n  }\n\n  /**\n   * Replace the current history stack.\n   */\n  set history(commands: TldrawCommand[]) {\n    this.replaceHistory(commands)\n  }\n\n  /**\n   * The current document.\n   */\n  get document(): TDDocument {\n    return this.state.document\n  }\n\n  /**\n   * The current app state.\n   */\n  get settings(): TDSnapshot['settings'] {\n    return this.state.settings\n  }\n\n  /**\n   * The current app state.\n   */\n  get appState(): TDSnapshot['appState'] {\n    return this.state.appState\n  }\n\n  /**\n   * The current page id.\n   */\n  get currentPageId(): string {\n    return this.state.appState.currentPageId\n  }\n\n  /**\n   * The current page.\n   */\n  get page(): TDPage {\n    return this.state.document.pages[this.currentPageId]\n  }\n\n  /**\n   * The current page's shapes (as an array).\n   */\n  get shapes(): TDShape[] {\n    return Object.values(this.page.shapes)\n  }\n\n  /**\n   * The current page's bindings.\n   */\n  get bindings(): TDBinding[] {\n    return Object.values(this.page.bindings)\n  }\n\n  /**\n   * The document's assets (as an array).\n   */\n  get assets(): TDAsset[] {\n    return Object.values(this.document.assets)\n  }\n\n  /**\n   * The current page's state.\n   */\n  get pageState(): TLPageState {\n    return this.state.document.pageStates[this.currentPageId]\n  }\n\n  get camera(): {\n    point: number[]\n    zoom: number\n  } {\n    return this.pageState.camera\n  }\n\n  get zoom(): number {\n    return this.pageState.camera.zoom\n  }\n\n  /**\n   * The page's current selected ids.\n   */\n  get selectedIds(): string[] {\n    return this.pageState.selectedIds\n  }\n\n  /* -------------------------------------------------- */\n  /*                        Pages                       */\n  /* -------------------------------------------------- */\n\n  /**\n   * Create a new page.\n   * @param pageId (optional) The new page's id.\n   */\n  createPage = (id?: string, name?: string): this => {\n    if (this.readOnly) return this\n    const { width, height } = this.rendererBounds\n    return this.setState(Commands.createPage(this, [-width / 2, -height / 2], id, name))\n  }\n\n  /**\n   * Change the current page.\n   * @param pageId The new current page's id.\n   */\n  changePage = (pageId: string): this => {\n    return this.setState(Commands.changePage(this, pageId))\n  }\n\n  /**\n   * Move a page above another.\n   * @param pageId The page to move.\n   * @param index The page above which to move.\n   */\n  movePage = (pageId: string, index: number): this => {\n    if (this.readOnly) return this\n\n    return this.setState(Commands.movePage(this, pageId, index))\n  }\n\n  /**\n   * Rename a page.\n   * @param pageId The id of the page to rename.\n   * @param name The page's new name\n   */\n  renamePage = (pageId: string, name: string): this => {\n    if (this.readOnly) return this\n    return this.setState(Commands.renamePage(this, pageId, name))\n  }\n\n  /**\n   * Duplicate a page.\n   * @param pageId The id of the page to duplicate.\n   */\n  duplicatePage = (pageId: string): this => {\n    if (this.readOnly) return this\n    return this.setState(Commands.duplicatePage(this, pageId))\n  }\n\n  /**\n   * Delete a page.\n   * @param pageId The id of the page to delete.\n   */\n  deletePage = (pageId?: string): this => {\n    if (this.readOnly) return this\n    if (Object.values(this.document.pages).length <= 1) return this\n    return this.setState(Commands.deletePage(this, pageId ? pageId : this.currentPageId))\n  }\n\n  /* -------------------------------------------------- */\n  /*                      Clipboard                     */\n  /* -------------------------------------------------- */\n\n  /**\n   * Cut (copy and delete) one or more shapes to the clipboard.\n   * @param ids The ids of the shapes to cut.\n   */\n  cut = (ids = this.selectedIds, e?: ClipboardEvent): this => {\n    e?.preventDefault()\n\n    this.copy(ids, e)\n\n    if (!this.readOnly) {\n      this.delete(ids)\n    }\n\n    return this\n  }\n\n  /**\n   * Copy one or more shapes to the clipboard.\n   * @param ids The ids of the shapes to copy.\n   */\n  copy = (ids = this.selectedIds, e?: ClipboardEvent): this => {\n    // Allow when in readOnly mode\n\n    e?.preventDefault()\n\n    this.clipboard = this.getContent(ids)\n\n    const jsonString = JSON.stringify({\n      type: 'tldr/clipboard',\n      ...this.clipboard,\n    })\n\n    const tldrawString = `<tldraw>${jsonString}</tldraw>`\n\n    setClipboard(tldrawString)\n\n    if (e) {\n      e.clipboardData?.setData('text/html', tldrawString)\n    }\n\n    if (navigator.clipboard && window.ClipboardItem) {\n      navigator.clipboard.write([\n        new ClipboardItem({\n          'text/html': new Blob([tldrawString], { type: 'text/html' }),\n        }),\n      ])\n    }\n\n    return this\n  }\n\n  /**\n   * Paste shapes (or text) from clipboard to a certain point.\n   * @param point\n   */\n  paste = async (point?: number[], e?: ClipboardEvent) => {\n    if (this.readOnly) return\n\n    const filesToPaste: File[] = []\n    const shapesToCreate: TDShape[] = []\n\n    let clipboardData: any\n\n    const getSvgFromText = async (text: string) => {\n      const div = document.createElement('div')\n      div.innerHTML = text\n      const svg = div.firstChild as SVGSVGElement\n\n      svg.style.setProperty('background-color', 'transparent')\n\n      const imageBlob = await TLDR.getImageForSvg(svg, TDExportType.SVG, {\n        scale: 1,\n        quality: 1,\n      })\n\n      if (imageBlob) {\n        const file = new File([imageBlob], 'image.svg')\n        filesToPaste.push(file)\n      } else {\n        getShapeFromText(text)\n      }\n    }\n\n    const getShapeFromText = (text: string) => {\n      const pagePoint = this.getPagePoint(point ?? this.centerPoint, this.currentPageId)\n\n      const isMultiline = text.includes('\\n')\n\n      shapesToCreate.push(\n        TLDR.getShapeUtil(TDShapeType.Text).getShape({\n          id: Utils.uniqueId(),\n          type: TDShapeType.Text,\n          parentId: this.appState.currentPageId,\n          text: TLDR.normalizeText(text.trim()),\n          point: pagePoint,\n          style: {\n            ...this.appState.currentStyle,\n            textAlign: isMultiline ? AlignStyle.Start : this.appState.currentStyle.textAlign,\n          },\n        })\n      )\n    }\n\n    const getShapeFromHtml = (html: string) => {\n      try {\n        const maybeJson = html.match(/<tldraw>(.*)<\\/tldraw>/)?.[1]\n\n        if (!maybeJson) return\n\n        const json: {\n          type: string\n          shapes: (TDShape & { text: string })[]\n          bindings: TDBinding[]\n          assets: TDAsset[]\n        } = JSON.parse(maybeJson)\n        if (json.type === 'tldr/clipboard') {\n          clipboardData = json\n          return\n        } else {\n          throw Error('Not tldraw data!')\n        }\n      } catch (e) {\n        getShapeFromText(html)\n      }\n    }\n\n    if (e !== undefined) {\n      const items = Array.from(e.clipboardData?.items ?? [])\n\n      await Promise.all(\n        items.map(async (item) => {\n          const { type, kind } = item\n\n          switch (kind) {\n            case 'string': {\n              const str: string = await new Promise((resolve) => item.getAsString(resolve))\n\n              switch (type) {\n                case 'text/html': {\n                  if (str.match(/<tldraw>(.*)<\\/tldraw>/)?.[1]) {\n                    getShapeFromHtml(str)\n                    return\n                  }\n                  break\n                }\n                case 'text/plain': {\n                  if (str.startsWith('<svg')) {\n                    await getSvgFromText(str)\n                  } else {\n                    getShapeFromText(str)\n                  }\n                  break\n                }\n              }\n\n              break\n            }\n            case 'file': {\n              const file = item.getAsFile()\n              if (file) filesToPaste.push(file)\n              break\n            }\n          }\n        })\n      )\n    }\n\n    if (clipboardData) {\n      this.insertContent(clipboardData, { point, select: true })\n      return this\n    }\n\n    if (filesToPaste.length) {\n      this.addMediaFromFiles(filesToPaste, point)\n      return this\n    }\n\n    if (shapesToCreate.length) {\n      const pagePoint = this.getPagePoint(point ?? this.centerPoint, this.currentPageId)\n\n      const currentPoint = Vec.add(pagePoint, [0, 0])\n\n      shapesToCreate.forEach((shape, i) => {\n        const bounds = TLDR.getBounds(shape)\n\n        if (i === 0) {\n          // For the first shape, offset the current point so\n          // that the first shape's center is at the page point\n          currentPoint[0] -= bounds.width / 2\n          currentPoint[1] -= bounds.height / 2\n        }\n\n        // Set the shape's point the current point\n        shape.point = [...currentPoint]\n\n        // Then bump the page current point by this shape's width\n        currentPoint[0] += bounds.width\n      })\n\n      this.createShapes(...shapesToCreate)\n      return this\n    }\n\n    if (this.clipboard) {\n      // try to get clipboard data from the scene itself\n      this.insertContent(this.clipboard)\n    } else {\n      // last chance to get the clipboard data, is it in storage?\n      getClipboard().then((text) => {\n        if (text) getShapeFromHtml(text)\n      })\n    }\n\n    return this\n  }\n\n  getSvg = async (\n    ids = this.selectedIds.length ? this.selectedIds : Object.keys(this.page.shapes),\n    opts = {} as Partial<{ includeFonts: boolean }>\n  ): Promise<SVGElement | undefined> => {\n    if (ids.length === 0) return\n\n    // Embed our custom fonts\n    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg')\n    const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs')\n    const style = document.createElementNS('http://www.w3.org/2000/svg', 'style')\n\n    if (typeof window !== 'undefined') {\n      window.focus() // weird but necessary\n    }\n\n    if (opts.includeFonts) {\n      try {\n        const { fonts } = await fetch(TldrawApp.assetSrc, { mode: 'no-cors' }).then((d) => d.json())\n\n        style.textContent = `\n          @font-face {\n            font-family: 'Caveat Brush';\n            src: url(data:application/x-font-woff;charset=utf-8;base64,${fonts.caveat}) format('woff');\n            font-weight: 500;\n            font-style: normal;\n          }\n          @font-face {\n            font-family: 'Source Code Pro';\n            src: url(data:application/x-font-woff;charset=utf-8;base64,${fonts.source_code_pro}) format('woff');\n            font-weight: 500;\n            font-style: normal;\n          }\n          @font-face {\n            font-family: 'Source Sans Pro';\n            src: url(data:application/x-font-woff;charset=utf-8;base64,${fonts.source_sans_pro}) format('woff');\n            font-weight: 500;\n            font-style: normal;\n          }\n          @font-face {\n            font-family: 'Crimson Pro';\n            src: url(data:application/x-font-woff;charset=utf-8;base64,${fonts.crimson_pro}) format('woff');\n            font-weight: 500;\n            font-style: normal;\n          }\n          `\n      } catch (e) {\n        TLDR.warn('Could not find tldraw-assets.json file.')\n      }\n    } else {\n      style.textContent = `@import url('https://fonts.googleapis.com/css2?family=Caveat+Brush&family=Source+Code+Pro&family=Source+Sans+Pro&family=Crimson+Pro&display=block');`\n    }\n\n    defs.append(style)\n    svg.append(defs)\n\n    // Get the shapes in order\n    const shapes = ids\n      .map((id) => this.getShape(id, this.currentPageId))\n      .sort((a, b) => a.childIndex - b.childIndex)\n\n    // Find their common bounding box. Shapes will be positioned relative to this box\n    const commonBounds = Utils.getCommonBounds(shapes.map(TLDR.getRotatedBounds))\n\n    // A quick routine to get an SVG element for each shape\n    const getSvgElementForShape = (shape: TDShape) => {\n      const util = TLDR.getShapeUtil(shape)\n      const bounds = util.getBounds(shape)\n      const elm = util.getSvgElement(shape, this.settings.isDarkMode)\n\n      if (!elm) return\n\n      // If the element is an image, set the asset src as the xlinkhref\n      if (shape.type === TDShapeType.Image) {\n        elm.setAttribute('xlink:href', this.document.assets[shape.assetId].src)\n      } else if (shape.type === TDShapeType.Video) {\n        elm.setAttribute('xlink:href', this.serializeVideo(shape.id))\n      }\n\n      // Put the element in the correct position relative to the common bounds\n      elm.setAttribute(\n        'transform',\n        `translate(${(SVG_EXPORT_PADDING + shape.point[0] - commonBounds.minX).toFixed(2)}, ${(\n          SVG_EXPORT_PADDING +\n          shape.point[1] -\n          commonBounds.minY\n        ).toFixed(2)}) rotate(${(((shape.rotation || 0) * 180) / Math.PI).toFixed(2)}, ${(\n          bounds.width / 2\n        ).toFixed(2)}, ${(bounds.height / 2).toFixed(2)})`\n      )\n\n      return elm\n    }\n\n    // Assemble the final SVG by iterating through each shape and its children\n    shapes.forEach((shape) => {\n      // The shape is a group! Just add the children.\n      if (shape.children?.length) {\n        // Create a group <g> elm for shape\n        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g')\n\n        // Get the shape's children as elms and add them to the group\n        shape.children.forEach((childId) => {\n          const shape = this.getShape(childId, this.currentPageId)\n          const elm = getSvgElementForShape(shape)\n\n          if (elm) {\n            g.append(elm)\n          }\n        })\n\n        // Add the group elm to the SVG\n        svg.append(g)\n\n        return\n      }\n\n      // Just add the shape's element to the\n      const elm = getSvgElementForShape(shape)\n\n      if (elm) {\n        svg.append(elm)\n      }\n    })\n\n    // Resize the elm to the bounding box\n    svg.setAttribute(\n      'viewBox',\n      [\n        0,\n        0,\n        commonBounds.width + SVG_EXPORT_PADDING * 2,\n        commonBounds.height + SVG_EXPORT_PADDING * 2,\n      ].join(' ')\n    )\n\n    // Clean up the SVG by removing any hidden elements\n    svg.setAttribute('width', (commonBounds.width + SVG_EXPORT_PADDING * 2).toString())\n    svg.setAttribute('height', (commonBounds.height + SVG_EXPORT_PADDING * 2).toString())\n\n    // Set export background\n    const exportBackground: TDExportBackground = this.settings.exportBackground\n    const darkBackground = '#212529'\n    const lightBackground = 'rgb(248, 249, 250)'\n\n    switch (exportBackground) {\n      case TDExportBackground.Auto: {\n        svg.style.setProperty(\n          'background-color',\n          this.settings.isDarkMode ? darkBackground : lightBackground\n        )\n        break\n      }\n      case TDExportBackground.Dark: {\n        svg.style.setProperty('background-color', darkBackground)\n        break\n      }\n      case TDExportBackground.Light: {\n        svg.style.setProperty('background-color', lightBackground)\n        break\n      }\n      case TDExportBackground.Transparent:\n      default: {\n        svg.style.setProperty('background-color', 'transparent')\n        break\n      }\n    }\n\n    svg\n      .querySelectorAll('.tl-fill-hitarea, .tl-stroke-hitarea, .tl-binding-indicator')\n      .forEach((elm) => elm.remove())\n\n    return svg\n  }\n\n  /**\n   * Copy one or more shapes as SVG.\n   * @param ids The ids of the shapes to copy.\n   * @returns A string containing the JSON.\n   */\n  copySvg = async (\n    ids = this.selectedIds.length ? this.selectedIds : Object.keys(this.page.shapes)\n  ) => {\n    if (ids.length === 0) return\n\n    const svg = await this.getSvg(ids)\n\n    if (!svg) return\n\n    const svgString = TLDR.getSvgString(svg, 1)\n\n    this.clipboard = this.getContent(ids)\n\n    const tldrawString = JSON.stringify({\n      type: 'tldr/clipboard',\n      ...this.clipboard,\n    })\n\n    if (navigator.clipboard && window.ClipboardItem) {\n      navigator.clipboard.write([\n        new ClipboardItem({\n          'text/html': new Blob([tldrawString], { type: 'text/html' }),\n          'text/plain': new Blob([svgString], { type: 'text/plain' }),\n        }),\n      ])\n    }\n\n    return svgString\n  }\n\n  /**\n   * Get the shapes and bindings for the current selection, if any, or else the current page.\n   *\n   * @param ids The ids of the shapes to get content for.\n   */\n  getContent = (ids?: string[]) => {\n    const page = this.getPage(this.currentPageId)\n\n    // If ids is explicitly empty ([]) return\n    if (ids && ids.length === 0) return\n\n    // If ids was not provided, use the selected ids\n    if (!ids) ids = this.selectedIds\n\n    // If there are no selected ids, use all the page's shape ids\n    if (ids.length === 0) ids = Object.keys(page.shapes)\n\n    // If the page was empty, return\n    if (ids.length === 0) return\n\n    const shapes = ids\n      .map((id) => page.shapes[id])\n      .flatMap((shape) => [shape, ...(shape.children ?? []).map((childId) => page.shapes[childId])])\n      .map(deepCopy)\n\n    const idsSet = new Set(shapes.map((s) => s.id))\n\n    shapes.forEach((shape) => {\n      if (shape.parentId === this.currentPageId) {\n        shape.parentId = 'currentPageId'\n      }\n    })\n\n    // If a binding's from and to are included, then include the binding;\n    // but if only one shape is included, discard the binding\n    const bindings = Object.values(page.bindings)\n      .filter((binding) => {\n        if (idsSet.has(binding.fromId) || idsSet.has(binding.toId)) {\n          return true\n        }\n\n        if (idsSet.has(binding.fromId)) {\n          const shape = shapes.find((s) => s.id === binding.fromId)\n          const handles = shape!.handles\n          if (handles) {\n            Object.values(handles).forEach((handle) => {\n              if (handle!.bindingId === binding.id) {\n                handle!.bindingId = undefined\n              }\n            })\n          }\n        }\n\n        if (idsSet.has(binding.toId)) {\n          const shape = shapes.find((s) => s.id === binding.toId)\n          const handles = shape!.handles\n          if (handles) {\n            Object.values(handles).forEach((handle) => {\n              if (handle!.bindingId === binding.id) {\n                handle!.bindingId = undefined\n              }\n            })\n          }\n        }\n\n        return false\n      })\n      .map(deepCopy)\n\n    const assets = [\n      ...new Set(\n        shapes\n          .map((shape) => {\n            if (!shape.assetId) return\n            return this.document.assets[shape.assetId]\n          })\n          .filter(Boolean)\n          .map(deepCopy)\n      ),\n    ] as TDAsset[]\n\n    return { shapes, bindings, assets }\n  }\n\n  /**\n   * Copy one or more shapes as JSON.\n   * @param ids The ids of the shapes to copy.\n   * @returns A string containing the JSON.\n   */\n  copyJson = (ids = this.selectedIds) => {\n    const content = this.getContent(ids)\n\n    if (content) {\n      TLDR.copyStringToClipboard(JSON.stringify(content))\n    }\n\n    return this\n  }\n\n  /**\n   * Export one or more shapes as JSON.\n   * @param ids The ids of the shapes to copy from the current page.\n   * @returns A string containing the JSON.\n   */\n  exportJson = (ids = this.selectedIds) => {\n    const content = this.getContent(ids)\n\n    if (content) {\n      const blob = new Blob([JSON.stringify(content)], { type: 'application/json' })\n      const url = URL.createObjectURL(blob)\n      const link = document.createElement('a')\n      link.href = url\n      link.download = `export.json`\n      link.click()\n    }\n\n    return this\n  }\n\n  /**\n   * Insert content.\n   *\n   * @param content The content to insert.\n   * @param content.shapes An array of TDShape objects.\n   * @param content.bindings (optional) An array of TDBinding objects.\n   * @param content.assets (optional) An array of TDAsset objects.\n   * @param opts (optional) An options object\n   * @param opts.point (optional) A point at which to paste the content.\n   * @param opts.select (optional) When true, the inserted shapes will be selected. Defaults to false.\n   * @param opts.overwrite (optional) When true, the inserted shapes and bindings will overwrite any existing shapes and bindings. Defaults to false.\n   */\n  insertContent = (\n    content: { shapes: TDShape[]; bindings?: TDBinding[]; assets?: TDAsset[] },\n    opts = {} as { point?: number[]; select?: boolean; overwrite?: boolean }\n  ) => {\n    return this.setState(Commands.insertContent(this, content, opts), 'insert_content')\n  }\n\n  /**\n   * Get an image of the selected shapes.\n   *\n   * @param format The format to export the image as.\n   * @param opts (optional) An object containing options for the image.\n   * @param opts.ids (optional) The ids of the shapes (on the current page) to get an image for.\n   * @param opts.scale (optional) The id of the page from which to get an image.\n   * @param opts.quality (optional) The quality (between 0 and 1) for the image if lossy format.\n   */\n  getImage = async (\n    format: Exclude<TDExportType, TDExportType.JSON> = TDExportType.PNG,\n    opts = {} as Partial<{\n      ids: string[]\n      scale: number\n      quality: number\n      transparentBackground: boolean\n    }>\n  ): Promise<Blob | undefined> => {\n    const { ids = this.selectedIds.length ? this.selectedIds : Object.keys(this.page.shapes) } =\n      opts\n\n    const svg = await this.getSvg(ids, {\n      includeFonts: format !== TDExportType.SVG,\n    })\n\n    if (!svg) return\n\n    if (format === TDExportType.SVG) {\n      const svgString = TLDR.getSvgString(svg, 1)\n      const blob = new Blob([svgString], { type: 'image/svg+xml' })\n      return blob\n    }\n\n    const imageBlob = await TLDR.getImageForSvg(svg, format, opts)\n\n    if (!imageBlob) return\n\n    return imageBlob\n  }\n\n  /**\n   * Copy an image of the selected shapes.\n   *\n   * @param format The format to export the image as.\n   * @param opts (optional) An object containing options for the image.\n   * @param opts.ids (optional) The ids of the shapes (on the current page) to get an image for.\n   * @param opts.scale (optional) The id of the page from which to get an image.\n   * @param opts.quality (optional) The quality (between 0 and 1) for the image if lossy format.\n   */\n  copyImage = async (\n    format: TDExportType.PNG | TDExportType.SVG = TDExportType.PNG,\n    opts = {} as Partial<{\n      ids: string[]\n      scale: number\n      quality: number\n      transparentBackground: boolean\n    }>\n  ) => {\n    if (format === TDExportType.SVG) {\n      this.copySvg(opts.ids)\n      return\n    }\n\n    if (!(navigator.clipboard && window.ClipboardItem)) {\n      console.warn('Sorry, your browser does not support copying images.')\n      return\n    }\n\n    const blob = await this.getImage(format, opts)\n\n    if (!blob) return\n\n    navigator.clipboard.write([\n      new ClipboardItem({\n        [blob.type]: blob,\n      }),\n    ])\n  }\n\n  exportImage = async (\n    format: Exclude<TDExportType, TDExportType.JSON> = TDExportType.PNG,\n    opts = {} as Partial<{\n      ids: string[]\n      pageId: string\n      scale: number\n      quality: number\n    }>\n  ) => {\n    const { pageId = this.currentPageId } = opts\n\n    const blob = await this.getImage(format, opts)\n\n    if (!blob) return\n\n    const name = this.document.pages[pageId].name ?? 'export'\n\n    if (this.callbacks.onExport) {\n      this.callbacks.onExport(this, {\n        name,\n        type: format,\n        blob,\n      })\n    } else {\n      const url = URL.createObjectURL(blob)\n      const link = document.createElement('a')\n      link.href = url\n      link.download = `${name}.${format}`\n      link.click()\n    }\n  }\n\n  /* -------------------------------------------------- */\n  /*                       Camera                       */\n  /* -------------------------------------------------- */\n\n  /**\n   * Set the camera to a specific point and zoom.\n   * @param point The camera point (top left of the viewport).\n   * @param zoom The zoom level.\n   * @param reason Why did the camera change?\n   */\n  setCamera = (point: number[], zoom: number, reason: string): this => {\n    this.updateViewport(point, zoom)\n    this.patchState(\n      {\n        document: {\n          pageStates: {\n            [this.currentPageId]: { camera: { point, zoom } },\n          },\n        },\n      },\n      reason\n    )\n    return this\n  }\n\n  /**\n   * Reset the camera to the default position\n   */\n  resetCamera = (): this => {\n    return this.setCamera(this.centerPoint, 1, `reset_camera`)\n  }\n\n  /**\n   * Pan the camera\n   * @param delta\n   */\n  pan = (delta: number[]): this => {\n    const { camera } = this.pageState\n    return this.setCamera(Vec.toFixed(Vec.sub(camera.point, delta)), camera.zoom, `panned`)\n  }\n\n  /**\n   * Pinch to a new zoom level, possibly together with a pan.\n   * @param point The current point under the cursor.\n   * @param delta The movement delta.\n   * @param zoomDelta The zoom detal\n   */\n  pinchZoom = (point: number[], delta: number[], zoom: number): this => {\n    const { camera } = this.pageState\n    const nextPoint = Vec.sub(camera.point, Vec.div(delta, camera.zoom))\n    const nextZoom = zoom\n    const p0 = Vec.sub(Vec.div(point, camera.zoom), nextPoint)\n    const p1 = Vec.sub(Vec.div(point, nextZoom), nextPoint)\n    return this.setCamera(\n      Vec.toFixed(Vec.add(nextPoint, Vec.sub(p1, p0))),\n      nextZoom,\n      `pinch_zoomed`\n    )\n  }\n\n  /**\n   * Zoom to a new zoom level, keeping the point under the cursor in the same position\n   * @param next The new zoom level.\n   * @param center The point to zoom towards (defaults to screen center).\n   */\n  zoomTo = (next: number, center = this.centerPoint): this => {\n    const { zoom, point } = this.camera\n    const p0 = Vec.sub(Vec.div(center, zoom), point)\n    const p1 = Vec.sub(Vec.div(center, next), point)\n    return this.setCamera(Vec.toFixed(Vec.add(point, Vec.sub(p1, p0))), next, `zoomed_camera`)\n  }\n\n  /**\n   * Zoom out by 25%\n   */\n  zoomIn = (): this => {\n    const i = Math.round((this.camera.zoom * 100) / 25)\n    const nextZoom = TLDR.getCameraZoom((i + 1) * 0.25)\n    return this.zoomTo(nextZoom)\n  }\n\n  /**\n   * Zoom in by 25%.\n   */\n  zoomOut = (): this => {\n    const i = Math.round((this.camera.zoom * 100) / 25)\n    const nextZoom = TLDR.getCameraZoom((i - 1) * 0.25)\n    return this.zoomTo(nextZoom)\n  }\n\n  /**\n   * Zoom to fit the page's shapes.\n   */\n  zoomToFit = (): this => {\n    const {\n      shapes,\n      pageState: { camera },\n    } = this\n    if (shapes.length === 0) return this\n    const { rendererBounds } = this\n    const commonBounds = Utils.getCommonBounds(shapes.map(TLDR.getBounds))\n    let zoom = TLDR.getCameraZoom(\n      Math.min(\n        (rendererBounds.width - FIT_TO_SCREEN_PADDING) / commonBounds.width,\n        (rendererBounds.height - FIT_TO_SCREEN_PADDING) / commonBounds.height\n      )\n    )\n    zoom = camera.zoom === zoom || camera.zoom < 1 ? Math.min(1, zoom) : zoom\n    const mx = (rendererBounds.width - commonBounds.width * zoom) / 2 / zoom\n    const my = (rendererBounds.height - commonBounds.height * zoom) / 2 / zoom\n    return this.setCamera(\n      Vec.toFixed(Vec.sub([mx, my], [commonBounds.minX, commonBounds.minY])),\n      zoom,\n      `zoomed_to_fit`\n    )\n  }\n\n  /**\n   * Zoom to the selected shapes.\n   */\n  zoomToSelection = (): this => {\n    if (this.selectedIds.length === 0) return this\n\n    const { rendererBounds } = this\n    const selectedBounds = TLDR.getSelectedBounds(this.state)\n\n    let zoom = TLDR.getCameraZoom(\n      Math.min(\n        (rendererBounds.width - FIT_TO_SCREEN_PADDING) / selectedBounds.width,\n        (rendererBounds.height - FIT_TO_SCREEN_PADDING) / selectedBounds.height\n      )\n    )\n\n    zoom = this.camera.zoom === zoom || this.camera.zoom < 1 ? Math.min(1, zoom) : zoom\n\n    const mx = (rendererBounds.width - selectedBounds.width * zoom) / 2 / zoom\n    const my = (rendererBounds.height - selectedBounds.height * zoom) / 2 / zoom\n\n    return this.setCamera(\n      Vec.toFixed(Vec.sub([mx, my], [selectedBounds.minX, selectedBounds.minY])),\n      zoom,\n      `zoomed_to_selection`\n    )\n  }\n\n  /**\n   * Zoom back to content when the canvas is empty.\n   */\n  zoomToContent = (): this => {\n    const shapes = this.shapes\n    const pageState = this.pageState\n\n    if (shapes.length === 0) return this\n\n    const { rendererBounds } = this\n    const { zoom } = pageState.camera\n    const commonBounds = Utils.getCommonBounds(shapes.map(TLDR.getBounds))\n\n    const mx = (rendererBounds.width - commonBounds.width * zoom) / 2 / zoom\n    const my = (rendererBounds.height - commonBounds.height * zoom) / 2 / zoom\n\n    return this.setCamera(\n      Vec.toFixed(Vec.sub([mx, my], [commonBounds.minX, commonBounds.minY])),\n      this.camera.zoom,\n      `zoomed_to_content`\n    )\n  }\n\n  /**\n   * Zoom the camera to 100%.\n   */\n  resetZoom = (): this => {\n    return this.zoomTo(1)\n  }\n\n  /**\n   * Zoom the camera by a certain delta.\n   * @param delta The zoom delta.\n   * @param center The point to zoom toward.\n   */\n  zoomBy = Utils.throttle((delta: number, center?: number[]): this => {\n    const { zoom } = this.camera\n    const nextZoom = TLDR.getCameraZoom(zoom - delta * zoom)\n    return this.zoomTo(nextZoom, center)\n  }, 16)\n\n  /* -------------------------------------------------- */\n  /*                      Selection                     */\n  /* -------------------------------------------------- */\n\n  /**\n   * Clear the selection history (undo/redo stack for selection).\n   */\n  private clearSelectHistory = (): this => {\n    this.selectHistory.pointer = 0\n    this.selectHistory.stack = [this.selectedIds]\n    return this\n  }\n\n  /**\n   * Adds a selection to the selection history (undo/redo stack for selection).\n   */\n  private addToSelectHistory = (ids: string[]): this => {\n    if (this.selectHistory.pointer < this.selectHistory.stack.length) {\n      this.selectHistory.stack = this.selectHistory.stack.slice(0, this.selectHistory.pointer + 1)\n    }\n    this.selectHistory.pointer++\n    this.selectHistory.stack.push(ids)\n    return this\n  }\n\n  /**\n   * Set the current selection.\n   * @param ids The ids to select\n   * @param push Whether to add the ids to the current selection instead.\n   */\n  private setSelectedIds = (ids: string[], push = false): this => {\n    const nextIds = push ? [...this.pageState.selectedIds, ...ids] : [...ids]\n\n    return this.patchState(\n      {\n        appState: {\n          activeTool: 'select',\n        },\n        document: {\n          pageStates: {\n            [this.currentPageId]: {\n              selectedIds: nextIds,\n            },\n          },\n        },\n      },\n      `selected`\n    )\n  }\n\n  /**\n   * Undo the most recent selection.\n   */\n  undoSelect = (): this => {\n    if (this.selectHistory.pointer > 0) {\n      this.selectHistory.pointer--\n      this.setSelectedIds(this.selectHistory.stack[this.selectHistory.pointer])\n    }\n    return this\n  }\n\n  /**\n   * Redo the previous selection.\n   */\n  redoSelect = (): this => {\n    if (this.selectHistory.pointer < this.selectHistory.stack.length - 1) {\n      this.selectHistory.pointer++\n      this.setSelectedIds(this.selectHistory.stack[this.selectHistory.pointer])\n    }\n    return this\n  }\n\n  /**\n   * Select one or more shapes.\n   * @param ids The shape ids to select.\n   */\n  select = (...ids: string[]): this => {\n    ids.forEach((id) => {\n      if (!this.page.shapes[id]) {\n        throw Error(`That shape does not exist on page ${this.currentPageId}`)\n      }\n    })\n    this.setSelectedIds(ids)\n    this.addToSelectHistory(ids)\n    return this\n  }\n\n  /**\n   * Select all shapes on the page.\n   */\n  selectAll = (pageId = this.currentPageId): this => {\n    if (this.session) return this\n\n    // Select only shapes that are the direct child of the page\n    this.setSelectedIds(\n      Object.values(this.document.pages[pageId].shapes)\n        .filter((shape) => shape.parentId === pageId)\n        .map((shape) => shape.id)\n    )\n\n    this.addToSelectHistory(this.selectedIds)\n\n    this.selectTool('select')\n\n    return this\n  }\n\n  /**\n   * Deselect any selected shapes.\n   */\n  selectNone = (): this => {\n    this.setSelectedIds([])\n    this.addToSelectHistory(this.selectedIds)\n    return this\n  }\n\n  /* -------------------------------------------------- */\n  /*                      Sessions                 p      */\n  /* -------------------------------------------------- */\n\n  /**\n   * Start a new session.\n   * @param type The session type\n   * @param args arguments of the session's start method.\n   */\n  startSession = <T extends SessionType>(type: T, ...args: SessionArgsOfType<T>): this => {\n    if (this.readOnly && type !== SessionType.Brush) return this\n\n    if (this.session) {\n      TLDR.warn(`Already in a session! (${this.session.constructor.name})`)\n      this.cancelSession()\n    }\n\n    const Session = getSession(type) as any\n    this.session = new Session(this, ...args)\n\n    const result = this.session!.start()\n\n    if (result) {\n      this.patchState(result, `session:start_${this.session!.constructor.name}`)\n    }\n\n    this.callbacks.onSessionStart?.(this, this.session!.constructor.name)\n\n    return this\n    // return this.setStatus(this.session.status)\n  }\n\n  /**\n   * updateSession.\n   * @param args The arguments of the current session's update method.\n   */\n  updateSession = (): this => {\n    const { session } = this\n    if (!session) return this\n\n    // @ts-ignore\n    const patch = session.update()\n    if (!patch) return this\n    return this.patchState(patch, `session:${session?.constructor.name}`)\n  }\n\n  /**\n   * Cancel the current session.\n   * @param args The arguments of the current session's cancel method.\n   */\n  cancelSession = (): this => {\n    const { session } = this\n    if (!session) return this\n    this.session = undefined\n\n    const result = session.cancel()\n\n    if (result) {\n      this.patchState(result, `session:cancel:${session.constructor.name}`)\n    }\n\n    this.setEditingId()\n\n    this.callbacks.onSessionEnd?.(this, session.constructor.name)\n\n    return this\n  }\n\n  /**\n   * Complete the current session.\n   * @param args The arguments of the current session's complete method.\n   */\n  completeSession = (): this => {\n    const { session } = this\n\n    if (!session) return this\n\n    this.session = undefined\n    const result = session.complete()\n\n    if (result === undefined) {\n      this.isCreating = false\n\n      this.patchState(\n        {\n          appState: {\n            status: TDStatus.Idle,\n          },\n          document: {\n            pageStates: {\n              [this.currentPageId]: {\n                editingId: undefined,\n                bindingId: undefined,\n                hoveredId: undefined,\n              },\n            },\n          },\n        },\n        `session:complete:${session.constructor.name}`\n      )\n    } else if ('after' in result) {\n      // Session ended with a command\n\n      if (this.isCreating) {\n        // We're currently creating a shape. Override the command's\n        // before state so that when we undo the command, we remove\n        // the shape we just created.\n\n        result.before = {\n          appState: {\n            ...result.before.appState,\n            status: TDStatus.Idle,\n          },\n          document: {\n            pages: {\n              [this.currentPageId]: {\n                shapes: Object.fromEntries(this.selectedIds.map((id) => [id, undefined])),\n              },\n            },\n            pageStates: {\n              [this.currentPageId]: {\n                selectedIds: [],\n                editingId: null,\n                bindingId: null,\n                hoveredId: null,\n              },\n            },\n          },\n        }\n\n        if (this.appState.isToolLocked) {\n          const pageState = result.after?.document?.pageStates?.[this.currentPageId] || {}\n          pageState.selectedIds = []\n        }\n\n        this.isCreating = false\n      }\n\n      result.after.appState = {\n        ...result.after.appState,\n        status: TDStatus.Idle,\n      }\n\n      result.after.document = {\n        ...result.after.document,\n        pageStates: {\n          ...result.after.document?.pageStates,\n          [this.currentPageId]: {\n            ...(result.after.document?.pageStates || {})[this.currentPageId],\n            editingId: null,\n          },\n        },\n      }\n\n      this.setState(result, `session:complete:${session.constructor.name}`)\n    } else {\n      this.patchState(\n        {\n          ...result,\n          appState: {\n            ...result.appState,\n            status: TDStatus.Idle,\n          },\n          document: {\n            ...result.document,\n            pageStates: {\n              [this.currentPageId]: {\n                ...result.document?.pageStates?.[this.currentPageId],\n                editingId: null,\n              },\n            },\n          },\n        },\n        `session:complete:${session.constructor.name}`\n      )\n    }\n\n    this.callbacks.onSessionEnd?.(this, session.constructor.name)\n\n    return this\n  }\n\n  /* -------------------------------------------------- */\n  /*                   Shape Functions                  */\n  /* -------------------------------------------------- */\n\n  /**\n   * Manually create shapes on the page.\n   * @param shapes An array of shape partials, containing the initial props for the shapes.\n   * @command\n   */\n  createShapes = (...shapes: ({ id: string; type: TDShapeType } & Partial<TDShape>)[]): this => {\n    if (shapes.length === 0) return this\n\n    return this.create(\n      shapes.map((shape) => {\n        return TLDR.getShapeUtil(shape.type).create({\n          parentId: this.currentPageId,\n          ...shape,\n        })\n      })\n    )\n  }\n\n  /**\n   * Manually update a set of shapes.\n   * @param shapes An array of shape partials, containing the changes to be made to each shape.\n   * @command\n   */\n  updateShapes = (...shapes: ({ id: string } & Partial<TDShape>)[]): this => {\n    const pageShapes = this.document.pages[this.currentPageId].shapes\n    const shapesToUpdate = shapes.filter((shape) => pageShapes[shape.id])\n    if (shapesToUpdate.length === 0) return this\n    return this.setState(\n      Commands.updateShapes(this, shapesToUpdate, this.currentPageId),\n      'updated_shapes'\n    )\n  }\n\n  createTextShapeAtPoint(point: number[], id?: string, patch?: boolean): this {\n    const {\n      shapes,\n      appState: { currentPageId, currentStyle },\n    } = this\n\n    const childIndex =\n      shapes.length === 0\n        ? 1\n        : shapes\n            .filter((shape) => shape.parentId === currentPageId)\n            .sort((a, b) => b.childIndex - a.childIndex)[0].childIndex + 1\n\n    const Text = shapeUtils[TDShapeType.Text]\n\n    const newShape = Text.create({\n      id: id || Utils.uniqueId(),\n      parentId: currentPageId,\n      childIndex,\n      point,\n      style: { ...currentStyle },\n    })\n\n    const bounds = Text.getBounds(newShape)\n    newShape.point = Vec.sub(newShape.point, [bounds.width / 2, bounds.height / 2])\n\n    if (patch) {\n      this.patchCreate([TLDR.getShapeUtil(newShape.type).create(newShape)])\n    } else {\n      this.createShapes(newShape)\n    }\n\n    this.setEditingId(newShape.id, true)\n\n    return this\n  }\n\n  getImageOrVideoShapeAtPoint(\n    id: string,\n    type: TDShapeType.Image | TDShapeType.Video,\n    point: number[],\n    size: number[],\n    assetId: string\n  ) {\n    const {\n      shapes,\n      appState: { currentPageId, currentStyle },\n    } = this\n\n    const childIndex =\n      shapes.length === 0\n        ? 1\n        : shapes\n            .filter((shape) => shape.parentId === currentPageId)\n            .sort((a, b) => b.childIndex - a.childIndex)[0].childIndex + 1\n\n    const Shape = shapeUtils[type]\n\n    // Ensure that the pasted shape fits inside of the current viewport\n\n    if (size[0] > this.viewport.width) {\n      const r = size[1] / size[0]\n      size[0] = this.viewport.width - (FIT_TO_SCREEN_PADDING / this.camera.zoom) * 2\n      size[1] = size[0] * r\n      if (size[1] < 32 || size[1] < 32) {\n        size[1] = 32\n        size[0] = size[1] / r\n      }\n    } else if (size[1] > this.viewport.height) {\n      const r = size[0] / size[1]\n      size[1] = this.viewport.height - (FIT_TO_SCREEN_PADDING / this.camera.zoom) * 2\n      size[0] = size[1] * r\n      if (size[1] < 32 || size[1] < 32) {\n        size[0] = 32\n        size[1] = size[0] / r\n      }\n    }\n\n    const newShape = Shape.create({\n      id,\n      parentId: currentPageId,\n      childIndex,\n      point,\n      size,\n      style: { ...currentStyle },\n      assetId,\n    })\n\n    return newShape\n  }\n\n  /**\n   * Create one or more shapes.\n   * @param shapes An array of shapes.\n   * @command\n   */\n  create = (shapes: TDShape[] = [], bindings: TDBinding[] = []): this => {\n    if (shapes.length === 0) return this\n    return this.setState(Commands.createShapes(this, shapes, bindings))\n  }\n\n  /**\n   * Patch in a new set of shapes\n   * @param shapes\n   * @param bindings\n   */\n  patchCreate = (shapes: TDShape[] = [], bindings: TDBinding[] = []): this => {\n    if (shapes.length === 0) return this\n    return this.patchState(Commands.createShapes(this, shapes, bindings).after)\n  }\n\n  /**\n   * Delete one or more shapes.\n   * @param ids The ids of the shapes to delete.\n   * @command\n   */\n  delete = (ids = this.selectedIds): this => {\n    if (ids.length === 0) return this\n\n    if (this.session) return this\n    const drawCommand = Commands.deleteShapes(this, ids)\n\n    if (\n      this.callbacks.onAssetDelete &&\n      drawCommand.before.document?.assets &&\n      drawCommand.after.document?.assets\n    ) {\n      const beforeAssetIds = Object.keys(drawCommand.before.document.assets).filter(\n        (k) => !!drawCommand.before.document!.assets![k]\n      )\n      const afterAssetIds = Object.keys(drawCommand.after.document.assets).filter(\n        (k) => !!drawCommand.after.document!.assets![k]\n      )\n\n      const intersection = beforeAssetIds.filter((x) => !afterAssetIds.includes(x))\n      intersection.forEach((id) => this.callbacks.onAssetDelete!(this, id))\n    }\n\n    return this.setState(drawCommand)\n  }\n\n  /**\n   * Delete all shapes on the page.\n   */\n  deleteAll = (): this => {\n    this.selectAll()\n    this.delete()\n    return this\n  }\n\n  /**\n   * Change the style for one or more shapes.\n   * @param style A style partial to apply to the shapes.\n   * @param ids The ids of the shapes to change (defaults to selection).\n   */\n  style = (style: Partial<ShapeStyles>, ids = this.selectedIds): this => {\n    return this.setState(Commands.styleShapes(this, ids, style))\n  }\n\n  /**\n   * Align one or more shapes.\n   * @param direction Whether to align horizontally or vertically.\n   * @param ids The ids of the shapes to change (defaults to selection).\n   */\n  align = (type: AlignType, ids = this.selectedIds): this => {\n    if (ids.length < 2) return this\n    return this.setState(Commands.alignShapes(this, ids, type))\n  }\n\n  /**\n   * Distribute one or more shapes.\n   * @param direction Whether to distribute horizontally or vertically..\n   * @param ids The ids of the shapes to change (defaults to selection).\n   */\n  distribute = (direction: DistributeType, ids = this.selectedIds): this => {\n    if (ids.length < 3) return this\n    return this.setState(Commands.distributeShapes(this, ids, direction))\n  }\n\n  /**\n   * Stretch one or more shapes to their common bounds.\n   * @param direction Whether to stretch horizontally or vertically.\n   * @param ids The ids of the shapes to change (defaults to selection).\n   */\n  stretch = (direction: StretchType, ids = this.selectedIds): this => {\n    if (ids.length < 2) return this\n    return this.setState(Commands.stretchShapes(this, ids, direction))\n  }\n\n  /**\n   * Flip one or more shapes horizontally.\n   * @param ids The ids of the shapes to change (defaults to selection).\n   */\n  flipHorizontal = (ids = this.selectedIds): this => {\n    if (ids.length === 0) return this\n    return this.setState(Commands.flipShapes(this, ids, FlipType.Horizontal))\n  }\n\n  /**\n   * Flip one or more shapes vertically.\n   * @param ids The ids of the shapes to change (defaults to selection).\n   */\n  flipVertical = (ids = this.selectedIds): this => {\n    if (ids.length === 0) return this\n    return this.setState(Commands.flipShapes(this, ids, FlipType.Vertical))\n  }\n\n  /**\n   * Move one or more shapes to a new page. Will also break or move bindings.\n   * @param toPageId The id of the page to move the shapes to.\n   * @param fromPageId The id of the page to move the shapes from (defaults to current page).\n   * @param ids The ids of the shapes to move (defaults to selection).\n   */\n  moveToPage = (\n    toPageId: string,\n    fromPageId = this.currentPageId,\n    ids = this.selectedIds\n  ): this => {\n    if (ids.length === 0) return this\n    const { rendererBounds } = this\n    this.setState(Commands.moveShapesToPage(this, ids, rendererBounds, fromPageId, toPageId))\n    return this\n  }\n\n  /**\n   * Move one or more shapes to the back of the page.\n   * @param ids The ids of the shapes to change (defaults to selection).\n   */\n  moveToBack = (ids = this.selectedIds): this => {\n    if (ids.length === 0) return this\n    return this.setState(Commands.reorderShapes(this, ids, MoveType.ToBack))\n  }\n\n  /**\n   * Move one or more shapes backward on of the page.\n   * @param ids The ids of the shapes to change (defaults to selection).\n   */\n  moveBackward = (ids = this.selectedIds): this => {\n    if (ids.length === 0) return this\n    return this.setState(Commands.reorderShapes(this, ids, MoveType.Backward))\n  }\n\n  /**\n   * Move one or more shapes forward on the page.\n   * @param ids The ids of the shapes to change (defaults to selection).\n   */\n  moveForward = (ids = this.selectedIds): this => {\n    if (ids.length === 0) return this\n    return this.setState(Commands.reorderShapes(this, ids, MoveType.Forward))\n  }\n\n  /**\n   * Move one or more shapes to the front of the page.\n   * @param ids The ids of the shapes to change (defaults to selection).\n   */\n  moveToFront = (ids = this.selectedIds): this => {\n    if (ids.length === 0) return this\n    return this.setState(Commands.reorderShapes(this, ids, MoveType.ToFront))\n  }\n\n  /**\n   * Nudge one or more shapes in a direction.\n   * @param delta The direction to nudge the shapes.\n   * @param isMajor Whether this is a major (i.e. shift) nudge.\n   * @param ids The ids to change (defaults to selection).\n   */\n  nudge = (delta: number[], isMajor = false, ids = this.selectedIds): this => {\n    if (ids.length === 0) return this\n    const size = isMajor\n      ? this.settings.showGrid\n        ? this.currentGrid * 4\n        : 10\n      : this.settings.showGrid\n      ? this.currentGrid\n      : 1\n\n    return this.setState(Commands.translateShapes(this, ids, Vec.mul(delta, size)))\n  }\n\n  /**\n   * Duplicate one or more shapes.\n   * @param ids The ids to duplicate (defaults to selection).\n   */\n  duplicate = (ids = this.selectedIds, point?: number[]): this => {\n    if (this.readOnly) return this\n    if (ids.length === 0) return this\n    return this.setState(Commands.duplicateShapes(this, ids, point))\n  }\n\n  /**\n   * Reset the bounds for one or more shapes. Usually when the\n   * bounding box of a shape is double-clicked. Different shapes may\n   * handle this differently.\n   * @param ids The ids to change (defaults to selection).\n   */\n  resetBounds = (ids = this.selectedIds): this => {\n    const command = Commands.resetBounds(this, ids, this.currentPageId)\n    return this.setState(Commands.resetBounds(this, ids, this.currentPageId), command.id)\n  }\n\n  /**\n   * Toggle the hidden property of one or more shapes.\n   * @param ids The ids to change (defaults to selection).\n   */\n  toggleHidden = (ids = this.selectedIds): this => {\n    if (ids.length === 0) return this\n    return this.setState(Commands.toggleShapeProp(this, ids, 'isHidden'))\n  }\n\n  /**\n   * Toggle the locked property of one or more shapes.\n   * @param ids The ids to change (defaults to selection).\n   */\n  toggleLocked = (ids = this.selectedIds): this => {\n    if (ids.length === 0) return this\n    return this.setState(Commands.toggleShapeProp(this, ids, 'isLocked'))\n  }\n\n  /**\n   * Toggle the fixed-aspect-ratio property of one or more shapes.\n   * @param ids The ids to change (defaults to selection).\n   */\n  toggleAspectRatioLocked = (ids = this.selectedIds): this => {\n    if (ids.length === 0) return this\n    return this.setState(Commands.toggleShapeProp(this, ids, 'isAspectRatioLocked'))\n  }\n\n  /**\n   * Toggle the decoration at a handle of one or more shapes.\n   * @param handleId The handle to toggle.\n   * @param ids The ids of the shapes to toggle the decoration on.\n   */\n  toggleDecoration = (handleId: string, ids = this.selectedIds): this => {\n    if (ids.length === 0 || !(handleId === 'start' || handleId === 'end')) return this\n    return this.setState(Commands.toggleShapesDecoration(this, ids, handleId))\n  }\n\n  /**\n   * Set the props of one or more shapes\n   * @param props The props to set on the shapes.\n   * @param ids The ids of the shapes to set props on.\n   */\n  setShapeProps = <T extends TDShape>(props: Partial<T>, ids = this.selectedIds) => {\n    return this.setState(Commands.setShapesProps(this, ids, props))\n  }\n\n  /**\n   * Rotate one or more shapes by a delta.\n   * @param delta The delta in radians.\n   * @param ids The ids to rotate (defaults to selection).\n   */\n  rotate = (delta = Math.PI * -0.5, ids = this.selectedIds): this => {\n    if (ids.length === 0) return this\n    const change = Commands.rotateShapes(this, ids, delta)\n    if (!change) return this\n    return this.setState(change)\n  }\n\n  /**\n   * Group the selected shapes.\n   * @param ids The ids to group (defaults to selection).\n   * @param groupId The new group's id.\n   */\n  group = (\n    ids = this.selectedIds,\n    groupId = Utils.uniqueId(),\n    pageId = this.currentPageId\n  ): this => {\n    if (this.readOnly) return this\n\n    if (ids.length === 1 && this.getShape(ids[0], pageId).type === TDShapeType.Group) {\n      return this.ungroup(ids, pageId)\n    }\n\n    if (ids.length < 2) return this\n\n    const command = Commands.groupShapes(this, ids, groupId, pageId)\n    if (!command) return this\n    return this.setState(command)\n  }\n\n  /**\n   * Ungroup the selected groups.\n   * @todo\n   */\n  ungroup = (ids = this.selectedIds, pageId = this.currentPageId): this => {\n    if (this.readOnly) return this\n\n    const groups = ids\n      .map((id) => this.getShape(id, pageId))\n      .filter((shape) => shape.type === TDShapeType.Group)\n\n    if (groups.length === 0) return this\n\n    const command = Commands.ungroupShapes(this, ids, groups as GroupShape[], pageId)\n\n    if (!command) {\n      return this\n    }\n\n    return this.setState(command)\n  }\n\n  /**\n   * Cancel the current session.\n   */\n  cancel = (): this => {\n    this.currentTool.onCancel?.()\n\n    return this\n  }\n\n  addMediaFromFiles = async (files: File[], point = this.centerPoint) => {\n    this.setIsLoading(true)\n\n    // Rather than creating each shape individually (which will produce undo / redo entries\n    // for each shape), create an array of all the shapes that we'll need to create. We'll\n    // iterate through these at the bottom of the function to set their points, then create\n    // them through a single call to `createShapes`.\n\n    const shapesToCreate: TDShape[] = []\n\n    const pagePoint = this.getPagePoint(point)\n\n    for (const file of files) {\n      const id = Utils.uniqueId()\n      const extension = file.name.match(/\\.[0-9a-z]+$/i)\n\n      if (!extension) throw Error('No extension')\n\n      const isImage = IMAGE_EXTENSIONS.includes(extension[0].toLowerCase())\n      const isVideo = VIDEO_EXTENSIONS.includes(extension[0].toLowerCase())\n\n      if (!(isImage || isVideo)) throw Error('Wrong extension')\n\n      const shapeType = isImage ? TDShapeType.Image : TDShapeType.Video\n      const assetType = isImage ? TDAssetType.Image : TDAssetType.Video\n\n      let src: string | ArrayBuffer | null\n\n      try {\n        if (this.callbacks.onAssetCreate) {\n          const result = await this.callbacks.onAssetCreate(this, file, id)\n\n          if (!result) throw Error('Asset creation callback returned false')\n\n          src = result\n        } else {\n          src = await fileToBase64(file)\n        }\n\n        if (typeof src === 'string') {\n          let size = [0, 0]\n\n          if (isImage) {\n            // attempt to get actual svg size from viewBox attribute as\n            if (extension[0] == '.svg') {\n              let viewBox: string[]\n              const svgString = await fileToText(file)\n              const viewBoxAttribute = this.getViewboxFromSVG(svgString)\n\n              if (viewBoxAttribute) {\n                viewBox = viewBoxAttribute.split(' ')\n                size[0] = parseFloat(viewBox[2])\n                size[1] = parseFloat(viewBox[3])\n              }\n            }\n            if (Vec.isEqual(size, [0, 0])) {\n              size = await getImageSizeFromSrc(src)\n            }\n          } else {\n            size = await getVideoSizeFromSrc(src)\n          }\n\n          const match = Object.values(this.document.assets).find(\n            (asset) => asset.type === assetType && asset.src === src\n          )\n\n          let assetId: string\n\n          if (!match) {\n            assetId = id\n\n            const asset = {\n              id: assetId,\n              type: assetType,\n              name: file.name,\n              src,\n              size,\n            }\n\n            this.patchState({\n              document: {\n                assets: {\n                  [assetId]: asset,\n                },\n              },\n            })\n          } else {\n            assetId = match.id\n          }\n\n          shapesToCreate.push(this.getImageOrVideoShapeAtPoint(id, shapeType, point, size, assetId))\n        }\n      } catch (error) {\n        // Even if one shape errors, keep going (we might have had other shapes that didn't error)\n        console.warn(error)\n      }\n    }\n\n    if (shapesToCreate.length) {\n      const currentPoint = Vec.add(pagePoint, [0, 0])\n\n      shapesToCreate.forEach((shape, i) => {\n        const bounds = TLDR.getBounds(shape)\n\n        if (i === 0) {\n          // For the first shape, offset the current point so\n          // that the first shape's center is at the page point\n          currentPoint[0] -= bounds.width / 2\n          currentPoint[1] -= bounds.height / 2\n        }\n\n        // Set the shape's point the current point\n        shape.point = [...currentPoint]\n\n        // Then bump the page current point by this shape's width\n        currentPoint[0] += bounds.width\n      })\n\n      const commonBounds = Utils.getCommonBounds(shapesToCreate.map(TLDR.getBounds))\n\n      this.createShapes(...shapesToCreate)\n\n      // Are the common bounds too big for the viewport?\n      if (!Utils.boundsContain(this.viewport, commonBounds)) {\n        this.zoomToSelection()\n        if (this.zoom > 1) {\n          this.resetZoom()\n        }\n      }\n    }\n\n    this.setIsLoading(false)\n    return this\n  }\n\n  private getViewboxFromSVG = (svgStr: string | ArrayBuffer | null) => {\n    const viewBoxRegex = /.*?viewBox=[\"'](-?[\\d.]+[, ]+-?[\\d.]+[, ][\\d.]+[, ][\\d.]+)[\"']/\n\n    if (typeof svgStr === 'string') {\n      const matches = svgStr.match(viewBoxRegex)\n      return matches && matches.length >= 2 ? matches[1] : null\n    }\n\n    this.setIsLoading(false)\n\n    return null\n  }\n\n  /* -------------------------------------------------- */\n  /*                   Event Handlers                   */\n  /* -------------------------------------------------- */\n\n  /* ----------------- Keyboard Events ---------------- */\n\n  onKeyDown: TLKeyboardEventHandler = (key, info, e) => {\n    switch (e.key) {\n      case '/': {\n        if (this.status === 'idle' && !this.pageState.editingId) {\n          const { shiftKey, metaKey, altKey, ctrlKey, spaceKey } = this\n\n          this.onPointerDown(\n            {\n              target: 'canvas',\n              pointerId: 0,\n              origin: info.point,\n              point: info.point,\n              delta: [0, 0],\n              pressure: 0.5,\n              shiftKey,\n              ctrlKey,\n              metaKey,\n              altKey,\n              spaceKey,\n            },\n            {\n              shiftKey,\n              altKey,\n              ctrlKey,\n              pointerId: 0,\n              clientX: info.point[0],\n              clientY: info.point[1],\n            } as unknown as React.PointerEvent<HTMLDivElement>\n          )\n        }\n        break\n      }\n      case 'Escape': {\n        this.cancel()\n        break\n      }\n      case 'Meta': {\n        this.metaKey = true\n        break\n      }\n      case 'Alt': {\n        this.altKey = true\n        break\n      }\n      case 'Control': {\n        this.ctrlKey = true\n        break\n      }\n      case ' ': {\n        this.isForcePanning = true\n        this.spaceKey = true\n        break\n      }\n    }\n\n    this.currentTool.onKeyDown?.(key, info, e)\n\n    return this\n  }\n\n  onKeyUp: TLKeyboardEventHandler = (key, info, e) => {\n    if (!info) return\n\n    switch (e.key) {\n      case '/': {\n        const { currentPoint, shiftKey, metaKey, altKey, ctrlKey, spaceKey } = this\n\n        this.onPointerUp(\n          {\n            target: 'canvas',\n            pointerId: 0,\n            origin: currentPoint,\n            point: currentPoint,\n            delta: [0, 0],\n            pressure: 0.5,\n            shiftKey,\n            ctrlKey,\n            metaKey,\n            altKey,\n            spaceKey,\n          },\n          {\n            shiftKey,\n            altKey,\n            ctrlKey,\n            pointerId: 0,\n            clientX: currentPoint[0],\n            clientY: currentPoint[1],\n          } as unknown as React.PointerEvent<HTMLDivElement>\n        )\n        break\n      }\n      case 'Meta': {\n        this.metaKey = false\n        break\n      }\n      case 'Alt': {\n        this.altKey = false\n        break\n      }\n      case 'Control': {\n        this.ctrlKey = false\n        break\n      }\n      case ' ': {\n        this.isForcePanning = false\n        this.spaceKey = false\n        break\n      }\n    }\n\n    this.currentTool.onKeyUp?.(key, info, e)\n  }\n\n  /** Force bounding boxes to reset when the document loads. */\n  refreshBoundingBoxes = () => {\n    // force a change to every text shape\n    const force = this.shapes.map((shape) => {\n      return [\n        shape.id,\n        {\n          point: [...shape.point],\n          ...('label' in shape && { label: '' }),\n        },\n      ]\n    })\n\n    const restore = this.shapes.map((shape) => {\n      return [\n        shape.id,\n        {\n          point: [...shape.point],\n          ...('label' in shape && { label: shape.label }),\n        },\n      ]\n    })\n\n    clearPrevSize()\n\n    this.patchState({\n      document: {\n        pages: {\n          [this.currentPageId]: {\n            shapes: Object.fromEntries(force),\n          },\n        },\n      },\n    })\n    this.patchState({\n      document: {\n        pages: {\n          [this.currentPageId]: {\n            shapes: Object.fromEntries(restore),\n          },\n        },\n      },\n    })\n  }\n\n  /* ------------- Renderer Event Handlers ------------ */\n\n  onDragOver: TLDropEventHandler = (e) => {\n    e.preventDefault()\n  }\n\n  onDrop: TLDropEventHandler = async (e) => {\n    e.preventDefault()\n    if (this.disableAssets) return this\n    if (e.dataTransfer.files?.length) {\n      this.addMediaFromFiles(Object.values(e.dataTransfer.files), [e.clientX, e.clientY])\n    }\n    return this\n  }\n\n  onPinchStart: TLPinchEventHandler = (info, e) => {\n    this.currentTool.onPinchStart?.(info, e)\n  }\n\n  onPinchEnd: TLPinchEventHandler = (info, e) => this.currentTool.onPinchEnd?.(info, e)\n\n  onPinch: TLPinchEventHandler = (info, e) => this.currentTool.onPinch?.(info, e)\n\n  onPan: TLWheelEventHandler = (info, e) => {\n    if (this.appState.status === 'pinching') return\n    // TODO: Pan and pinchzoom are firing at the same time. Considering turning one of them off!\n\n    const delta = Vec.div(info.delta, this.camera.zoom)\n    const prev = this.camera.point\n    const next = Vec.sub(prev, delta)\n\n    if (Vec.isEqual(next, prev)) return\n\n    this.pan(delta)\n\n    // When panning, we also want to call onPointerMove, except when \"force panning\" via spacebar / middle wheel button (it's called elsewhere in that case)\n    if (!this.isForcePanning) this.onPointerMove(info, e as unknown as React.PointerEvent)\n\n    // prevent middle click paste on linux\n    if (isLinux && this.isForcePanning) this.preventPaste()\n  }\n\n  onZoom: TLWheelEventHandler = (info, e) => {\n    if (this.state.appState.status !== TDStatus.Idle) return\n    const delta = info.delta[2] / 50\n    this.zoomBy(delta, info.point)\n    this.onPointerMove(info, e as unknown as React.PointerEvent)\n  }\n\n  /* ----------------- Pointer Events ----------------- */\n\n  updateInputs: TLPointerEventHandler = (info) => {\n    this.currentPoint = this.getPagePoint(info.point).concat(info.pressure)\n    this.shiftKey = info.shiftKey\n    this.altKey = info.altKey\n    this.ctrlKey = info.ctrlKey\n    this.metaKey = info.metaKey\n  }\n\n  onPointerMove: TLPointerEventHandler = (info, e) => {\n    this.previousPoint = this.currentPoint\n    this.updateInputs(info, e)\n    if (this.isForcePanning && this.isPointing) {\n      this.onPan?.({ ...info, delta: Vec.neg(info.delta) }, e as unknown as WheelEvent)\n      return\n    }\n\n    // Several events (e.g. pan) can trigger the same \"pointer move\" behavior\n    this.currentTool.onPointerMove?.(info, e)\n\n    // Move this to an emitted event\n    if (this.state.room) {\n      const { users, userId } = this.state.room\n\n      this.callbacks.onChangePresence?.(this, {\n        ...users[userId],\n        point: this.getPagePoint(info.point),\n        session: !!this.session,\n      })\n    }\n  }\n\n  onPointerDown: TLPointerEventHandler = (info, e) => {\n    if (e.buttons === 4) {\n      this.isForcePanning = true\n    } else if (this.isPointing) {\n      return\n    }\n    this.isPointing = true\n    this.originPoint = this.getPagePoint(info.point).concat(info.pressure)\n    this.updateInputs(info, e)\n    if (this.isForcePanning) return\n    if (this.currentTool.type === TDShapeType.Draw && e.pointerType === 'pen' && e.button === 5) {\n      this.selectTool('erase')\n      this.isErasingWithPen = true\n    }\n    this.currentTool.onPointerDown?.(info, e)\n  }\n\n  onPointerUp: TLPointerEventHandler = (info, e) => {\n    this.isPointing = false\n    if (!this.shiftKey) this.isForcePanning = false\n    this.updateInputs(info, e)\n    this.currentTool.onPointerUp?.(info, e)\n    if (this.isErasingWithPen && e.pointerType === 'pen' && e.button === 5) {\n      this.selectTool(TDShapeType.Draw)\n      this.isErasingWithPen = false\n    }\n  }\n\n  // Canvas (background)\n  onPointCanvas: TLCanvasEventHandler = (info, e) => {\n    this.updateInputs(info, e)\n    this.currentTool.onPointCanvas?.(info, e)\n  }\n\n  onDoubleClickCanvas: TLCanvasEventHandler = (info, e) => {\n    this.updateInputs(info, e)\n    this.currentTool.onDoubleClickCanvas?.(info, e)\n  }\n\n  onRightPointCanvas: TLCanvasEventHandler = (info, e) => {\n    this.updateInputs(info, e)\n    this.currentTool.onRightPointCanvas?.(info, e)\n  }\n\n  onDragCanvas: TLCanvasEventHandler = (info, e) => {\n    this.updateInputs(info, e)\n    this.currentTool.onDragCanvas?.(info, e)\n  }\n\n  onReleaseCanvas: TLCanvasEventHandler = (info, e) => {\n    this.updateInputs(info, e)\n    this.currentTool.onReleaseCanvas?.(info, e)\n  }\n\n  // Shape\n  onPointShape: TLPointerEventHandler = (info, e) => {\n    this.originPoint = this.getPagePoint(info.point).concat(info.pressure)\n    this.updateInputs(info, e)\n    this.currentTool.onPointShape?.(info, e)\n  }\n\n  onReleaseShape: TLPointerEventHandler = (info, e) => {\n    this.updateInputs(info, e)\n    this.currentTool.onReleaseShape?.(info, e)\n  }\n\n  onDoubleClickShape: TLPointerEventHandler = (info, e) => {\n    this.originPoint = this.getPagePoint(info.point).concat(info.pressure)\n    this.updateInputs(info, e)\n    this.currentTool.onDoubleClickShape?.(info, e)\n  }\n\n  onRightPointShape: TLPointerEventHandler = (info, e) => {\n    this.originPoint = this.getPagePoint(info.point).concat(info.pressure)\n    this.updateInputs(info, e)\n    this.currentTool.onRightPointShape?.(info, e)\n  }\n\n  onDragShape: TLPointerEventHandler = (info, e) => {\n    this.updateInputs(info, e)\n    this.currentTool.onDragShape?.(info, e)\n  }\n\n  onHoverShape: TLPointerEventHandler = (info, e) => {\n    this.updateInputs(info, e)\n    this.currentTool.onHoverShape?.(info, e)\n  }\n\n  onUnhoverShape: TLPointerEventHandler = (info, e) => {\n    this.updateInputs(info, e)\n    this.currentTool.onUnhoverShape?.(info, e)\n  }\n\n  // Bounds (bounding box background)\n  onPointBounds: TLBoundsEventHandler = (info, e) => {\n    this.originPoint = this.getPagePoint(info.point).concat(info.pressure)\n    this.updateInputs(info, e)\n    this.currentTool.onPointBounds?.(info, e)\n  }\n\n  onDoubleClickBounds: TLBoundsEventHandler = (info, e) => {\n    this.originPoint = this.getPagePoint(info.point).concat(info.pressure)\n    this.updateInputs(info, e)\n    this.currentTool.onDoubleClickBounds?.(info, e)\n  }\n\n  onRightPointBounds: TLBoundsEventHandler = (info, e) => {\n    this.originPoint = this.getPagePoint(info.point).concat(info.pressure)\n    this.updateInputs(info, e)\n    this.currentTool.onRightPointBounds?.(info, e)\n  }\n\n  onDragBounds: TLBoundsEventHandler = (info, e) => {\n    this.updateInputs(info, e)\n    this.currentTool.onDragBounds?.(info, e)\n  }\n\n  onHoverBounds: TLBoundsEventHandler = (info, e) => {\n    this.updateInputs(info, e)\n    this.currentTool.onHoverBounds?.(info, e)\n  }\n\n  onUnhoverBounds: TLBoundsEventHandler = (info, e) => {\n    this.updateInputs(info, e)\n    this.currentTool.onUnhoverBounds?.(info, e)\n  }\n\n  onReleaseBounds: TLBoundsEventHandler = (info, e) => {\n    this.updateInputs(info, e)\n    this.currentTool.onReleaseBounds?.(info, e)\n  }\n\n  // Bounds handles (corners, edges)\n  onPointBoundsHandle: TLBoundsHandleEventHandler = (info, e) => {\n    this.originPoint = this.getPagePoint(info.point).concat(info.pressure)\n    this.updateInputs(info, e)\n    this.currentTool.onPointBoundsHandle?.(info, e)\n  }\n\n  onDoubleClickBoundsHandle: TLBoundsHandleEventHandler = (info, e) => {\n    this.originPoint = this.getPagePoint(info.point).concat(info.pressure)\n    this.updateInputs(info, e)\n    this.currentTool.onDoubleClickBoundsHandle?.(info, e)\n\n    // hack time to reset the size / clipping of an image\n    if (this.selectedIds.length !== 1) return\n\n    const shape = this.getShape(this.selectedIds[0])\n\n    if (shape.type === TDShapeType.Image || shape.type === TDShapeType.Video) {\n      const asset = this.document.assets[shape.assetId]\n      const util = TLDR.getShapeUtil(shape)\n      const centerA = util.getCenter(shape)\n      const centerB = util.getCenter({ ...shape, size: asset.size })\n      const delta = Vec.sub(centerB, centerA)\n\n      this.updateShapes({\n        id: shape.id,\n        point: Vec.sub(shape.point, delta),\n        size: asset.size,\n      })\n    }\n  }\n\n  onRightPointBoundsHandle: TLBoundsHandleEventHandler = (info, e) => {\n    this.originPoint = this.getPagePoint(info.point).concat(info.pressure)\n    this.updateInputs(info, e)\n    this.currentTool.onRightPointBoundsHandle?.(info, e)\n  }\n\n  onDragBoundsHandle: TLBoundsHandleEventHandler = (info, e) => {\n    this.updateInputs(info, e)\n    this.currentTool.onDragBoundsHandle?.(info, e)\n  }\n\n  onHoverBoundsHandle: TLBoundsHandleEventHandler = (info, e) => {\n    this.updateInputs(info, e)\n    this.currentTool.onHoverBoundsHandle?.(info, e)\n  }\n\n  onUnhoverBoundsHandle: TLBoundsHandleEventHandler = (info, e) => {\n    this.updateInputs(info, e)\n    this.currentTool.onUnhoverBoundsHandle?.(info, e)\n  }\n\n  onReleaseBoundsHandle: TLBoundsHandleEventHandler = (info, e) => {\n    this.updateInputs(info, e)\n    this.currentTool.onReleaseBoundsHandle?.(info, e)\n  }\n\n  // Handles (ie the handles of a selected arrow)\n  onPointHandle: TLPointerEventHandler = (info, e) => {\n    this.originPoint = this.getPagePoint(info.point).concat(info.pressure)\n    this.updateInputs(info, e)\n    this.currentTool.onPointHandle?.(info, e)\n  }\n\n  onDoubleClickHandle: TLPointerEventHandler = (info, e) => {\n    this.originPoint = this.getPagePoint(info.point).concat(info.pressure)\n    this.updateInputs(info, e)\n    this.currentTool.onDoubleClickHandle?.(info, e)\n  }\n\n  onRightPointHandle: TLPointerEventHandler = (info, e) => {\n    this.originPoint = this.getPagePoint(info.point).concat(info.pressure)\n    this.updateInputs(info, e)\n    this.currentTool.onRightPointHandle?.(info, e)\n  }\n\n  onDragHandle: TLPointerEventHandler = (info, e) => {\n    this.updateInputs(info, e)\n    this.currentTool.onDragHandle?.(info, e)\n  }\n\n  onHoverHandle: TLPointerEventHandler = (info, e) => {\n    this.updateInputs(info, e)\n    this.currentTool.onHoverHandle?.(info, e)\n  }\n\n  onUnhoverHandle: TLPointerEventHandler = (info, e) => {\n    this.updateInputs(info, e)\n    this.currentTool.onUnhoverHandle?.(info, e)\n  }\n\n  onReleaseHandle: TLPointerEventHandler = (info, e) => {\n    this.updateInputs(info, e)\n    this.currentTool.onReleaseHandle?.(info, e)\n  }\n\n  onShapeChange = (shape: { id: string } & Partial<TLShape>) => {\n    const pageShapes = this.document.pages[this.currentPageId].shapes\n    const shapeToUpdate = { ...(pageShapes[shape.id] as any), ...shape }\n    const patch = Commands.updateShapes(this, [shapeToUpdate], this.currentPageId).after\n    return this.patchState(patch, 'patched_shapes')\n    // this.updateShapes(shape)\n  }\n\n  onShapeBlur = () => {\n    // This prevents an auto-blur event from Safari\n    if (performance.now() - this.editingStartTime < 50) return\n\n    const { editingId } = this.pageState\n    const { isToolLocked } = this.getAppState()\n\n    if (editingId) {\n      // If we're editing text, then delete the text if it's empty\n      const shape = this.getShape(editingId)\n      this.setEditingId()\n      if (shape.type === TDShapeType.Text) {\n        if (shape.text.trim().length <= 0) {\n          this.patchState(Commands.deleteShapes(this, [editingId]).after, 'delete_empty_text')\n        } else if (!isToolLocked) {\n          this.select(editingId)\n        }\n      }\n    }\n\n    this.currentTool.onShapeBlur?.()\n  }\n\n  onShapeClone: TLShapeCloneHandler = (info, e) => {\n    this.originPoint = this.getPagePoint(info.point).concat(info.pressure)\n    this.updateInputs(info, e)\n    this.currentTool.onShapeClone?.(info, e)\n  }\n\n  onRenderCountChange = (ids: string[]) => {\n    const appState = this.getAppState()\n    if (appState.isEmptyCanvas && ids.length > 0) {\n      this.patchState(\n        {\n          appState: {\n            isEmptyCanvas: false,\n          },\n        },\n        'empty_canvas:false'\n      )\n    } else if (!appState.isEmptyCanvas && ids.length <= 0) {\n      this.patchState(\n        {\n          appState: {\n            isEmptyCanvas: true,\n          },\n        },\n        'empty_canvas:true'\n      )\n    }\n  }\n\n  onError = () => {\n    // TODO\n  }\n\n  isSelected(id: string) {\n    return this.selectedIds.includes(id)\n  }\n\n  /* ----------------- Export ----------------- */\n\n  /**\n   * Get a snapshot of a video at current frame as base64 encoded image\n   * @param id ID of video shape\n   * @returns base64 encoded frame\n   * @throws Error if video shape with given ID does not exist\n   */\n  serializeVideo(id: string): string {\n    const video = document.getElementById(id + '_video') as HTMLVideoElement\n    if (video) {\n      const canvas = document.createElement('canvas')\n      canvas.width = video.videoWidth\n      canvas.height = video.videoHeight\n      canvas.getContext('2d')!.drawImage(video, 0, 0)\n      return canvas.toDataURL('image/png')\n    } else throw new Error('Video with id ' + id + ' not found')\n  }\n\n  /**\n   * Get a snapshot of a image (e.g. a GIF) as base64 encoded image\n   * @param id ID of image shape\n   * @returns base64 encoded frame\n   * @throws Error if image shape with given ID does not exist\n   */\n  serializeImage(id: string): string {\n    const image = document.getElementById(id + '_image') as HTMLImageElement\n    if (image) {\n      const canvas = document.createElement('canvas')\n      canvas.width = image.width\n      canvas.height = image.height\n      canvas.getContext('2d')!.drawImage(image, 0, 0)\n      return canvas.toDataURL('image/png')\n    } else throw new Error('Image with id ' + id + ' not found')\n  }\n\n  patchAssets(assets: TDAssets) {\n    this.document.assets = {\n      ...this.document.assets,\n      ...assets,\n    }\n  }\n\n  get room() {\n    return this.state.room\n  }\n\n  get isLocal() {\n    return this.state.room === undefined || this.state.room.id === 'local'\n  }\n\n  get status() {\n    return this.appState.status\n  }\n\n  get currentUser() {\n    if (!this.state.room) return\n    return this.state.room.users[this.state.room.userId]\n  }\n\n  // The center of the component (in screen space)\n  get centerPoint() {\n    const { width, height } = this.rendererBounds\n    return Vec.toFixed([width / 2, height / 2])\n  }\n\n  get currentGrid() {\n    const { zoom } = this.camera\n    if (zoom < 0.15) {\n      return GRID_SIZE * 16\n    } else if (zoom < 1) {\n      return GRID_SIZE * 4\n    } else {\n      return GRID_SIZE * 1\n    }\n  }\n\n  getShapeUtil = TLDR.getShapeUtil\n\n  static version = 15.5\n\n  static defaultDocument: TDDocument = {\n    id: 'doc',\n    name: 'New Document',\n    version: TldrawApp.version,\n    pages: {\n      page: {\n        id: 'page',\n        name: 'Page 1',\n        childIndex: 1,\n        shapes: {},\n        bindings: {},\n      },\n    },\n    pageStates: {\n      page: {\n        id: 'page',\n        selectedIds: [],\n        camera: {\n          point: [0, 0],\n          zoom: 1,\n        },\n      },\n    },\n    assets: {},\n  }\n\n  static defaultState: TDSnapshot = {\n    settings: {\n      isCadSelectMode: false,\n      isPenMode: false,\n      isDarkMode: false,\n      isZoomSnap: false,\n      isFocusMode: false,\n      isSnapping: false,\n      isDebugMode: false,\n      isReadonlyMode: false,\n      keepStyleMenuOpen: false,\n      nudgeDistanceLarge: 16,\n      nudgeDistanceSmall: 1,\n      showRotateHandles: true,\n      showBindingHandles: true,\n      showCloneHandles: false,\n      showGrid: false,\n      language: 'en',\n      dockPosition: 'bottom',\n      exportBackground: TDExportBackground.Transparent,\n    },\n    appState: {\n      status: TDStatus.Idle,\n      activeTool: 'select',\n      hoveredId: undefined,\n      currentPageId: 'page',\n      currentStyle: defaultStyle,\n      isToolLocked: false,\n      isMenuOpen: false,\n      isEmptyCanvas: false,\n      eraseLine: [],\n      snapLines: [],\n      isLoading: false,\n      disableAssets: false,\n    },\n    document: TldrawApp.defaultDocument,\n  }\n\n  static assetSrc = 'tldraw-assets.json'\n}\n", "import { del, get, set } from 'idb-keyval'\n\n// Used for clipboard\n\nconst ID = 'tldraw_clipboard'\n\nexport async function getClipboard(): Promise<string | undefined> {\n  return get(ID)\n}\n\nexport async function setClipboard(item: string): Promise<void> {\n  return set(ID, item)\n}\n\nexport function clearClipboard(): Promise<void> {\n  return del(ID)\n}\n", "import { Utils } from '@tldraw/core'\nimport * as idb from 'idb-keyval'\nimport create, { UseBoundStore } from 'zustand'\nimport createVanilla, { StoreApi } from 'zustand/vanilla'\nimport type { Command, Patch } from '~types'\nimport { deepCopy } from './copy'\n\nexport class StateManager<T extends Record<string, any>> {\n  /**\n   * An ID used to persist state in indexdb.\n   */\n  protected _idbId?: string\n\n  /**\n   * The initial state.\n   */\n  private initialState: T\n\n  /**\n   * A zustand store that also holds the state.\n   */\n  private store: StoreApi<T>\n\n  /**\n   * The index of the current command.\n   */\n  protected pointer = -1\n\n  /**\n   * The current state.\n   */\n  private _state: T\n\n  /**\n   * The state manager's current status, with regard to restoring persisted state.\n   */\n  private _status: 'loading' | 'ready' = 'loading'\n\n  /**\n   * A stack of commands used for history (undo and redo).\n   */\n  protected stack: Command<T>[] = []\n\n  /**\n   * A snapshot of the current state.\n   */\n  protected _snapshot: T\n\n  /**\n   * A React hook for accessing the zustand store.\n   */\n  public readonly useStore: UseBoundStore<StoreApi<T>>\n\n  /**\n   * A promise that will resolve when the state manager has loaded any peristed state.\n   */\n  public ready: Promise<'none' | 'restored' | 'migrated'>\n\n  public isPaused = false\n\n  constructor(\n    initialState: T,\n    id?: string,\n    version?: number,\n    update?: (prev: T, next: T, prevVersion: number) => T\n  ) {\n    this._idbId = id\n    this._state = deepCopy(initialState)\n    this._snapshot = deepCopy(initialState)\n    this.initialState = deepCopy(initialState)\n    this.store = createVanilla(() => this._state)\n    this.useStore = create(this.store)\n\n    this.ready = new Promise<'none' | 'restored' | 'migrated'>((resolve) => {\n      let message: 'none' | 'restored' | 'migrated' = 'none'\n\n      if (this._idbId) {\n        message = 'restored'\n\n        idb\n          .get(this._idbId)\n          .then(async (saved) => {\n            if (saved) {\n              let next = saved\n\n              if (version) {\n                const savedVersion = await idb.get<number>(id + '_version')\n\n                if (savedVersion && savedVersion < version) {\n                  next = update ? update(saved, initialState, savedVersion) : initialState\n\n                  message = 'migrated'\n                }\n              }\n\n              await idb.set(id + '_version', version || -1)\n\n              // why is this necessary? but it is...\n              const prevEmpty = this._state.appState.isEmptyCanvas\n\n              next = this.migrate(next)\n\n              this._state = deepCopy(next)\n              this._snapshot = deepCopy(next)\n\n              this._state.appState.isEmptyCanvas = prevEmpty\n              this.store.setState(this._state, true)\n            } else {\n              await idb.set(id + '_version', version || -1)\n            }\n            this._status = 'ready'\n            resolve(message)\n          })\n          .catch((e) => console.error(e))\n      } else {\n        // We need to wait for any override to `onReady` to take effect.\n        this._status = 'ready'\n        resolve(message)\n      }\n    }).then((message) => {\n      if (this.onReady) this.onReady(message)\n      return message\n    })\n  }\n\n  /**\n   * Save the current state to indexdb.\n   */\n  protected persist = (patch: Patch<T>, id?: string): void | Promise<void> => {\n    if (this._status !== 'ready') return\n\n    if (this.onPersist) {\n      this.onPersist(this._state, patch, id)\n    }\n\n    if (this._idbId) {\n      return idb.set(this._idbId, this._state).catch((e) => console.error(e))\n    }\n  }\n\n  /**\n   * Apply a patch to the current state.\n   * This does not effect the undo/redo stack.\n   * This does not persist the state.\n   * @param patch The patch to apply.\n   * @param id (optional) An id for the patch.\n   */\n  private applyPatch = (patch: Patch<T>, id?: string) => {\n    const prev = this._state\n    const next = Utils.deepMerge(this._state, patch as any)\n    const final = this.cleanup(next, prev, patch, id)\n    if (this.onStateWillChange) {\n      this.onStateWillChange(final, id)\n    }\n    this._state = final\n    this.store.setState(this._state, true)\n    if (this.onStateDidChange) {\n      this.onStateDidChange(this._state, id)\n    }\n    return this\n  }\n\n  // Internal API ---------------------------------\n\n  protected migrate = (next: T): T => {\n    return next\n  }\n\n  /**\n   * Perform any last changes to the state before updating.\n   * Override this on your extending class.\n   * @param nextState The next state.\n   * @param prevState The previous state.\n   * @param patch The patch that was just applied.\n   * @param id (optional) An id for the just-applied patch.\n   * @returns The final new state to apply.\n   */\n  protected cleanup = (nextState: T, _prevState: T, _patch: Patch<T>, _id?: string): T => nextState\n\n  /**\n   * A life-cycle method called when the state is about to change.\n   * @param state The next state.\n   * @param id An id for the change.\n   */\n  protected onStateWillChange?: (state: T, id?: string) => void\n\n  /**\n   * A life-cycle method called when the state has changed.\n   * @param state The next state.\n   * @param id An id for the change.\n   */\n  protected onStateDidChange?: (state: T, id?: string) => void\n\n  /**\n   * Apply a patch to the current state.\n   * This does not effect the undo/redo stack.\n   * This does not persist the state.\n   * @param patch The patch to apply.\n   * @param id (optional) An id for this patch.\n   */\n  patchState = (patch: Patch<T>, id?: string): this => {\n    this.applyPatch(patch, id)\n    if (this.onPatch) {\n      this.onPatch(this._state, patch, id)\n    }\n    return this\n  }\n\n  /**\n   * Replace the current state.\n   * This does not effect the undo/redo stack.\n   * This does not persist the state.\n   * @param state The new state.\n   * @param id An id for this change.\n   */\n  protected replaceState = (state: T, id?: string): this => {\n    const final = this.cleanup(state, this._state, state, id)\n    if (this.onStateWillChange) {\n      this.onStateWillChange(final, 'replace')\n    }\n    this._state = final\n    this.store.setState(this._state, true)\n    if (this.onStateDidChange) {\n      this.onStateDidChange(this._state, 'replace')\n    }\n    return this\n  }\n\n  /**\n   * Update the state using a Command.\n   * This effects the undo/redo stack.\n   * This persists the state.\n   * @param command The command to apply and add to the undo/redo stack.\n   * @param id (optional) An id for this command.\n   */\n  protected setState = (command: Command<T>, id = command.id) => {\n    if (this.pointer < this.stack.length - 1) {\n      this.stack = this.stack.slice(0, this.pointer + 1)\n    }\n    this.stack.push({ ...command, id })\n    this.pointer = this.stack.length - 1\n    this.applyPatch(command.after, id)\n    if (this.onCommand) this.onCommand(this._state, command, id)\n    this.persist(command.after, id)\n    return this\n  }\n\n  // Public API ---------------------------------\n\n  public pause() {\n    this.isPaused = true\n  }\n\n  public resume() {\n    this.isPaused = false\n  }\n\n  /**\n   * A callback fired when the constructor finishes loading any\n   * persisted data.\n   */\n  protected onReady?: (message: 'none' | 'restored' | 'migrated') => void\n\n  /**\n   * A callback fired when a patch is applied.\n   */\n  public onPatch?: (state: T, patch: Patch<T>, id?: string) => void\n\n  /**\n   * A callback fired when a patch is applied.\n   */\n  public onCommand?: (state: T, command: Command<T>, id?: string) => void\n\n  /**\n   * A callback fired when the state is persisted.\n   */\n  public onPersist?: (state: T, patch: Patch<T>, id?: string) => void\n\n  /**\n   * A callback fired when the state is replaced.\n   */\n  public onReplace?: (state: T) => void\n\n  /**\n   * A callback fired when the state is reset.\n   */\n  public onReset?: (state: T) => void\n\n  /**\n   * A callback fired when the history is reset.\n   */\n  public onResetHistory?: (state: T) => void\n\n  /**\n   * A callback fired when a command is undone.\n   */\n  public onUndo?: (state: T) => void\n\n  /**\n   * A callback fired when a command is redone.\n   */\n  public onRedo?: (state: T) => void\n\n  /**\n   * Reset the state to the initial state and reset history.\n   */\n  public reset = () => {\n    if (this.onStateWillChange) {\n      this.onStateWillChange(this.initialState, 'reset')\n    }\n    this._state = this.initialState\n    this.store.setState(this._state, true)\n    this.resetHistory()\n    this.persist({}, 'reset')\n    if (this.onStateDidChange) {\n      this.onStateDidChange(this._state, 'reset')\n    }\n    if (this.onReset) {\n      this.onReset(this._state)\n    }\n    return this\n  }\n\n  /**\n   * Force replace a new undo/redo history. It's your responsibility\n   * to make sure that this is compatible with the current state!\n   * @param history The new array of commands.\n   * @param pointer (optional) The new pointer position.\n   */\n  public replaceHistory = (history: Command<T>[], pointer = history.length - 1): this => {\n    this.stack = history\n    this.pointer = pointer\n    if (this.onReplace) {\n      this.onReplace(this._state)\n    }\n    return this\n  }\n\n  /**\n   * Reset the history stack (without resetting the state).\n   */\n  public resetHistory = (): this => {\n    this.stack = []\n    this.pointer = -1\n    if (this.onResetHistory) {\n      this.onResetHistory(this._state)\n    }\n    return this\n  }\n\n  /**\n   * Move backward in the undo/redo stack.\n   */\n  public undo = (): this => {\n    if (!this.isPaused) {\n      if (!this.canUndo) return this\n      const command = this.stack[this.pointer]\n      this.pointer--\n      this.applyPatch(command.before, `undo`)\n      this.persist(command.before, 'undo')\n    }\n    if (this.onUndo) this.onUndo(this._state)\n    return this\n  }\n\n  /**\n   * Move forward in the undo/redo stack.\n   */\n  public redo = (): this => {\n    if (!this.isPaused) {\n      if (!this.canRedo) return this\n      this.pointer++\n      const command = this.stack[this.pointer]\n      this.applyPatch(command.after, 'redo')\n      this.persist(command.after, 'undo')\n    }\n    if (this.onRedo) this.onRedo(this._state)\n    return this\n  }\n\n  /**\n   * Save a snapshot of the current state, accessible at `this.snapshot`.\n   */\n  public setSnapshot = (): this => {\n    this._snapshot = { ...this._state }\n    return this\n  }\n\n  /**\n   * Force the zustand state to update.\n   */\n  public forceUpdate = () => {\n    this.store.setState(this._state, true)\n  }\n\n  /**\n   * Get whether the state manager can undo.\n   */\n  public get canUndo(): boolean {\n    return this.pointer > -1\n  }\n\n  /**\n   * Get whether the state manager can redo.\n   */\n  public get canRedo(): boolean {\n    return this.pointer < this.stack.length - 1\n  }\n\n  /**\n   * The current state.\n   */\n  public get state(): T {\n    return this._state\n  }\n\n  /**\n   * The current status.\n   */\n  public get status(): string {\n    return this._status\n  }\n\n  /**\n   * The most-recent snapshot.\n   */\n  protected get snapshot(): T {\n    return this._snapshot\n  }\n}\n", "import { Utils } from '@tldraw/core'\nimport { Vec } from '@tldraw/vec'\nimport { TLDR } from '~state/TLDR'\nimport type { TldrawApp } from '~state/TldrawApp'\nimport { AlignType, TDShapeType, TldrawCommand } from '~types'\n\nexport function alignShapes(app: TldrawApp, ids: string[], type: AlignType): TldrawCommand {\n  const { currentPageId } = app\n\n  const initialShapes = ids.map((id) => app.getShape(id))\n\n  const boundsForShapes = initialShapes.map((shape) => {\n    return {\n      id: shape.id,\n      point: [...shape.point],\n      bounds: TLDR.getBounds(shape),\n    }\n  })\n\n  const commonBounds = Utils.getCommonBounds(boundsForShapes.map(({ bounds }) => bounds))\n\n  const midX = commonBounds.minX + commonBounds.width / 2\n  const midY = commonBounds.minY + commonBounds.height / 2\n\n  const deltaMap = Object.fromEntries(\n    boundsForShapes.map(({ id, point, bounds }) => {\n      return [\n        id,\n        {\n          prev: point,\n          next: {\n            [AlignType.Top]: [point[0], commonBounds.minY],\n            [AlignType.CenterVertical]: [point[0], midY - bounds.height / 2],\n            [AlignType.Bottom]: [point[0], commonBounds.maxY - bounds.height],\n            [AlignType.Left]: [commonBounds.minX, point[1]],\n            [AlignType.CenterHorizontal]: [midX - bounds.width / 2, point[1]],\n            [AlignType.Right]: [commonBounds.maxX - bounds.width, point[1]],\n          }[type],\n        },\n      ]\n    })\n  )\n\n  const { before, after } = TLDR.mutateShapes(\n    app.state,\n    ids,\n    (shape) => {\n      if (!deltaMap[shape.id]) return shape\n      return { point: deltaMap[shape.id].next }\n    },\n    currentPageId,\n    false\n  )\n\n  initialShapes.forEach((shape) => {\n    if (shape.type === TDShapeType.Group) {\n      const delta = Vec.sub(after[shape.id].point!, before[shape.id].point!)\n\n      shape.children.forEach((id) => {\n        const child = app.getShape(id)\n        before[child.id] = { point: child.point }\n        after[child.id] = { point: Vec.add(child.point, delta) }\n      })\n\n      delete before[shape.id]\n      delete after[shape.id]\n    }\n  })\n\n  return {\n    id: 'align',\n    before: {\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes: before,\n          },\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: ids,\n          },\n        },\n      },\n    },\n    after: {\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes: after,\n          },\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: ids,\n          },\n        },\n      },\n    },\n  }\n}\n", "import type { TldrawApp } from '~state/TldrawApp'\nimport type { TldrawCommand } from '~types'\n\nexport function changePage(app: TldrawApp, pageId: string): TldrawCommand {\n  return {\n    id: 'change_page',\n    before: {\n      appState: {\n        currentPageId: app.currentPageId,\n      },\n    },\n    after: {\n      appState: {\n        currentPageId: pageId,\n      },\n    },\n  }\n}\n", "import { TLPageState, Utils } from '@tldraw/core'\nimport type { TldrawApp } from '~state'\nimport { getIncrementedName } from '~state/commands/shared'\nimport type { TDPage, TldrawCommand } from '~types'\n\nexport function createPage(\n  app: TldrawApp,\n  center: number[],\n  pageId = Utils.uniqueId(),\n  pageName = 'Page'\n): TldrawCommand {\n  const { currentPageId } = app\n\n  const pages = Object.values(app.state.document.pages).sort(\n    (a, b) => (a.childIndex ?? 0) - (b.childIndex ?? 0)\n  )\n\n  const topPage = pages[pages.length - 1]\n\n  const nextChildIndex = topPage?.childIndex ? topPage?.childIndex + 1 : 1\n\n  const page: TDPage = {\n    id: pageId,\n    name: getIncrementedName(\n      pageName,\n      pages.map((p) => p.name ?? '')\n    ),\n    childIndex: nextChildIndex,\n    shapes: {},\n    bindings: {},\n  }\n\n  const pageState: TLPageState = {\n    id: pageId,\n    selectedIds: [],\n    camera: { point: center, zoom: 1 },\n    editingId: undefined,\n    bindingId: undefined,\n    hoveredId: undefined,\n    pointedId: undefined,\n  }\n\n  return {\n    id: 'create_page',\n    before: {\n      appState: {\n        currentPageId,\n      },\n      document: {\n        pages: {\n          [pageId]: undefined,\n        },\n        pageStates: {\n          [pageId]: undefined,\n        },\n      },\n    },\n    after: {\n      appState: {\n        currentPageId: page.id,\n      },\n      document: {\n        pages: {\n          [pageId]: page,\n        },\n        pageStates: {\n          [pageId]: pageState,\n        },\n      },\n    },\n  }\n}\n", "/**\n * Get an incremented name (e.g. Page 2) from a name (e.g. Page 1), based on an array of existing names.\n *\n * @param name The name to increment.\n * @param others The array of existing names.\n */\nexport function getIncrementedName(name: string, others: string[]) {\n  let result = name\n  const set = new Set(others)\n\n  while (set.has(result)) {\n    result = /^.*(\\d+)$/.exec(result)?.[1]\n      ? result.replace(/(\\d+)(?=\\D?)$/, (m) => (+m + 1).toString())\n      : `${result} 1`\n  }\n\n  return result\n}\n", "import { TLDR } from '~state/TLDR'\nimport type { ArrowShape, GroupShape, PagePartial, TDSnapshot } from '~types'\n\nexport function removeShapesFromPage(data: TDSnapshot, ids: string[], pageId: string) {\n  const before: PagePartial = {\n    shapes: {},\n    bindings: {},\n  }\n\n  const after: PagePartial = {\n    shapes: {},\n    bindings: {},\n  }\n\n  const parentsToUpdate: GroupShape[] = []\n  const deletedIds = new Set()\n  const assetsToRemove = new Set<string>()\n\n  // These are the shapes we're definitely going to delete\n\n  ids\n    .filter((id) => !TLDR.getShape(data, id, pageId).isLocked)\n    .forEach((id) => {\n      deletedIds.add(id)\n      const shape = TLDR.getShape(data, id, pageId)\n      before.shapes[id] = shape\n      after.shapes[id] = undefined\n\n      // Also delete the shape's children\n\n      if (shape.children !== undefined) {\n        shape.children.forEach((childId) => {\n          deletedIds.add(childId)\n          const child = TLDR.getShape(data, childId, pageId)\n          before.shapes[childId] = child\n          after.shapes[childId] = undefined\n        })\n      }\n\n      if (shape.parentId !== pageId) {\n        parentsToUpdate.push(TLDR.getShape(data, shape.parentId, pageId))\n      }\n\n      if (shape.assetId) {\n        assetsToRemove.add(shape.assetId)\n      }\n    })\n\n  parentsToUpdate.forEach((parent) => {\n    if (ids.includes(parent.id)) return\n    deletedIds.add(parent.id)\n    before.shapes[parent.id] = { children: parent.children }\n    after.shapes[parent.id] = { children: parent.children.filter((id) => !ids.includes(id)) }\n    if (after.shapes[parent.id]?.children!.length === 0) {\n      after.shapes[parent.id] = undefined\n      before.shapes[parent.id] = TLDR.getShape(data, parent.id, pageId)\n    }\n  })\n\n  // Recursively check for empty parents?\n\n  const page = TLDR.getPage(data, pageId)\n\n  // We also need to delete bindings that reference the deleted shapes\n  Object.values(page.bindings)\n    .filter((binding) => deletedIds.has(binding.fromId) || deletedIds.has(binding.toId))\n    .forEach((binding) => {\n      for (const id of [binding.toId, binding.fromId]) {\n        // If the binding references a deleted shape...\n        if (after.shapes[id] === undefined) {\n          // Delete this binding\n          before.bindings[binding.id] = binding\n          after.bindings[binding.id] = undefined\n\n          // Let's also look each the bound shape...\n          const shape = page.shapes[id]\n\n          // If the bound shape has a handle that references the deleted binding...\n          if (shape && shape.handles) {\n            Object.values(shape.handles)\n              .filter((handle) => handle.bindingId === binding.id)\n              .forEach((handle) => {\n                // Save the binding reference in the before patch\n                before.shapes[id] = {\n                  ...before.shapes[id],\n                  handles: {\n                    ...before.shapes[id]?.handles,\n                    [handle.id]: {\n                      ...before.shapes[id]?.handles?.[handle.id as keyof ArrowShape['handles']],\n                      bindingId: binding.id,\n                    },\n                  },\n                }\n\n                // Unless we're currently deleting the shape, remove the\n                // binding reference from the after patch\n                if (!deletedIds.has(id)) {\n                  after.shapes[id] = {\n                    ...after.shapes[id],\n                    handles: {\n                      ...after.shapes[id]?.handles,\n                      [handle.id]: {\n                        ...after.shapes[id]?.handles?.[handle.id as keyof ArrowShape['handles']],\n                        bindingId: undefined,\n                      },\n                    },\n                  }\n                }\n              })\n          }\n        }\n      }\n    })\n\n  // If any other shapes are using the deleted assets, don't remove them\n  Object.values(data.document.pages)\n    .flatMap((page) => Object.values(page.shapes))\n    .forEach((shape) => {\n      if ('assetId' in shape && shape.assetId && !deletedIds.has(shape.id)) {\n        assetsToRemove.delete(shape.assetId)\n      }\n    })\n\n  return { before, after, assetsToRemove: Array.from(assetsToRemove) }\n}\n", "import type { TldrawApp } from '~state/TldrawApp'\nimport type { Patch, TDBinding, TDShape, TldrawCommand } from '~types'\n\nexport function createShapes(\n  app: TldrawApp,\n  shapes: TDShape[],\n  bindings: TDBinding[] = []\n): TldrawCommand {\n  const { currentPageId } = app\n\n  const beforeShapes: Record<string, Patch<TDShape> | undefined> = {}\n  const afterShapes: Record<string, Patch<TDShape> | undefined> = {}\n\n  shapes.forEach((shape) => {\n    beforeShapes[shape.id] = undefined\n    afterShapes[shape.id] = shape\n  })\n\n  const beforeBindings: Record<string, Patch<TDBinding> | undefined> = {}\n  const afterBindings: Record<string, Patch<TDBinding> | undefined> = {}\n\n  bindings.forEach((binding) => {\n    beforeBindings[binding.id] = undefined\n    afterBindings[binding.id] = binding\n  })\n\n  return {\n    id: 'create',\n    before: {\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes: beforeShapes,\n            bindings: beforeBindings,\n          },\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: [...app.selectedIds],\n          },\n        },\n      },\n    },\n    after: {\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes: afterShapes,\n            bindings: afterBindings,\n          },\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: shapes.map((shape) => shape.id),\n          },\n        },\n      },\n    },\n  }\n}\n", "import type { TldrawApp } from '~state/TldrawApp'\nimport type { TldrawCommand } from '~types'\n\nexport function deletePage(app: TldrawApp, pageId: string): TldrawCommand {\n  const {\n    currentPageId,\n    document: { pages, pageStates },\n  } = app\n\n  const pagesArr = Object.values(pages).sort((a, b) => (a.childIndex || 0) - (b.childIndex || 0))\n\n  const currentIndex = pagesArr.findIndex((page) => page.id === pageId)\n\n  let nextCurrentPageId: string\n\n  if (pageId === currentPageId) {\n    if (currentIndex === pagesArr.length - 1) {\n      nextCurrentPageId = pagesArr[pagesArr.length - 2].id\n    } else {\n      nextCurrentPageId = pagesArr[currentIndex + 1].id\n    }\n  } else {\n    nextCurrentPageId = currentPageId\n  }\n\n  return {\n    id: 'delete_page',\n    before: {\n      appState: {\n        currentPageId: pageId,\n      },\n      document: {\n        pages: {\n          [pageId]: { ...pages[pageId] },\n        },\n        pageStates: {\n          [pageId]: { ...pageStates[pageId] },\n        },\n      },\n    },\n    after: {\n      appState: {\n        currentPageId: nextCurrentPageId,\n      },\n      document: {\n        pages: {\n          [pageId]: undefined,\n        },\n        pageStates: {\n          [pageId]: undefined,\n        },\n      },\n    },\n  }\n}\n", "import type { TldrawApp } from '~state/TldrawApp'\nimport { removeShapesFromPage } from '~state/commands/shared'\nimport type { TDAsset, TDAssets, TldrawCommand } from '~types'\n\nconst removeAssetsFromDocument = (assets: TDAssets, idsToRemove: string[]) => {\n  const afterAssets: Record<string, TDAsset | undefined> = { ...assets }\n  idsToRemove.forEach((id) => (afterAssets[id] = undefined))\n  return afterAssets\n}\n\nexport function deleteShapes(\n  app: TldrawApp,\n  ids: string[],\n  pageId = app.currentPageId\n): TldrawCommand {\n  const {\n    pageState,\n    selectedIds,\n    document: { assets: beforeAssets },\n  } = app\n  const { before, after, assetsToRemove } = removeShapesFromPage(app.state, ids, pageId)\n  const afterAssets = removeAssetsFromDocument(beforeAssets, assetsToRemove)\n\n  return {\n    id: 'delete',\n    before: {\n      document: {\n        assets: beforeAssets,\n        pages: {\n          [pageId]: before,\n        },\n        pageStates: {\n          [pageId]: { selectedIds: [...app.selectedIds] },\n        },\n      },\n    },\n    after: {\n      document: {\n        assets: afterAssets,\n        pages: {\n          [pageId]: after,\n        },\n        pageStates: {\n          [pageId]: {\n            selectedIds: selectedIds.filter((id) => !ids.includes(id)),\n            hoveredId:\n              pageState.hoveredId && ids.includes(pageState.hoveredId)\n                ? undefined\n                : pageState.hoveredId,\n          },\n        },\n      },\n    },\n  }\n}\n", "import { Utils } from '@tldraw/core'\nimport Vec from '@tldraw/vec'\nimport { TLDR } from '~state/TLDR'\nimport type { TldrawApp } from '~state/TldrawApp'\nimport { DistributeType, TDShape, TDShapeType, TldrawCommand } from '~types'\n\nexport function distributeShapes(\n  app: TldrawApp,\n  ids: string[],\n  type: DistributeType\n): TldrawCommand {\n  const { currentPageId } = app\n\n  const initialShapes = ids.map((id) => app.getShape(id))\n\n  const deltaMap = Object.fromEntries(getDistributions(initialShapes, type).map((d) => [d.id, d]))\n\n  const { before, after } = TLDR.mutateShapes(\n    app.state,\n    ids.filter((id) => deltaMap[id] !== undefined),\n    (shape) => ({ point: deltaMap[shape.id]?.next }),\n    currentPageId\n  )\n\n  initialShapes.forEach((shape) => {\n    if (shape.type === TDShapeType.Group) {\n      const delta = Vec.sub(after[shape.id].point!, before[shape.id].point!)\n\n      shape.children.forEach((id) => {\n        const child = app.getShape(id)\n        before[child.id] = { point: child.point }\n        after[child.id] = { point: Vec.add(child.point, delta) }\n      })\n\n      delete before[shape.id]\n      delete after[shape.id]\n    }\n  })\n\n  return {\n    id: 'distribute',\n    before: {\n      document: {\n        pages: {\n          [currentPageId]: { shapes: before },\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: ids,\n          },\n        },\n      },\n    },\n    after: {\n      document: {\n        pages: {\n          [currentPageId]: { shapes: after },\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: ids,\n          },\n        },\n      },\n    },\n  }\n}\n\nfunction getDistributions(initialShapes: TDShape[], type: DistributeType) {\n  const entries = initialShapes.map((shape) => {\n    const utils = TLDR.getShapeUtil(shape)\n    return {\n      id: shape.id,\n      point: [...shape.point],\n      bounds: utils.getBounds(shape),\n      center: utils.getCenter(shape),\n    }\n  })\n\n  const len = entries.length\n  const commonBounds = Utils.getCommonBounds(entries.map(({ bounds }) => bounds))\n\n  const results: { id: string; prev: number[]; next: number[] }[] = []\n\n  switch (type) {\n    case DistributeType.Horizontal: {\n      const span = entries.reduce((a, c) => a + c.bounds.width, 0)\n\n      if (span > commonBounds.width) {\n        const left = entries.sort((a, b) => a.bounds.minX - b.bounds.minX)[0]\n\n        const right = entries.sort((a, b) => b.bounds.maxX - a.bounds.maxX)[0]\n\n        const entriesToMove = entries\n          .filter((a) => a !== left && a !== right)\n          .sort((a, b) => a.center[0] - b.center[0])\n\n        const step = (right.center[0] - left.center[0]) / (len - 1)\n\n        const x = left.center[0] + step\n\n        entriesToMove.forEach(({ id, point, bounds }, i) => {\n          results.push({\n            id,\n            prev: point,\n            next: [x + step * i - bounds.width / 2, bounds.minY],\n          })\n        })\n      } else {\n        const entriesToMove = entries.sort((a, b) => a.center[0] - b.center[0])\n\n        let x = commonBounds.minX\n        const step = (commonBounds.width - span) / (len - 1)\n\n        entriesToMove.forEach(({ id, point, bounds }) => {\n          results.push({ id, prev: point, next: [x, bounds.minY] })\n          x += bounds.width + step\n        })\n      }\n      break\n    }\n    case DistributeType.Vertical: {\n      const span = entries.reduce((a, c) => a + c.bounds.height, 0)\n\n      if (span > commonBounds.height) {\n        const top = entries.sort((a, b) => a.bounds.minY - b.bounds.minY)[0]\n\n        const bottom = entries.sort((a, b) => b.bounds.maxY - a.bounds.maxY)[0]\n\n        const entriesToMove = entries\n          .filter((a) => a !== top && a !== bottom)\n          .sort((a, b) => a.center[1] - b.center[1])\n\n        const step = (bottom.center[1] - top.center[1]) / (len - 1)\n\n        const y = top.center[1] + step\n\n        entriesToMove.forEach(({ id, point, bounds }, i) => {\n          results.push({\n            id,\n            prev: point,\n            next: [bounds.minX, y + step * i - bounds.height / 2],\n          })\n        })\n      } else {\n        const entriesToMove = entries.sort((a, b) => a.center[1] - b.center[1])\n\n        let y = commonBounds.minY\n        const step = (commonBounds.height - span) / (len - 1)\n\n        entriesToMove.forEach(({ id, point, bounds }) => {\n          results.push({ id, prev: point, next: [bounds.minX, y] })\n          y += bounds.height + step\n        })\n      }\n\n      break\n    }\n  }\n\n  return results\n}\n", "import { Utils } from '@tldraw/core'\nimport type { TldrawApp } from '~state/TldrawApp'\nimport type { TldrawCommand } from '~types'\n\nexport function duplicatePage(app: TldrawApp, pageId: string): TldrawCommand {\n  const {\n    currentPageId,\n    pageState: { camera },\n  } = app\n\n  const page = app.document.pages[pageId]\n\n  const newId = Utils.uniqueId()\n\n  // Map shapes and bindings onto new IDs\n  const oldToNewIds: Record<string, string> = Object.fromEntries([\n    [page.id, newId],\n    ...Object.keys(page.shapes).map((id) => [id, Utils.uniqueId()]),\n    ...Object.keys(page.bindings).map((id) => [id, Utils.uniqueId()]),\n  ])\n\n  const shapes = Object.fromEntries(\n    Object.entries(page.shapes).map(([id, shape]) => [\n      oldToNewIds[id],\n      {\n        ...Utils.deepClone(shape),\n        id: oldToNewIds[id],\n        parentId: oldToNewIds[shape.parentId],\n      },\n    ])\n  )\n\n  const bindings = Object.fromEntries(\n    Object.entries(page.bindings).map(([id, binding]) => [\n      oldToNewIds[id],\n      {\n        ...Utils.deepClone(binding),\n        id: oldToNewIds[binding.id],\n        fromId: oldToNewIds[binding.fromId],\n        toId: oldToNewIds[binding.toId],\n      },\n    ])\n  )\n\n  // Update the shape's to and from references to the new bindingid\n  Object.values(page.bindings).forEach((binding) => {\n    const fromId = oldToNewIds[binding.fromId]\n    const fromHandles = shapes[fromId]!.handles\n\n    if (fromHandles) {\n      Object.values(fromHandles).forEach((handle) => {\n        if (handle!.bindingId === binding.id) {\n          handle!.bindingId = oldToNewIds[binding.id]\n        }\n      })\n    }\n\n    const toId = oldToNewIds[binding.toId]\n    const toHandles = shapes[toId]!.handles\n\n    if (toHandles) {\n      Object.values(toHandles).forEach((handle) => {\n        if (handle!.bindingId === binding.id) {\n          handle!.bindingId = oldToNewIds[binding.id]\n        }\n      })\n    }\n  })\n\n  const nextPage = {\n    ...page,\n    id: oldToNewIds[page.id],\n    name: page.name + ' Copy',\n    shapes,\n    bindings,\n  }\n\n  return {\n    id: 'duplicate_page',\n    before: {\n      appState: {\n        currentPageId,\n      },\n      document: {\n        pages: {\n          [newId]: undefined,\n        },\n        pageStates: {\n          [newId]: undefined,\n        },\n      },\n    },\n    after: {\n      appState: {\n        currentPageId: newId,\n      },\n      document: {\n        pages: {\n          [newId]: nextPage,\n        },\n        pageStates: {\n          [newId]: {\n            ...page,\n            id: newId,\n            selectedIds: [],\n            camera: { ...camera },\n            editingId: undefined,\n            bindingId: undefined,\n            hoveredId: undefined,\n            pointedId: undefined,\n          },\n        },\n      },\n    },\n  }\n}\n", "import { Utils } from '@tldraw/core'\nimport { Vec } from '@tldraw/vec'\nimport { TLDR } from '~state/TLDR'\nimport type { TldrawApp } from '~state/TldrawApp'\nimport type { PagePartial, TDShape, TldrawCommand } from '~types'\n\nexport function duplicateShapes(app: TldrawApp, ids: string[], point?: number[]): TldrawCommand {\n  const { selectedIds, currentPageId, page, shapes } = app\n\n  const before: PagePartial = {\n    shapes: {},\n    bindings: {},\n  }\n\n  const after: PagePartial = {\n    shapes: {},\n    bindings: {},\n  }\n\n  const duplicateMap: Record<string, string> = {}\n\n  const shapesToDuplicate = ids\n    .map((id) => app.getShape(id))\n    .filter((shape) => !ids.includes(shape.parentId))\n\n  // Create duplicates\n  shapesToDuplicate.forEach((shape) => {\n    const duplicatedId = Utils.uniqueId()\n    before.shapes[duplicatedId] = undefined\n\n    after.shapes[duplicatedId] = {\n      ...Utils.deepClone(shape),\n      id: duplicatedId,\n      childIndex: TLDR.getChildIndexAbove(app.state, shape.id, currentPageId),\n    }\n\n    if (shape.children) {\n      after.shapes[duplicatedId]!.children = []\n    }\n\n    if (shape.parentId !== currentPageId) {\n      const parent = app.getShape(shape.parentId)\n\n      before.shapes[parent.id] = {\n        ...before.shapes[parent.id],\n        children: parent.children,\n      }\n\n      after.shapes[parent.id] = {\n        ...after.shapes[parent.id],\n        children: [...(after.shapes[parent.id] || parent).children!, duplicatedId],\n      }\n    }\n\n    duplicateMap[shape.id] = duplicatedId\n  })\n\n  // If the shapes have children, then duplicate those too\n  shapesToDuplicate.forEach((shape) => {\n    if (shape.children) {\n      shape.children.forEach((childId) => {\n        const child = app.getShape(childId)\n        const duplicatedId = Utils.uniqueId()\n        const duplicatedParentId = duplicateMap[shape.id]\n        before.shapes[duplicatedId] = undefined\n        after.shapes[duplicatedId] = {\n          ...Utils.deepClone(child),\n          id: duplicatedId,\n          parentId: duplicatedParentId,\n          childIndex: TLDR.getChildIndexAbove(app.state, child.id, currentPageId),\n        }\n        duplicateMap[childId] = duplicatedId\n        after.shapes[duplicateMap[shape.id]]?.children?.push(duplicatedId)\n      })\n    }\n  })\n\n  // Which ids did we end up duplicating?\n  const dupedShapeIds = new Set(Object.keys(duplicateMap))\n\n  // Handle bindings that effect duplicated shapes\n  Object.values(page.bindings)\n    .filter((binding) => dupedShapeIds.has(binding.fromId) || dupedShapeIds.has(binding.toId))\n    .forEach((binding) => {\n      if (dupedShapeIds.has(binding.fromId)) {\n        if (dupedShapeIds.has(binding.toId)) {\n          // If the binding is between two duplicating shapes then\n          // duplicate the binding, too\n          const duplicatedBindingId = Utils.uniqueId()\n\n          const duplicatedBinding = {\n            ...Utils.deepClone(binding),\n            id: duplicatedBindingId,\n            fromId: duplicateMap[binding.fromId],\n            toId: duplicateMap[binding.toId],\n          }\n\n          before.bindings[duplicatedBindingId] = undefined\n          after.bindings[duplicatedBindingId] = duplicatedBinding\n\n          // Change the duplicated shape's handle so that it reference\n          // the duplicated binding\n          const boundShape = after.shapes[duplicatedBinding.fromId]\n          Object.values(boundShape!.handles!).forEach((handle) => {\n            if (handle!.bindingId === binding.id) {\n              handle!.bindingId = duplicatedBindingId\n            }\n          })\n        } else {\n          // If only the fromId is selected, delete the binding on\n          // the duplicated shape's handles\n          const boundShape = after.shapes[duplicateMap[binding.fromId]]\n          Object.values(boundShape!.handles!).forEach((handle) => {\n            if (handle!.bindingId === binding.id) {\n              handle!.bindingId = undefined\n            }\n          })\n        }\n      }\n    })\n\n  // Now move the shapes\n\n  const shapesToMove = Object.values(after.shapes) as TDShape[]\n\n  if (point) {\n    const commonBounds = Utils.getCommonBounds(shapesToMove.map((shape) => TLDR.getBounds(shape)))\n    const center = Utils.getBoundsCenter(commonBounds)\n    shapesToMove.forEach((shape) => {\n      // Could be a group\n      if (!shape.point) return\n      shape.point = Vec.sub(point, Vec.sub(center, shape.point))\n    })\n  } else {\n    const offset = [16, 16]\n    shapesToMove.forEach((shape) => {\n      // Could be a group\n      if (!shape.point) return\n      shape.point = Vec.add(shape.point, offset)\n    })\n  }\n\n  // Unlock any locked shapes\n  shapesToMove.forEach((shape) => {\n    if (shape.isLocked) {\n      shape.isLocked = false\n    }\n  })\n\n  return {\n    id: 'duplicate',\n    before: {\n      document: {\n        pages: {\n          [currentPageId]: before,\n        },\n        pageStates: {\n          [currentPageId]: { selectedIds },\n        },\n      },\n    },\n    after: {\n      document: {\n        pages: {\n          [currentPageId]: after,\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: Array.from(dupedShapeIds.values()).map((id) => duplicateMap[id]),\n          },\n        },\n      },\n    },\n  }\n}\n", "import { TLBoundsCorner, Utils } from '@tldraw/core'\nimport { TLDR } from '~state/TLDR'\nimport type { TldrawApp } from '~state/TldrawApp'\nimport { FlipType } from '~types'\nimport type { TldrawCommand } from '~types'\n\nexport function flipShapes(app: TldrawApp, ids: string[], type: FlipType): TldrawCommand {\n  const {\n    selectedIds,\n    currentPageId,\n    page: { shapes },\n  } = app\n\n  const boundsForShapes = ids.map((id) => TLDR.getBounds(shapes[id]))\n\n  const isSinglySelectedGroup = ids.length === 1 && shapes[ids[0]].type === 'group'\n\n  const commonBounds = Utils.getCommonBounds(boundsForShapes)\n\n  const { before, after } = TLDR.mutateShapes(\n    app.state,\n    ids,\n    (shape) => {\n      const shapeBounds = TLDR.getBounds(shape)\n      const isChildOfGroup = shape.parentId !== currentPageId\n      switch (type) {\n        case FlipType.Horizontal: {\n          if (isChildOfGroup && !isSinglySelectedGroup) {\n            // do translation of this child\n            const groupBounds = TLDR.getBounds(shapes[shape.parentId])\n            const newGroupBounds = Utils.getRelativeTransformedBoundingBox(\n              commonBounds,\n              commonBounds,\n              groupBounds,\n              true,\n              false\n            )\n            const dx = newGroupBounds.minX - groupBounds.minX\n            return TLDR.getShapeUtil(shape).transform(\n              shape,\n              { ...shapeBounds, minX: shapeBounds.minX + dx, maxX: shapeBounds.maxX + dx },\n              {\n                type: TLBoundsCorner.TopLeft,\n                scaleX: 1,\n                scaleY: 1,\n                initialShape: shape,\n                transformOrigin: [0.5, 0.5],\n              }\n            )\n          }\n\n          const newShapeBounds = Utils.getRelativeTransformedBoundingBox(\n            commonBounds,\n            commonBounds,\n            shapeBounds,\n            true,\n            false\n          )\n\n          return TLDR.getShapeUtil(shape).transform(shape, newShapeBounds, {\n            type: TLBoundsCorner.TopLeft,\n            scaleX: -1,\n            scaleY: 1,\n            initialShape: shape,\n            transformOrigin: [0.5, 0.5],\n          })\n        }\n        case FlipType.Vertical: {\n          if (isChildOfGroup && !isSinglySelectedGroup) {\n            // do translation of this child\n            const groupBounds = TLDR.getBounds(shapes[shape.parentId])\n            const newGroupBounds = Utils.getRelativeTransformedBoundingBox(\n              commonBounds,\n              commonBounds,\n              groupBounds,\n              false,\n              true\n            )\n            const dy = newGroupBounds.minY - groupBounds.minY\n            return TLDR.getShapeUtil(shape).transform(\n              shape,\n              { ...shapeBounds, minY: shapeBounds.minY + dy, maxY: shapeBounds.maxY + dy },\n              {\n                type: TLBoundsCorner.TopLeft,\n                scaleX: 1,\n                scaleY: 1,\n                initialShape: shape,\n                transformOrigin: [0.5, 0.5],\n              }\n            )\n          }\n          const newShapeBounds = Utils.getRelativeTransformedBoundingBox(\n            commonBounds,\n            commonBounds,\n            shapeBounds,\n            false,\n            true\n          )\n\n          return TLDR.getShapeUtil(shape).transform(shape, newShapeBounds, {\n            type: TLBoundsCorner.TopLeft,\n            scaleX: 1,\n            scaleY: -1,\n            initialShape: shape,\n            transformOrigin: [0.5, 0.5],\n          })\n        }\n      }\n    },\n    currentPageId,\n    true\n  )\n\n  return {\n    id: 'flip',\n    before: {\n      document: {\n        pages: {\n          [currentPageId]: { shapes: before },\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds,\n          },\n        },\n      },\n    },\n    after: {\n      document: {\n        pages: {\n          [currentPageId]: { shapes: after },\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: ids,\n          },\n        },\n      },\n    },\n  }\n}\n", "import { Utils } from '@tldraw/core'\nimport { TLDR } from '~state/TLDR'\nimport type { TldrawApp } from '~state/TldrawApp'\nimport { TDShape, TDShapeType } from '~types'\nimport type { Patch, TDBinding, TldrawCommand } from '~types'\n\nexport function groupShapes(\n  app: TldrawApp,\n  ids: string[],\n  groupId: string,\n  pageId: string\n): TldrawCommand | undefined {\n  if (ids.length < 2) return\n\n  const beforeShapes: Record<string, Patch<TDShape | undefined>> = {}\n  const afterShapes: Record<string, Patch<TDShape | undefined>> = {}\n\n  const beforeBindings: Record<string, Patch<TDBinding | undefined>> = {}\n  const afterBindings: Record<string, Patch<TDBinding | undefined>> = {}\n\n  const idsToGroup = [...ids]\n  const shapesToGroup: TDShape[] = []\n  const deletedGroupIds: string[] = []\n  const otherEffectedGroups: TDShape[] = []\n\n  // Collect all of the shapes to group (and their ids)\n  for (const id of ids) {\n    const shape = app.getShape(id)\n    if (shape.isLocked) continue\n\n    if (shape.children === undefined) {\n      shapesToGroup.push(shape)\n    } else {\n      const childIds = shape.children.filter((id) => !app.getShape(id).isLocked)\n      otherEffectedGroups.push(shape)\n      idsToGroup.push(...childIds)\n      shapesToGroup.push(...childIds.map((id) => app.getShape(id)).filter(Boolean))\n    }\n  }\n\n  // 1. Can we create this group?\n\n  // Do the shapes have the same parent?\n  if (shapesToGroup.every((shape) => shape.parentId === shapesToGroup[0].parentId)) {\n    // Is the common parent a shape (not the page)?\n    if (shapesToGroup[0].parentId !== pageId) {\n      const commonParent = app.getShape(shapesToGroup[0].parentId)\n      // Are all of the common parent's shapes selected?\n      if (commonParent.children?.length === idsToGroup.length) {\n        // Don't create a group if that group would be the same as the\n        // existing group.\n        return\n      }\n    }\n  }\n\n  // A flattened array of shapes from the page\n  const flattenedShapes = TLDR.flattenPage(app.state, pageId)\n\n  // A map of shapes to their index in flattendShapes\n  const shapeIndexMap = Object.fromEntries(\n    shapesToGroup.map((shape) => [shape.id, flattenedShapes.indexOf(shape)])\n  )\n\n  // An array of shapes in order by their index in flattendShapes\n  const sortedShapes = shapesToGroup.sort((a, b) => shapeIndexMap[a.id] - shapeIndexMap[b.id])\n\n  // The parentId is always the current page\n  const groupParentId = pageId // sortedShapes[0].parentId\n\n  // The childIndex should be the lowest index of the selected shapes\n  // with a parent that is the current page; or else the child index\n  // of the lowest selected shape.\n  const groupChildIndex = (\n    sortedShapes.filter((shape) => shape.parentId === pageId)[0] || sortedShapes[0]\n  ).childIndex\n\n  // The shape's point is the min point of its childrens' common bounds\n  const groupBounds = Utils.getCommonBounds(shapesToGroup.map((shape) => TLDR.getBounds(shape)))\n\n  // Create the group\n  beforeShapes[groupId] = undefined\n\n  afterShapes[groupId] = TLDR.getShapeUtil(TDShapeType.Group).create({\n    id: groupId,\n    childIndex: groupChildIndex,\n    parentId: groupParentId,\n    point: [groupBounds.minX, groupBounds.minY],\n    size: [groupBounds.width, groupBounds.height],\n    children: sortedShapes.map((shape) => shape.id),\n  })\n\n  // Reparent shapes to the new group\n  sortedShapes.forEach((shape, index) => {\n    // If the shape is part of a different group, mark the parent shape for cleanup\n    if (shape.parentId !== pageId) {\n      const parentShape = app.getShape(shape.parentId)\n      otherEffectedGroups.push(parentShape)\n    }\n\n    beforeShapes[shape.id] = {\n      ...beforeShapes[shape.id],\n      parentId: shape.parentId,\n      childIndex: shape.childIndex,\n    }\n\n    afterShapes[shape.id] = {\n      ...afterShapes[shape.id],\n      parentId: groupId,\n      childIndex: index + 1,\n    }\n  })\n\n  // Clean up effected parents\n  while (otherEffectedGroups.length > 0) {\n    const shape = otherEffectedGroups.pop()\n    if (!shape) break\n\n    const nextChildren = (beforeShapes[shape.id]?.children || shape.children)!.filter(\n      (childId) => childId && !(idsToGroup.includes(childId) || deletedGroupIds.includes(childId))\n    )\n\n    // If the parent has no children, remove it\n    if (nextChildren.length === 0) {\n      beforeShapes[shape.id] = shape\n      afterShapes[shape.id] = undefined\n\n      // And if that parent is part of a different group, mark it for cleanup\n      // (This is necessary only when we implement nested groups.)\n      if (shape.parentId !== pageId) {\n        deletedGroupIds.push(shape.id)\n        otherEffectedGroups.push(app.getShape(shape.parentId))\n      }\n    } else {\n      beforeShapes[shape.id] = {\n        ...beforeShapes[shape.id],\n        children: shape.children,\n      }\n\n      afterShapes[shape.id] = {\n        ...afterShapes[shape.id],\n        children: nextChildren,\n      }\n    }\n  }\n\n  // TODO: This code is copied from delete.command. Create a shared helper!\n\n  const { bindings } = app\n\n  const deletedGroupIdsSet = new Set(deletedGroupIds)\n\n  // We also need to delete bindings that reference the deleted shapes\n  bindings.forEach((binding) => {\n    for (const id of [binding.toId, binding.fromId]) {\n      // If the binding references a deleted shape...\n      if (deletedGroupIdsSet.has(id)) {\n        // Delete this binding\n        beforeBindings[binding.id] = binding\n        afterBindings[binding.id] = undefined\n\n        // Let's also look each the bound shape...\n        const shape = app.getShape(id)\n\n        // If the bound shape has a handle that references the deleted binding...\n        if (shape.handles) {\n          Object.values(shape.handles)\n            .filter((handle) => handle.bindingId === binding.id)\n            .forEach((handle) => {\n              // Save the binding reference in the before patch\n              beforeShapes[id] = {\n                ...beforeShapes[id],\n                handles: {\n                  ...beforeShapes[id]?.handles,\n                  [handle.id]: { bindingId: binding.id },\n                },\n              }\n\n              // Unless we're currently deleting the shape, remove the\n              // binding reference from the after patch\n              if (!deletedGroupIds.includes(id)) {\n                afterShapes[id] = {\n                  ...afterShapes[id],\n                  handles: {\n                    ...afterShapes[id]?.handles,\n                    [handle.id]: { bindingId: undefined },\n                  },\n                }\n              }\n            })\n        }\n      }\n    }\n  })\n\n  return {\n    id: 'group',\n    before: {\n      document: {\n        pages: {\n          [pageId]: {\n            shapes: beforeShapes,\n            bindings: beforeBindings,\n          },\n        },\n        pageStates: {\n          [pageId]: {\n            selectedIds: ids,\n          },\n        },\n      },\n    },\n    after: {\n      document: {\n        pages: {\n          [pageId]: {\n            shapes: afterShapes,\n            bindings: beforeBindings,\n          },\n        },\n        pageStates: {\n          [pageId]: {\n            selectedIds: [groupId],\n          },\n        },\n      },\n    },\n  }\n}\n", "import { TLBounds, Utils } from '@tldraw/core'\nimport { Vec } from '@tldraw/vec'\nimport { TLDR } from '~state/TLDR'\nimport type { TldrawApp } from '~state/TldrawApp'\nimport type { ArrowShape, PagePartial, TDShape, TldrawCommand } from '~types'\n\nexport function moveShapesToPage(\n  app: TldrawApp,\n  ids: string[],\n  viewportBounds: TLBounds,\n  fromPageId: string,\n  toPageId: string\n): TldrawCommand {\n  const { page } = app\n\n  const fromPage: Record<string, PagePartial> = {\n    before: {\n      shapes: {},\n      bindings: {},\n    },\n    after: {\n      shapes: {},\n      bindings: {},\n    },\n  }\n\n  const toPage: Record<string, PagePartial> = {\n    before: {\n      shapes: {},\n      bindings: {},\n    },\n    after: {\n      shapes: {},\n      bindings: {},\n    },\n  }\n\n  // Collect all the shapes to move and their keys.\n  const movingShapeIds = new Set<string>()\n  const shapesToMove = new Set<TDShape>()\n\n  ids\n    .map((id) => app.getShape(id, fromPageId))\n    .filter((shape) => !shape.isLocked)\n    .forEach((shape) => {\n      movingShapeIds.add(shape.id)\n      shapesToMove.add(shape)\n      if (shape.children !== undefined) {\n        shape.children.forEach((childId) => {\n          movingShapeIds.add(childId)\n          shapesToMove.add(app.getShape(childId, fromPageId))\n        })\n      }\n    })\n\n  // Where should we put start putting shapes on the \"to\" page?\n  const startingChildIndex = TLDR.getTopChildIndex(app.state, toPageId)\n\n  // Which shapes are we moving?\n  const movingShapes = Array.from(shapesToMove.values())\n\n  movingShapes.forEach((shape, i) => {\n    // Remove the shape from the fromPage\n    fromPage.before.shapes[shape.id] = shape\n    fromPage.after.shapes[shape.id] = undefined\n\n    // But the moved shape on the \"to\" page\n    toPage.before.shapes[shape.id] = undefined\n    toPage.after.shapes[shape.id] = shape\n\n    // If the shape's parent isn't moving too, reparent the shape to\n    // the \"to\" page, at the top of the z stack\n    if (!movingShapeIds.has(shape.parentId)) {\n      toPage.after.shapes[shape.id] = {\n        ...shape,\n        parentId: toPageId,\n        childIndex: startingChildIndex + i,\n      }\n\n      // If the shape was in a group, then pull the shape from the\n      // parent's children array.\n      if (shape.parentId !== fromPageId) {\n        const parent = app.getShape(shape.parentId, fromPageId)\n        fromPage.before.shapes[parent.id] = {\n          children: parent.children,\n        }\n\n        fromPage.after.shapes[parent.id] = {\n          children: parent.children!.filter((childId) => childId !== shape.id),\n        }\n      }\n    }\n  })\n\n  // Handle bindings that effect duplicated shapes\n  Object.values(page.bindings)\n    .filter((binding) => movingShapeIds.has(binding.fromId) || movingShapeIds.has(binding.toId))\n    .forEach((binding) => {\n      // Always delete the binding from the from page\n\n      fromPage.before.bindings[binding.id] = binding\n      fromPage.after.bindings[binding.id] = undefined\n\n      // Delete the reference from the binding's fromShape\n\n      const fromBoundShape = app.getShape(binding.fromId, fromPageId)\n\n      // Will we be copying this binding to the new page?\n\n      const shouldCopy = movingShapeIds.has(binding.fromId) && movingShapeIds.has(binding.toId)\n\n      if (shouldCopy) {\n        // Just move the binding to the new page\n        toPage.before.bindings[binding.id] = undefined\n        toPage.after.bindings[binding.id] = binding\n      } else {\n        if (movingShapeIds.has(binding.fromId)) {\n          // If we are only moving the \"from\" shape, we need to delete\n          // the binding reference from the \"from\" shapes handles\n          const fromShape = app.getShape(binding.fromId, fromPageId)\n          const handle = Object.values(fromBoundShape.handles!).find(\n            (handle) => handle.bindingId === binding.id\n          )!\n\n          // Remove the handle from the shape on the toPage\n\n          const handleId = handle.id as keyof ArrowShape['handles']\n\n          const toPageShape = toPage.after.shapes[fromShape.id]!\n\n          toPageShape.handles = {\n            ...toPageShape.handles,\n            [handleId]: {\n              ...toPageShape.handles![handleId],\n              bindingId: undefined,\n            },\n          }\n        } else {\n          // If we are only moving the \"to\" shape, we need to delete\n          // the binding reference from the \"from\" shape's handles\n          const fromShape = app.getShape(binding.fromId, fromPageId)\n          const handle = Object.values(fromBoundShape.handles!).find(\n            (handle) => handle.bindingId === binding.id\n          )!\n\n          fromPage.before.shapes[fromShape.id] = {\n            handles: { [handle.id]: { bindingId: binding.id } },\n          }\n\n          fromPage.after.shapes[fromShape.id] = {\n            handles: { [handle.id]: { bindingId: undefined } },\n          }\n        }\n      }\n    })\n\n  // Finally, center camera on selection\n\n  const toPageState = app.state.document.pageStates[toPageId]\n\n  const bounds = Utils.getCommonBounds(movingShapes.map((shape) => TLDR.getBounds(shape)))\n\n  const zoom = TLDR.getCameraZoom(\n    viewportBounds.width < viewportBounds.height\n      ? (viewportBounds.width - 128) / bounds.width\n      : (viewportBounds.height - 128) / bounds.height\n  )\n\n  const mx = (viewportBounds.width - bounds.width * zoom) / 2 / zoom\n  const my = (viewportBounds.height - bounds.height * zoom) / 2 / zoom\n\n  const point = Vec.toFixed(Vec.add([-bounds.minX, -bounds.minY], [mx, my]))\n\n  return {\n    id: 'move_to_page',\n    before: {\n      appState: {\n        currentPageId: fromPageId,\n      },\n      document: {\n        pages: {\n          [fromPageId]: fromPage.before,\n          [toPageId]: toPage.before,\n        },\n        pageStates: {\n          [fromPageId]: { selectedIds: ids },\n          [toPageId]: {\n            selectedIds: toPageState.selectedIds,\n            camera: toPageState.camera,\n          },\n        },\n      },\n    },\n    after: {\n      appState: {\n        currentPageId: toPageId,\n      },\n      document: {\n        pages: {\n          [fromPageId]: fromPage.after,\n          [toPageId]: toPage.after,\n        },\n        pageStates: {\n          [fromPageId]: { selectedIds: [] },\n          [toPageId]: {\n            selectedIds: ids,\n            camera: {\n              zoom,\n              point,\n            },\n          },\n        },\n      },\n    },\n  }\n}\n", "import type { TldrawApp } from '~state/TldrawApp'\nimport type { TDPage, TldrawCommand } from '~types'\n\nexport function movePage(app: TldrawApp, pageId: string, index: number): TldrawCommand {\n  const { pages } = app.document\n\n  const movingPage = pages[pageId]\n\n  const beforePages = Object.values(pages).sort((a, b) => (a.childIndex ?? 0) - (b.childIndex ?? 0))\n\n  const fromIndex = beforePages.indexOf(movingPage)\n\n  const afterPages = [...beforePages]\n  afterPages.splice(fromIndex, 1)\n  afterPages.splice(index > fromIndex ? index - 1 : index, 0, movingPage)\n\n  return {\n    id: 'move_page',\n    before: {\n      document: {\n        pages: Object.fromEntries(\n          beforePages.map((p: TDPage) => [p.id, { childIndex: p.childIndex }])\n        ),\n      },\n    },\n    after: {\n      document: {\n        pages: Object.fromEntries(\n          afterPages.map((p: TDPage, childIndex) => [p.id, { childIndex }])\n        ),\n      },\n    },\n  }\n}\n", "import { TLDR } from '~state/TLDR'\nimport type { TldrawApp } from '~state/TldrawApp'\nimport { MoveType, TDShape, TldrawCommand } from '~types'\n\nexport function reorderShapes(app: TldrawApp, ids: string[], type: MoveType): TldrawCommand {\n  const { currentPageId, page } = app\n\n  // Get the unique parent ids for the selected elements\n  const parentIds = new Set(ids.map((id) => app.getShape(id).parentId))\n\n  let result: {\n    before: Record<string, Partial<TDShape>>\n    after: Record<string, Partial<TDShape>>\n  } = { before: {}, after: {} }\n\n  let startIndex: number\n  let startChildIndex: number\n  let step: number\n\n  // Collect shapes with common parents into a table under their parent id\n  Array.from(parentIds.values()).forEach((parentId) => {\n    let sortedChildren: TDShape[] = []\n    if (parentId === page.id) {\n      sortedChildren = Object.values(page.shapes).sort((a, b) => a.childIndex - b.childIndex)\n    } else {\n      const parent = app.getShape(parentId)\n      if (!parent.children) throw Error('No children in parent!')\n\n      sortedChildren = parent.children\n        .map((childId) => app.getShape(childId))\n        .sort((a, b) => a.childIndex - b.childIndex)\n    }\n\n    const sortedChildIds = sortedChildren.map((shape) => shape.id)\n\n    const sortedIndicesToMove = ids\n      .filter((id) => sortedChildIds.includes(id))\n      .map((id) => sortedChildIds.indexOf(id))\n      .sort((a, b) => a - b)\n\n    if (sortedIndicesToMove.length === sortedChildIds.length) return\n\n    switch (type) {\n      case MoveType.ToBack: {\n        //               a       b  c\n        // Initial   1   2    3  4  5  6  7\n        // Final   .25  .5  .75  1  3  6  7\n        //           a   b    c\n\n        // Find the lowest \"open\" index\n        for (let i = 0; i < sortedChildIds.length; i++) {\n          if (sortedIndicesToMove.includes(i)) continue\n          startIndex = i\n          break\n        }\n\n        // Find the lowest child index that isn't in sortedIndicesToMove\n        startChildIndex = sortedChildren[startIndex].childIndex\n\n        // Find the step for each additional child\n        step = startChildIndex / (sortedIndicesToMove.length + 1)\n\n        // Get the results of moving the selected shapes below the first open index's shape\n        result = TLDR.mutateShapes(\n          app.state,\n          sortedIndicesToMove.map((i) => sortedChildren[i].id).reverse(),\n          (_shape, i) => ({\n            childIndex: startChildIndex - (i + 1) * step,\n          }),\n          currentPageId\n        )\n\n        break\n      }\n      case MoveType.ToFront: {\n        //              a     b  c\n        // Initial   1  2  3  4  5  6   7\n        // Final     1  3  6  7  8  9  10\n        //                       a  b   c\n\n        // Find the highest \"open\" index\n        for (let i = sortedChildIds.length - 1; i >= 0; i--) {\n          if (sortedIndicesToMove.includes(i)) continue\n          startIndex = i\n          break\n        }\n\n        // Find the lowest child index that isn't in sortedIndicesToMove\n        startChildIndex = sortedChildren[startIndex].childIndex\n\n        // Find the step for each additional child\n        step = 1\n\n        // Get the results of moving the selected shapes below the first open index's shape\n        result = TLDR.mutateShapes(\n          app.state,\n          sortedIndicesToMove.map((i) => sortedChildren[i].id),\n          (_shape, i) => ({\n            childIndex: startChildIndex + (i + 1),\n          }),\n          currentPageId\n        )\n\n        break\n      }\n      case MoveType.Backward: {\n        //               a           b  c\n        // Initial    1  2     3     4  5  6  7\n        // Final     .5  1  1.66  2.33  3  6  7\n        //           a         b     c\n\n        const indexMap: Record<string, number> = {}\n\n        // Starting from the top...\n        for (let i = sortedChildIds.length - 1; i >= 0; i--) {\n          // If we found a moving index...\n          if (sortedIndicesToMove.includes(i)) {\n            for (let j = i; j >= 0; j--) {\n              // iterate downward until we find an open spot\n              if (!sortedIndicesToMove.includes(j)) {\n                // i = the index of the first closed spot\n                // j = the index of the first open spot\n\n                const endChildIndex = sortedChildren[j].childIndex\n                let startChildIndex: number\n                let step: number\n\n                if (j === 0) {\n                  // We're moving below the first child, start from\n                  // half of its child index.\n\n                  startChildIndex = endChildIndex / 2\n                  step = endChildIndex / 2 / (i - j + 1)\n                } else {\n                  // Start from the child index of the child below the\n                  // child above.\n                  startChildIndex = sortedChildren[j - 1].childIndex\n                  step = (endChildIndex - startChildIndex) / (i - j + 1)\n                  startChildIndex += step\n                }\n\n                for (let k = 0; k < i - j; k++) {\n                  indexMap[sortedChildren[j + k + 1].id] = startChildIndex + step * k\n                }\n\n                break\n              }\n            }\n          }\n        }\n\n        if (Object.values(indexMap).length > 0) {\n          // Get the results of moving the selected shapes below the first open index's shape\n          result = TLDR.mutateShapes(\n            app.state,\n            sortedIndicesToMove.map((i) => sortedChildren[i].id),\n            (shape) => ({\n              childIndex: indexMap[shape.id],\n            }),\n            currentPageId\n          )\n        }\n\n        break\n      }\n      case MoveType.Forward: {\n        //             a     b c\n        // Initial   1 2   3 4 5 6 7\n        // Final     1 3 3.5 6 7 8 9\n        //                 a     b c\n\n        const indexMap: Record<string, number> = {}\n\n        // Starting from the top...\n        for (let i = 0; i < sortedChildIds.length; i++) {\n          // If we found a moving index...\n          if (sortedIndicesToMove.includes(i)) {\n            // Search for the first open spot above this one\n            for (let j = i; j < sortedChildIds.length; j++) {\n              if (!sortedIndicesToMove.includes(j)) {\n                // i = the low index of the first closed spot\n                // j = the high index of the first open spot\n\n                startChildIndex = sortedChildren[j].childIndex\n\n                const step =\n                  j === sortedChildIds.length - 1\n                    ? 1\n                    : (sortedChildren[j + 1].childIndex - startChildIndex) / (j - i + 1)\n\n                for (let k = 0; k < j - i; k++) {\n                  indexMap[sortedChildren[i + k].id] = startChildIndex + step * (k + 1)\n                }\n\n                break\n              }\n            }\n          }\n        }\n\n        if (Object.values(indexMap).length > 0) {\n          // Get the results of moving the selected shapes below the first open index's shape\n          result = TLDR.mutateShapes(\n            app.state,\n            sortedIndicesToMove.map((i) => sortedChildren[i].id),\n            (shape) => ({\n              childIndex: indexMap[shape.id],\n            }),\n            currentPageId\n          )\n        }\n\n        break\n      }\n    }\n  })\n\n  return {\n    id: 'move',\n    before: {\n      document: {\n        pages: {\n          [currentPageId]: { shapes: result.before },\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: ids,\n          },\n        },\n      },\n    },\n    after: {\n      document: {\n        pages: {\n          [currentPageId]: { shapes: result.after },\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: ids,\n          },\n        },\n      },\n    },\n  }\n}\n", "import type { TldrawApp } from '~state/TldrawApp'\nimport type { TldrawCommand } from '~types'\n\nexport function renamePage(app: TldrawApp, pageId: string, name: string): TldrawCommand {\n  const { page } = app\n\n  return {\n    id: 'rename_page',\n    before: {\n      document: {\n        pages: {\n          [pageId]: { name: page.name },\n        },\n      },\n    },\n    after: {\n      document: {\n        pages: {\n          [pageId]: { name: name },\n        },\n      },\n    },\n  }\n}\n", "import { TLDR } from '~state/TLDR'\nimport type { TldrawApp } from '~state/TldrawApp'\nimport type { TldrawCommand } from '~types'\n\nexport function resetBounds(app: TldrawApp, ids: string[], pageId: string): TldrawCommand {\n  const { currentPageId } = app\n\n  const { before, after } = TLDR.mutateShapes(\n    app.state,\n    ids,\n    (shape) => app.getShapeUtil(shape).onDoubleClickBoundsHandle?.(shape),\n    pageId\n  )\n\n  return {\n    id: 'reset_bounds',\n    before: {\n      document: {\n        pages: {\n          [currentPageId]: { shapes: before },\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: ids,\n          },\n        },\n      },\n    },\n    after: {\n      document: {\n        pages: {\n          [currentPageId]: { shapes: after },\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: ids,\n          },\n        },\n      },\n    },\n  }\n}\n", "import { Utils } from '@tldraw/core'\nimport { TLDR } from '~state/TLDR'\nimport type { TldrawApp } from '~state/TldrawApp'\nimport type { TDShape, TldrawCommand } from '~types'\n\nconst PI2 = Math.PI * 2\n\nexport function rotateShapes(\n  app: TldrawApp,\n  ids: string[],\n  delta = -PI2 / 4\n): TldrawCommand | void {\n  const { currentPageId } = app\n\n  // The shapes for the before patch\n  const before: Record<string, Partial<TDShape>> = {}\n\n  // The shapes for the after patch\n  const after: Record<string, Partial<TDShape>> = {}\n\n  // Find the shapes that we want to rotate.\n  // We don't rotate groups: we rotate their children instead.\n  const shapesToRotate = ids\n    .flatMap((id) => {\n      const shape = app.getShape(id)\n      return shape.children ? shape.children.map((childId) => app.getShape(childId)) : shape\n    })\n    .filter((shape) => !shape.isLocked)\n\n  // Find the common center to all shapes\n  // This is the point that we'll rotate around\n  const origin = Utils.getBoundsCenter(\n    Utils.getCommonBounds(shapesToRotate.map((shape) => TLDR.getBounds(shape)))\n  )\n\n  // Find the rotate mutations for each shape\n  shapesToRotate.forEach((shape) => {\n    const change = TLDR.getRotatedShapeMutation(shape, TLDR.getCenter(shape), origin, delta)\n    if (!change) return\n    before[shape.id] = TLDR.getBeforeShape(shape, change)\n    after[shape.id] = change\n  })\n\n  return {\n    id: 'rotate',\n    before: {\n      document: {\n        pages: {\n          [currentPageId]: { shapes: before },\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: ids,\n          },\n        },\n      },\n    },\n    after: {\n      document: {\n        pages: {\n          [currentPageId]: { shapes: after },\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: ids,\n          },\n        },\n      },\n    },\n  }\n}\n", "import { TLBoundsCorner, Utils } from '@tldraw/core'\nimport { TLDR } from '~state/TLDR'\nimport type { TldrawApp } from '~state/TldrawApp'\nimport { StretchType, TDShapeType } from '~types'\nimport type { TldrawCommand } from '~types'\n\nexport function stretchShapes(app: TldrawApp, ids: string[], type: StretchType): TldrawCommand {\n  const { currentPageId, selectedIds } = app\n\n  const initialShapes = ids.map((id) => app.getShape(id))\n\n  const boundsForShapes = initialShapes.map((shape) => TLDR.getBounds(shape))\n\n  const commonBounds = Utils.getCommonBounds(boundsForShapes)\n\n  const idsToMutate = ids\n    .flatMap((id) => {\n      const shape = app.getShape(id)\n      return shape.children ? shape.children : shape.id\n    })\n    .filter((id) => !app.getShape(id).isLocked)\n\n  const { before, after } = TLDR.mutateShapes(\n    app.state,\n    idsToMutate,\n    (shape) => {\n      const bounds = TLDR.getBounds(shape)\n\n      switch (type) {\n        case StretchType.Horizontal: {\n          const newBounds = {\n            ...bounds,\n            minX: commonBounds.minX,\n            maxX: commonBounds.maxX,\n            width: commonBounds.width,\n          }\n\n          return TLDR.getShapeUtil(shape).transformSingle(shape, newBounds, {\n            type: TLBoundsCorner.TopLeft,\n            scaleX: newBounds.width / bounds.width,\n            scaleY: 1,\n            initialShape: shape,\n            transformOrigin: [0.5, 0.5],\n          })\n        }\n        case StretchType.Vertical: {\n          const newBounds = {\n            ...bounds,\n            minY: commonBounds.minY,\n            maxY: commonBounds.maxY,\n            height: commonBounds.height,\n          }\n\n          return TLDR.getShapeUtil(shape).transformSingle(shape, newBounds, {\n            type: TLBoundsCorner.TopLeft,\n            scaleX: 1,\n            scaleY: newBounds.height / bounds.height,\n            initialShape: shape,\n            transformOrigin: [0.5, 0.5],\n          })\n        }\n      }\n    },\n    currentPageId\n  )\n\n  initialShapes.forEach((shape) => {\n    if (shape.type === TDShapeType.Group) {\n      delete before[shape.id]\n      delete after[shape.id]\n    }\n  })\n\n  return {\n    id: 'stretch',\n    before: {\n      document: {\n        pages: {\n          [currentPageId]: { shapes: before },\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds,\n          },\n        },\n      },\n    },\n    after: {\n      document: {\n        pages: {\n          [currentPageId]: { shapes: after },\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: ids,\n          },\n        },\n      },\n    },\n  }\n}\n", "import { Vec } from '@tldraw/vec'\nimport { TLDR } from '~state/TLDR'\nimport type { TldrawApp } from '~state/TldrawApp'\nimport { Patch, ShapeStyles, TDShape, TDShapeType, TextShape, TldrawCommand } from '~types'\n\nexport function styleShapes(\n  app: TldrawApp,\n  ids: string[],\n  changes: Partial<ShapeStyles>\n): TldrawCommand {\n  const { currentPageId, selectedIds } = app\n\n  const shapeIdsToMutate = ids\n    .flatMap((id) => TLDR.getDocumentBranch(app.state, id, currentPageId))\n    .filter((id) => !app.getShape(id).isLocked)\n\n  const beforeShapes: Record<string, Patch<TDShape>> = {}\n  const afterShapes: Record<string, Patch<TDShape>> = {}\n\n  shapeIdsToMutate\n    .map((id) => app.getShape(id))\n    .filter((shape) => !shape.isLocked)\n    .forEach((shape) => {\n      beforeShapes[shape.id] = {\n        style: {\n          ...Object.fromEntries(\n            Object.keys(changes).map((key) => [key, shape.style[key as keyof typeof shape.style]])\n          ),\n        },\n      }\n\n      afterShapes[shape.id] = {\n        style: changes,\n      }\n\n      if (shape.type === TDShapeType.Text) {\n        beforeShapes[shape.id].point = shape.point\n        afterShapes[shape.id].point = Vec.toFixed(\n          Vec.add(\n            shape.point,\n            Vec.sub(\n              app.getShapeUtil(shape).getCenter(shape),\n              app.getShapeUtil(shape).getCenter({\n                ...shape,\n                style: { ...shape.style, ...changes },\n              } as TextShape)\n            )\n          )\n        )\n      }\n    })\n\n  return {\n    id: 'style',\n    before: {\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes: beforeShapes,\n          },\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: selectedIds,\n          },\n        },\n      },\n      appState: {\n        currentStyle: { ...app.appState.currentStyle },\n      },\n    },\n    after: {\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes: afterShapes,\n          },\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: ids,\n          },\n        },\n      },\n      appState: {\n        currentStyle: changes,\n      },\n    },\n  }\n}\n", "import type { TldrawApp } from '~state/internal'\nimport { Decoration } from '~types'\nimport type { ArrowShape, Patch, TldrawCommand } from '~types'\n\nexport function toggleShapesDecoration(\n  app: TldrawApp,\n  ids: string[],\n  decorationId: 'start' | 'end'\n): TldrawCommand {\n  const { currentPageId, selectedIds } = app\n\n  const beforeShapes: Record<string, Patch<ArrowShape>> = Object.fromEntries(\n    ids.map((id) => [\n      id,\n      {\n        decorations: {\n          [decorationId]: app.getShape<ArrowShape>(id).decorations?.[decorationId],\n        },\n      },\n    ])\n  )\n\n  const afterShapes: Record<string, Patch<ArrowShape>> = Object.fromEntries(\n    ids\n      .filter((id) => !app.getShape(id).isLocked)\n      .map((id) => [\n        id,\n        {\n          decorations: {\n            [decorationId]: app.getShape<ArrowShape>(id).decorations?.[decorationId]\n              ? undefined\n              : Decoration.Arrow,\n          },\n        },\n      ])\n  )\n\n  return {\n    id: 'toggle_decorations',\n    before: {\n      document: {\n        pages: {\n          [currentPageId]: { shapes: beforeShapes },\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds,\n          },\n        },\n      },\n    },\n    after: {\n      document: {\n        pages: {\n          [currentPageId]: { shapes: afterShapes },\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: ids,\n          },\n        },\n      },\n    },\n  }\n}\n", "import type { TldrawApp } from '~state'\nimport type { TDShape, TldrawCommand } from '~types'\n\nexport function toggleShapeProp(app: TldrawApp, ids: string[], prop: keyof TDShape): TldrawCommand {\n  const { currentPageId } = app\n\n  const initialShapes = ids\n    .map((id) => app.getShape(id))\n    .filter((shape) => (prop === 'isLocked' ? true : !shape.isLocked))\n\n  const isAllToggled = initialShapes.every((shape) => shape[prop])\n\n  const before: Record<string, Partial<TDShape>> = {}\n  const after: Record<string, Partial<TDShape>> = {}\n\n  initialShapes.forEach((shape) => {\n    before[shape.id] = { [prop]: shape[prop] }\n    after[shape.id] = { [prop]: !isAllToggled }\n  })\n\n  return {\n    id: 'toggle',\n    before: {\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes: before,\n          },\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: ids,\n          },\n        },\n      },\n    },\n    after: {\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes: after,\n          },\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: ids,\n          },\n        },\n      },\n    },\n  }\n}\n", "import { Vec } from '@tldraw/vec'\nimport { TLDR } from '~state/TLDR'\nimport type { TldrawApp } from '~state/TldrawApp'\nimport type { PagePartial, TldrawCommand } from '~types'\n\nexport function translateShapes(app: TldrawApp, ids: string[], delta: number[]): TldrawCommand {\n  const { currentPageId, selectedIds } = app\n\n  // Clear session cache\n  app.rotationInfo.selectedIds = [...selectedIds]\n\n  const before: PagePartial = {\n    shapes: {},\n    bindings: {},\n  }\n\n  const after: PagePartial = {\n    shapes: {},\n    bindings: {},\n  }\n\n  const idsToMutate = ids\n    .flatMap((id) => {\n      const shape = app.getShape(id)\n      return shape.children ? shape.children : shape.id\n    })\n    .filter((id) => !app.getShape(id).isLocked)\n\n  const change = TLDR.mutateShapes(\n    app.state,\n    idsToMutate,\n    (shape) => ({\n      point: Vec.toFixed(Vec.add(shape.point, delta)),\n    }),\n    currentPageId\n  )\n\n  before.shapes = change.before\n  after.shapes = change.after\n\n  // Delete bindings from nudged shapes, unless both bound and bound-to shapes are selected\n  const bindingsToDelete = TLDR.getBindings(app.state, currentPageId).filter(\n    (binding) => ids.includes(binding.fromId) && !ids.includes(binding.toId)\n  )\n\n  bindingsToDelete.forEach((binding) => {\n    before.bindings[binding.id] = binding\n    after.bindings[binding.id] = undefined\n\n    for (const id of [binding.toId, binding.fromId]) {\n      // Let's also look at the bound shape...\n      const shape = app.getShape(id)\n\n      if (!shape.handles) continue\n\n      // If the bound shape has a handle that references the deleted binding, delete that reference\n\n      Object.values(shape.handles)\n        .filter((handle) => handle.bindingId === binding.id)\n        .forEach((handle) => {\n          before.shapes[id] = {\n            ...before.shapes[id],\n            handles: {\n              ...before.shapes[id]?.handles,\n              [handle.id]: { bindingId: binding.id },\n            },\n          }\n          after.shapes[id] = {\n            ...after.shapes[id],\n            handles: { ...after.shapes[id]?.handles, [handle.id]: { bindingId: undefined } },\n          }\n        })\n    }\n  })\n\n  return {\n    id: 'translate',\n    before: {\n      document: {\n        pages: {\n          [currentPageId]: before,\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: ids,\n          },\n        },\n      },\n    },\n    after: {\n      document: {\n        pages: {\n          [currentPageId]: after,\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: ids,\n          },\n        },\n      },\n    },\n  }\n}\n", "import { TLDR } from '~state/TLDR'\nimport type { TldrawApp } from '~state/TldrawApp'\nimport type { GroupShape, Patch, TDBinding, TDShape } from '~types'\nimport type { TldrawCommand } from '~types'\n\nexport function ungroupShapes(\n  app: TldrawApp,\n  selectedIds: string[],\n  groupShapes: GroupShape[],\n  pageId: string\n): TldrawCommand | undefined {\n  const { bindings } = app\n\n  const beforeShapes: Record<string, Patch<TDShape | undefined>> = {}\n  const afterShapes: Record<string, Patch<TDShape | undefined>> = {}\n\n  const beforeBindings: Record<string, Patch<TDBinding | undefined>> = {}\n  const afterBindings: Record<string, Patch<TDBinding | undefined>> = {}\n\n  const beforeSelectedIds = selectedIds\n  const afterSelectedIds = selectedIds.filter((id) => !groupShapes.find((shape) => shape.id === id))\n\n  // The group shape\n  groupShapes\n    .filter((shape) => !shape.isLocked)\n    .forEach((groupShape) => {\n      const shapesToReparent: TDShape[] = []\n      const deletedGroupIds: string[] = []\n\n      // Remove the group shape in the next state\n      beforeShapes[groupShape.id] = groupShape\n      afterShapes[groupShape.id] = undefined\n\n      // Select its children in the next state\n      groupShape.children.forEach((id) => {\n        afterSelectedIds.push(id)\n        const shape = app.getShape(id, pageId)\n        shapesToReparent.push(shape)\n      })\n\n      // We'll start placing the shapes at this childIndex\n      const startingChildIndex = groupShape.childIndex\n\n      // And we'll need to fit them under this child index\n      const endingChildIndex = TLDR.getChildIndexAbove(app.state, groupShape.id, pageId)\n\n      const step = (endingChildIndex - startingChildIndex) / shapesToReparent.length\n\n      // An array of shapes in order by their child index\n      const sortedShapes = shapesToReparent.sort((a, b) => a.childIndex - b.childIndex)\n\n      // Reparent shapes to the page\n      sortedShapes.forEach((shape, index) => {\n        beforeShapes[shape.id] = {\n          parentId: shape.parentId,\n          childIndex: shape.childIndex,\n        }\n\n        afterShapes[shape.id] = {\n          parentId: pageId,\n          childIndex: startingChildIndex + step * index,\n        }\n      })\n\n      // We also need to delete bindings that reference the deleted shapes\n      bindings\n        .filter((binding) => binding.toId === groupShape.id || binding.fromId === groupShape.id)\n        .forEach((binding) => {\n          for (const id of [binding.toId, binding.fromId]) {\n            // If the binding references the deleted group...\n            if (afterShapes[id] === undefined) {\n              // Delete the binding\n              beforeBindings[binding.id] = binding\n              afterBindings[binding.id] = undefined\n\n              // Let's also look each the bound shape...\n              const shape = app.getShape(id, pageId)\n\n              // If the bound shape has a handle that references the deleted binding...\n              if (shape.handles) {\n                Object.values(shape.handles)\n                  .filter((handle) => handle.bindingId === binding.id)\n                  .forEach((handle) => {\n                    // Save the binding reference in the before patch\n                    beforeShapes[id] = {\n                      ...beforeShapes[id],\n                      handles: {\n                        ...beforeShapes[id]?.handles,\n                        [handle.id]: { bindingId: binding.id },\n                      },\n                    }\n\n                    // Unless we're currently deleting the shape, remove the\n                    // binding reference from the after patch\n                    if (!deletedGroupIds.includes(id)) {\n                      afterShapes[id] = {\n                        ...afterShapes[id],\n                        handles: {\n                          ...afterShapes[id]?.handles,\n                          [handle.id]: { bindingId: undefined },\n                        },\n                      }\n                    }\n                  })\n              }\n            }\n          }\n        })\n    })\n\n  return {\n    id: 'ungroup',\n    before: {\n      document: {\n        pages: {\n          [pageId]: {\n            shapes: beforeShapes,\n            bindings: beforeBindings,\n          },\n        },\n        pageStates: {\n          [pageId]: {\n            selectedIds: beforeSelectedIds,\n          },\n        },\n      },\n    },\n    after: {\n      document: {\n        pages: {\n          [pageId]: {\n            shapes: afterShapes,\n            bindings: beforeBindings,\n          },\n        },\n        pageStates: {\n          [pageId]: {\n            selectedIds: afterSelectedIds,\n          },\n        },\n      },\n    },\n  }\n}\n", "import { TLDR } from '~state/TLDR'\nimport type { TldrawApp } from '~state/TldrawApp'\nimport type { TDShape, TldrawCommand } from '~types'\n\nexport function updateShapes(\n  app: TldrawApp,\n  updates: ({ id: string } & Partial<TDShape>)[],\n  pageId: string\n): TldrawCommand {\n  const ids = updates.map((update) => update.id)\n\n  const change = TLDR.mutateShapes(\n    app.state,\n    ids.filter((id) => !app.getShape(id, pageId).isLocked),\n    (_shape, i) => updates[i],\n    pageId\n  )\n\n  return {\n    id: 'update',\n    before: {\n      document: {\n        pages: {\n          [pageId]: {\n            shapes: change.before,\n          },\n        },\n      },\n    },\n    after: {\n      document: {\n        pages: {\n          [pageId]: {\n            shapes: change.after,\n          },\n        },\n      },\n    },\n  }\n}\n", "import type { TldrawApp } from '~state'\nimport type { TDShape, TldrawCommand } from '~types'\n\nexport function setShapesProps<T extends TDShape>(\n  app: TldrawApp,\n  ids: string[],\n  partial: Partial<T>\n): TldrawCommand {\n  const { currentPageId, selectedIds } = app\n\n  const initialShapes = ids\n    .map((id) => app.getShape<T>(id))\n    .filter((shape) => (partial['isLocked'] ? true : !shape.isLocked))\n\n  const before: Record<string, Partial<TDShape>> = {}\n  const after: Record<string, Partial<TDShape>> = {}\n\n  const keys = Object.keys(partial) as (keyof T)[]\n\n  initialShapes.forEach((shape) => {\n    before[shape.id] = Object.fromEntries(keys.map((key) => [key, shape[key]]))\n    after[shape.id] = partial\n  })\n\n  return {\n    id: 'set_props',\n    before: {\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes: before,\n          },\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds,\n          },\n        },\n      },\n    },\n    after: {\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes: after,\n          },\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds,\n          },\n        },\n      },\n    },\n  }\n}\n", "import { Utils } from '@tldraw/core'\nimport { Vec } from '@tldraw/vec'\nimport { TLDR } from '~state/TLDR'\nimport type { TldrawApp } from '~state/TldrawApp'\nimport type { PagePartial, TDAsset, TDBinding, TDShape, TldrawCommand } from '~types'\n\nexport function insertContent(\n  app: TldrawApp,\n  content: { shapes: TDShape[]; bindings?: TDBinding[]; assets?: TDAsset[] },\n  opts = {} as { point?: number[]; select?: boolean; overwrite?: boolean }\n): TldrawCommand {\n  const { currentPageId } = app\n  const { point, select, overwrite } = opts\n\n  const page = app.document.pages[currentPageId]\n\n  const before: PagePartial = {\n    shapes: {},\n    bindings: {},\n  }\n\n  const afterAssets: Record<string, TDAsset> = {}\n\n  const after: PagePartial = {\n    shapes: {},\n    bindings: {},\n  }\n\n  if (overwrite) {\n    // Map shapes and bindings onto new IDs to avoid overwriting existing content.\n    for (const shape of content.shapes) {\n      before.shapes[shape.id] = page.shapes[shape.id]\n      after.shapes[shape.id] = shape\n    }\n    if (content.bindings) {\n      for (const binding of content.bindings) {\n        before.bindings[binding.id] = page.bindings[binding.id]\n        after.bindings[binding.id] = binding\n      }\n    }\n    if (content.assets) {\n      for (const asset of content.assets) {\n        afterAssets[asset.id] = asset\n      }\n    }\n  } else {\n    // Map shapes and bindings onto new IDs to avoid overwriting existing content.\n\n    const oldToNewIds: Record<string, string> = {}\n\n    // The index of the new shape\n    let nextIndex = TLDR.getTopChildIndex(app.state, currentPageId)\n\n    const shapesToInsert: TDShape[] = content.shapes\n      .sort((a, b) => a.childIndex - b.childIndex)\n      .map((shape) => {\n        const newShapeId = Utils.uniqueId()\n        oldToNewIds[shape.id] = newShapeId\n\n        // The redo should include a clone of the new shape\n        return {\n          ...Utils.deepClone(shape),\n          id: newShapeId,\n        }\n      })\n\n    const visited = new Set<string>()\n\n    // Iterate through the list, starting from the front\n    while (shapesToInsert.length > 0) {\n      const shape = shapesToInsert.shift()\n\n      if (!shape) break\n\n      visited.add(shape.id)\n\n      if (shape.parentId === 'currentPageId') {\n        shape.parentId = currentPageId\n        shape.childIndex = nextIndex++\n      } else {\n        // The shape had another shape as its parent.\n\n        // Re-assign the shape's parentId to the new id\n        shape.parentId = oldToNewIds[shape.parentId]\n\n        // Has that parent been added yet to the after object?\n        const parent = after.shapes[shape.parentId]\n\n        if (!parent) {\n          if (visited.has(shape.id)) {\n            // If we've already visited this shape, then that means\n            // its parent was not among the shapes to insert. Set it\n            // to be a child of the current page instead.\n            shape.parentId = 'currentPageId'\n          }\n\n          // If the parent hasn't been added yet, push this shape\n          // to back of the queue; we'll try and add it again later\n          shapesToInsert.push(shape)\n          continue\n        }\n\n        // If we've found the parent, add this shape's id to its children\n        parent.children!.push(shape.id)\n      }\n\n      // If the inserting shape has its own children, set the children to\n      // an empty array; we'll add them later, as just shown above\n      if (shape.children) {\n        shape.children = []\n      }\n\n      // The undo should remove the inserted shape\n      before.shapes[shape.id] = undefined\n\n      // The redo should include the inserted shape\n      after.shapes[shape.id] = shape\n    }\n\n    Object.values(after.shapes).forEach((shape) => {\n      // If the shape used to have children, but no longer does have children,\n      // then delete the shape. This prevents inserting groups without children.\n      if (shape!.children && shape!.children.length === 0) {\n        delete before.shapes[shape!.id!]\n        delete after.shapes[shape!.id!]\n      }\n    })\n\n    // Insert bindings\n    if (content.bindings) {\n      content.bindings.forEach((binding) => {\n        const newBindingId = Utils.uniqueId()\n        oldToNewIds[binding.id] = newBindingId\n\n        const toId = oldToNewIds[binding.toId]\n        const fromId = oldToNewIds[binding.fromId]\n\n        // If the binding is \"to\" or \"from\" a shape that hasn't been inserted,\n        // we'll need to skip the binding and remove it from any shape that\n        // references it.\n        if (!toId || !fromId) {\n          if (fromId) {\n            const handles = after.shapes[fromId]!.handles\n            if (handles) {\n              Object.values(handles).forEach((handle) => {\n                if (handle!.bindingId === binding.id) {\n                  handle!.bindingId = undefined\n                }\n              })\n            }\n          }\n\n          if (toId) {\n            const handles = after.shapes[toId]!.handles\n            if (handles) {\n              Object.values(handles).forEach((handle) => {\n                if (handle!.bindingId === binding.id) {\n                  handle!.bindingId = undefined\n                }\n              })\n            }\n          }\n\n          return\n        }\n\n        // Update the shape's to and from references to the new bindingid\n\n        const fromHandles = after.shapes[fromId]!.handles\n        if (fromHandles) {\n          Object.values(fromHandles).forEach((handle) => {\n            if (handle!.bindingId === binding.id) {\n              handle!.bindingId = newBindingId\n            }\n          })\n        }\n\n        const toHandles = after.shapes[toId]!.handles\n        if (toHandles) {\n          Object.values(after.shapes[toId]!.handles!).forEach((handle) => {\n            if (handle!.bindingId === binding.id) {\n              handle!.bindingId = newBindingId\n            }\n          })\n        }\n\n        const newBinding = {\n          ...Utils.deepClone(binding),\n          id: newBindingId,\n          toId,\n          fromId,\n        }\n\n        // The undo should remove the inserted binding\n        before.bindings[newBinding.id] = undefined\n\n        // The redo should include the inserted binding\n        after.bindings[newBinding.id] = newBinding\n      })\n    }\n\n    // Now move the shapes\n\n    const shapesToMove = Object.values(after.shapes) as TDShape[]\n\n    if (shapesToMove.length > 0) {\n      if (point) {\n        // Move the shapes so that they're centered on the given point\n        const commonBounds = Utils.getCommonBounds(\n          shapesToMove.map((shape) => TLDR.getBounds(shape))\n        )\n        const center = Utils.getBoundsCenter(commonBounds)\n        shapesToMove.forEach((shape) => {\n          if (!shape.point) return\n          shape.point = Vec.sub(point, Vec.sub(center, shape.point))\n        })\n      } else {\n        const commonBounds = Utils.getCommonBounds(shapesToMove.map(TLDR.getBounds))\n\n        if (\n          !(\n            Utils.boundsContain(app.viewport, commonBounds) ||\n            Utils.boundsCollide(app.viewport, commonBounds)\n          )\n        ) {\n          const center = Vec.toFixed(app.getPagePoint(app.centerPoint))\n\n          const centeredBounds = Utils.centerBounds(commonBounds, center)\n\n          const delta = Vec.sub(\n            Utils.getBoundsCenter(centeredBounds),\n            Utils.getBoundsCenter(commonBounds)\n          )\n\n          shapesToMove.forEach((shape) => {\n            shape.point = Vec.toFixed(Vec.add(shape.point, delta))\n          })\n        }\n      }\n    }\n    if (content.assets) {\n      for (const asset of content.assets) {\n        afterAssets[asset.id] = asset\n      }\n    }\n  }\n\n  const elm = document.createElement('textarea')\n\n  Object.values(after.shapes as Record<string, TDShape>).forEach((shape) => {\n    if ('text' in shape) {\n      elm.innerHTML = shape.text\n      shape.text = elm.value\n    }\n\n    if ('label' in shape) {\n      elm.innerHTML = shape.label!\n      shape.label = elm.value\n    }\n  })\n\n  elm.remove()\n\n  return {\n    id: 'insert',\n    before: {\n      document: {\n        pages: {\n          [currentPageId]: before,\n        },\n        pageStates: {\n          [currentPageId]: { selectedIds: [...app.selectedIds] },\n        },\n      },\n    },\n    after: {\n      document: {\n        pages: {\n          [currentPageId]: after,\n        },\n        assets: afterAssets,\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: select ? Object.keys(after.shapes) : [...app.selectedIds],\n          },\n        },\n      },\n    },\n  }\n}\n", "export * from './migrate'\nexport * from './filesystem'\nexport * from 'browser-fs-access'\n", "import {\n  Decoration,\n  FontStyle,\n  TDExportBackground,\n  TDShapeType,\n  TDSnapshot,\n  TextShape,\n} from '~types'\n\nexport function migrate(state: TDSnapshot, newVersion: number): TDSnapshot {\n  const { document, settings } = state\n  const { version = 0 } = document\n\n  if (!('assets' in document)) {\n    document.assets = {}\n  }\n\n  // Remove unused assets when loading a document\n  const assetIdsInUse = new Set<string>()\n\n  Object.values(document.pages).forEach((page) =>\n    Object.values(page.shapes).forEach((shape) => {\n      const { parentId, children, assetId } = shape\n\n      if (assetId) {\n        assetIdsInUse.add(assetId)\n      }\n\n      // Fix missing parent bug\n      if (parentId !== page.id && !page.shapes[parentId]) {\n        console.warn('Encountered a shape with a missing parent!')\n        shape.parentId = page.id\n      }\n\n      if (shape.type === TDShapeType.Group && children) {\n        children.forEach((childId) => {\n          if (!page.shapes[childId]) {\n            console.warn('Encountered a parent with a missing child!', shape.id, childId)\n            children?.splice(children.indexOf(childId), 1)\n          }\n        })\n\n        // TODO: Remove the shape if it has no children\n      }\n    })\n  )\n\n  Object.keys(document.assets).forEach((assetId) => {\n    if (!assetIdsInUse.has(assetId)) {\n      delete document.assets[assetId]\n    }\n  })\n\n  if (version !== newVersion) {\n    if (version < 14) {\n      Object.values(document.pages).forEach((page) => {\n        Object.values(page.shapes)\n          .filter((shape) => shape.type === TDShapeType.Text)\n          .forEach((shape) => (shape as TextShape).style.font === FontStyle.Script)\n      })\n    }\n\n    // Lowercase styles, move binding meta to binding\n    if (version <= 13) {\n      Object.values(document.pages).forEach((page) => {\n        Object.values(page.bindings).forEach((binding) => {\n          Object.assign(binding, (binding as any).meta)\n        })\n\n        Object.values(page.shapes).forEach((shape) => {\n          Object.entries(shape.style).forEach(([id, style]) => {\n            if (typeof style === 'string') {\n              // @ts-ignore\n              shape.style[id] = style.toLowerCase()\n            }\n          })\n\n          if (shape.type === TDShapeType.Arrow) {\n            if (shape.decorations) {\n              Object.entries(shape.decorations).forEach(([id, decoration]) => {\n                if ((decoration as unknown) === 'Arrow') {\n                  shape.decorations = {\n                    ...shape.decorations,\n                    [id]: Decoration.Arrow,\n                  }\n                }\n              })\n            }\n          }\n        })\n      })\n    }\n\n    // Add document name and file system handle\n    if (version <= 13.1) {\n      document.name = 'New Document'\n    }\n\n    if (version < 15) {\n      document.assets = {}\n    }\n\n    Object.values(document.pages).forEach((page) => {\n      Object.values(page.shapes).forEach((shape) => {\n        if (version < 15.2) {\n          if (shape.type === TDShapeType.Image || shape.type === TDShapeType.Video) {\n            shape.style.isFilled = true\n          }\n        }\n\n        if (version < 15.3) {\n          if (\n            shape.type === TDShapeType.Rectangle ||\n            shape.type === TDShapeType.Triangle ||\n            shape.type === TDShapeType.Ellipse ||\n            shape.type === TDShapeType.Arrow\n          ) {\n            shape.label = (shape as any).text || ''\n            shape.labelPoint = [0.5, 0.5]\n          }\n        }\n      })\n    })\n\n    if (version < 15.4) {\n      settings.dockPosition = 'bottom'\n    }\n\n    if (version < 15.5) {\n      settings.exportBackground = TDExportBackground.Transparent\n    }\n  }\n\n  // Cleanup\n  Object.values(document.pageStates).forEach((pageState) => {\n    pageState.selectedIds = pageState.selectedIds.filter((id) => {\n      return document.pages[pageState.id].shapes[id] !== undefined\n    })\n    pageState.bindingId = undefined\n    pageState.editingId = undefined\n    pageState.hoveredId = undefined\n    pageState.pointedId = undefined\n  })\n\n  document.version = newVersion\n\n  return state\n}\n", "import { fileOpen, fileSave, supported } from 'browser-fs-access'\nimport type { FileSystemHandle } from 'browser-fs-access'\nimport { get as getFromIdb, set as setToIdb } from 'idb-keyval'\nimport { FILE_EXTENSION, IMAGE_EXTENSIONS, VIDEO_EXTENSIONS } from '~constants'\nimport type { TDDocument, TDFile } from '~types'\n\nconst options = { mode: 'readwrite' as const }\n\nconst checkPermissions = async (handle: FileSystemFileHandle) => {\n  return (\n    (await (handle as unknown as FileSystemHandle).queryPermission(options)) === 'granted' ||\n    (await (handle as unknown as FileSystemHandle).requestPermission(options)) === 'granted'\n  )\n}\n\nexport async function loadFileHandle() {\n  if (typeof Window === 'undefined' || !('_location' in Window)) return\n  const fileHandle = await getFromIdb(`Tldraw_file_handle_${window.location.origin}`)\n  if (!fileHandle) return null\n  return fileHandle\n}\n\nexport async function saveFileHandle(fileHandle: FileSystemFileHandle | null) {\n  return setToIdb(`Tldraw_file_handle_${window.location.origin}`, fileHandle)\n}\n\nexport async function saveToFileSystem(\n  document: TDDocument,\n  fileHandle: FileSystemFileHandle | null,\n  name?: string\n) {\n  // Create the saved file data\n  const file: TDFile = {\n    name: document.name || 'New Document',\n    fileHandle: fileHandle ?? null,\n    document,\n    assets: {},\n  }\n\n  // Serialize to JSON\n  const json =\n    process.env.NODE_ENV === 'production' ? JSON.stringify(file) : JSON.stringify(file, null, 2)\n\n  // Create blob\n  const blob = new Blob([json], {\n    type: 'application/vnd.Tldraw+json',\n  })\n\n  if (fileHandle) {\n    const hasPermissions = await checkPermissions(fileHandle)\n    if (!hasPermissions) return null\n  }\n  const filename = !supported && name?.length ? name : `${file.name}`\n  // Save to file system\n  const newFileHandle = await fileSave(\n    blob,\n    {\n      fileName: `${filename}${FILE_EXTENSION}`,\n      description: 'Tldraw File',\n      extensions: [`${FILE_EXTENSION}`],\n    },\n    fileHandle\n  )\n\n  await saveFileHandle(newFileHandle)\n\n  // Return true\n  return newFileHandle\n}\n\nexport async function openFromFileSystem(): Promise<null | {\n  fileHandle: FileSystemFileHandle | null\n  document: TDDocument\n}> {\n  // Get the blob\n  const blob = await fileOpen({\n    description: 'Tldraw File',\n    extensions: [`${FILE_EXTENSION}`],\n    multiple: false,\n  })\n\n  if (!blob) return null\n\n  // Get JSON from blob\n  const json: string = await new Promise((resolve) => {\n    const reader = new FileReader()\n    reader.onloadend = () => {\n      if (reader.readyState === FileReader.DONE) {\n        resolve(reader.result as string)\n      }\n    }\n    reader.readAsText(blob, 'utf8')\n  })\n\n  // Parse\n  const file: TDFile = JSON.parse(json)\n\n  const fileHandle = blob.handle ?? null\n\n  await saveFileHandle(fileHandle)\n\n  return {\n    fileHandle,\n    document: file.document,\n  }\n}\n\nexport async function openAssetsFromFileSystem() {\n  return fileOpen({\n    description: 'Image or Video',\n    extensions: [...IMAGE_EXTENSIONS, ...VIDEO_EXTENSIONS],\n    multiple: true,\n  })\n}\n\nexport function fileToBase64(file: Blob): Promise<string | ArrayBuffer | null> {\n  return new Promise((resolve, reject) => {\n    if (file) {\n      const reader = new FileReader()\n      reader.readAsDataURL(file)\n      reader.onload = () => resolve(reader.result)\n      reader.onerror = (error) => reject(error)\n      reader.onabort = (error) => reject(error)\n    }\n  })\n}\n\nexport function fileToText(file: Blob): Promise<string | ArrayBuffer | null> {\n  return new Promise((resolve, reject) => {\n    if (file) {\n      const reader = new FileReader()\n      reader.readAsText(file)\n      reader.onload = () => resolve(reader.result)\n      reader.onerror = (error) => reject(error)\n      reader.onabort = (error) => reject(error)\n    }\n  })\n}\n\nexport function getImageSizeFromSrc(src: string): Promise<number[]> {\n  return new Promise((resolve, reject) => {\n    const img = new Image()\n    img.onload = () => resolve([img.width, img.height])\n    img.onerror = () => reject(new Error('Could not get image size'))\n    img.src = src\n  })\n}\n\nexport function getVideoSizeFromSrc(src: string): Promise<number[]> {\n  return new Promise((resolve, reject) => {\n    const video = document.createElement('video')\n    video.onloadedmetadata = () => resolve([video.videoWidth, video.videoHeight])\n    video.onerror = () => reject(new Error('Could not get video size'))\n    video.src = src\n  })\n}\n", "import { Utils } from '@tldraw/core'\nimport { Vec } from '@tldraw/vec'\nimport { deepCopy } from '~state/StateManager/copy'\nimport { TLDR } from '~state/TLDR'\nimport type { TldrawApp } from '~state/TldrawApp'\nimport { BaseSession } from '~state/sessions/BaseSession'\nimport { shapeUtils } from '~state/shapes'\nimport {\n  ArrowBinding,\n  ArrowShape,\n  SessionType,\n  TDBinding,\n  TDShape,\n  TDShapeType,\n  TDStatus,\n  TldrawCommand,\n  TldrawPatch,\n} from '~types'\n\nexport class ArrowSession extends BaseSession {\n  type = SessionType.Arrow\n  performanceMode = undefined\n  status = TDStatus.TranslatingHandle\n  newStartBindingId = Utils.uniqueId()\n  draggedBindingId = Utils.uniqueId()\n  didBind = false\n  initialShape: ArrowShape\n  handleId: 'start' | 'end'\n  bindableShapeIds: string[]\n  initialBinding?: TDBinding\n  startBindingShapeId?: string\n  isCreate: boolean\n\n  constructor(app: TldrawApp, shapeId: string, handleId: 'start' | 'end', isCreate = false) {\n    super(app)\n\n    this.isCreate = isCreate\n\n    const { currentPageId } = app.state.appState\n\n    const page = app.state.document.pages[currentPageId]\n\n    this.handleId = handleId\n\n    this.initialShape = deepCopy(page.shapes[shapeId] as ArrowShape)\n\n    this.bindableShapeIds = TLDR.getBindableShapeIds(app.state).filter(\n      (id) => !(id === this.initialShape.id || id === this.initialShape.parentId)\n    )\n\n    // TODO: find out why this the oppositeHandleBindingId is sometimes missing\n    const oppositeHandleBindingId =\n      this.initialShape.handles[handleId === 'start' ? 'end' : 'start']?.bindingId\n\n    if (oppositeHandleBindingId) {\n      const oppositeToId = page.bindings[oppositeHandleBindingId]?.toId\n      if (oppositeToId) {\n        this.bindableShapeIds = this.bindableShapeIds.filter((id) => id !== oppositeToId)\n      }\n    }\n\n    const { originPoint } = this.app\n\n    if (this.isCreate) {\n      // If we're creating a new shape, should we bind its first point?\n      // The method may return undefined, which is correct if there is no\n      // bindable shape under the pointer.\n      this.startBindingShapeId = this.bindableShapeIds\n        .map((id) => page.shapes[id])\n        .filter(\n          (shape) =>\n            !shape.isLocked &&\n            Utils.pointInBounds(originPoint, TLDR.getShapeUtil(shape).getBounds(shape))\n        )\n        .sort((a, b) => {\n          // TODO - We should be smarter here, what's the right logic?\n          return b.childIndex - a.childIndex\n        })[0]?.id\n\n      if (this.startBindingShapeId) {\n        this.bindableShapeIds.splice(this.bindableShapeIds.indexOf(this.startBindingShapeId), 1)\n      }\n    } else {\n      // If we're editing an existing line, is there a binding already\n      // for the dragging handle?\n      const initialBindingId = this.initialShape.handles[this.handleId].bindingId\n\n      if (initialBindingId) {\n        this.initialBinding = page.bindings[initialBindingId]\n      } else {\n        // If not, explicitly set this handle to undefined, so that it gets deleted on undo\n        this.initialShape.handles[this.handleId].bindingId = undefined\n      }\n    }\n  }\n\n  start = (): TldrawPatch | undefined => void null\n\n  update = (): TldrawPatch | undefined => {\n    const { initialShape } = this\n    const {\n      currentPoint,\n      shiftKey,\n      altKey,\n      metaKey,\n      currentGrid,\n      settings: { showGrid },\n    } = this.app\n\n    const shape = this.app.getShape<ArrowShape>(initialShape.id)\n\n    if (shape.isLocked) return\n\n    const { handles } = initialShape\n\n    const handleId = this.handleId as keyof typeof handles\n    // If the handle can bind, then we need to search bindable shapes for\n    // a binding.\n    if (!handles[handleId].canBind) return\n\n    // Find the delta (in shape space)\n    let delta = Vec.sub(currentPoint, Vec.add(handles[handleId].point, initialShape.point))\n\n    if (shiftKey) {\n      const A = altKey\n        ? Vec.med(handles.start.point, handles.end.point)\n        : handles[handleId === 'start' ? 'end' : 'start'].point\n      const B = handles[handleId].point\n      const C = Vec.add(B, delta)\n\n      const angle = Vec.angle(A, C)\n\n      const adjusted = Vec.rotWith(C, A, Utils.snapAngleToSegments(angle, 24) - angle)\n\n      delta = Vec.add(delta, Vec.sub(adjusted, C))\n    }\n\n    const nextPoint = Vec.add(handles[handleId].point, delta)\n\n    const handleChanges = {\n      [handleId]: {\n        ...handles[handleId],\n        point: showGrid ? Vec.snap(nextPoint, currentGrid) : Vec.toFixed(nextPoint),\n        bindingId: undefined,\n      },\n    }\n\n    // if (altKey) {\n    //   // If the user is holding alt key, apply the inverse delta\n    //   // to the oppoosite handle.\n    //   const oppositeHandleId = handleId === 'start' ? 'end' : 'start'\n\n    //   const nextPoint = Vec.sub(handles[oppositeHandleId].point, delta)\n\n    //   handleChanges[oppositeHandleId] = {\n    //     ...handles[oppositeHandleId],\n    //     point: showGrid ? Vec.snap(nextPoint, currentGrid) : Vec.toFixed(nextPoint),\n    //     bindingId: undefined,\n    //   }\n    // }\n\n    const utils = shapeUtils[TDShapeType.Arrow]\n    const handleChange = utils.onHandleChange?.(initialShape, handleChanges)\n\n    // If the handle changed produced no change, bail here\n    if (!handleChange) return\n\n    // If nothing changes, we want these to be the same object reference as\n    // before. If it does change, we'll redefine this later on. And if we've\n    // made it this far, the shape should be a new object reference that\n    // incorporates the changes we've made due to the handle movement.\n    const next: { shape: ArrowShape; bindings: Record<string, TDBinding | undefined> } = {\n      shape: Utils.deepMerge(shape, handleChange),\n      bindings: {},\n    }\n\n    let draggedBinding: ArrowBinding | undefined\n\n    const draggingHandle = next.shape.handles[this.handleId]\n\n    const oppositeHandle = next.shape.handles[this.handleId === 'start' ? 'end' : 'start']\n\n    // START BINDING\n    // If we have a start binding shape id, the recompute the binding\n    // point based on the current end handle position\n    if (this.startBindingShapeId) {\n      let nextStartBinding: ArrowBinding | undefined\n\n      const startTarget = this.app.page.shapes[this.startBindingShapeId]\n\n      const startTargetUtils = TLDR.getShapeUtil(startTarget)\n\n      const center = startTargetUtils.getCenter(startTarget)\n\n      const startHandle = next.shape.handles.start\n\n      const endHandle = next.shape.handles.end\n\n      const rayPoint = Vec.add(startHandle.point, next.shape.point)\n\n      if (Vec.isEqual(rayPoint, center)) rayPoint[1]++ // Fix bug where ray and center are identical\n\n      const rayOrigin = center\n\n      const isInsideShape = startTargetUtils.hitTestPoint(startTarget, currentPoint)\n\n      const rayDirection = Vec.uni(Vec.sub(rayPoint, rayOrigin))\n\n      const hasStartBinding = this.app.getBinding(this.newStartBindingId) !== undefined\n\n      // Don't bind the start handle if both handles are inside of the target shape.\n      if (\n        !metaKey &&\n        !startTargetUtils.hitTestPoint(startTarget, Vec.add(next.shape.point, endHandle.point))\n      ) {\n        nextStartBinding = this.findBindingPoint(\n          shape,\n          startTarget,\n          'start',\n          this.newStartBindingId,\n          center,\n          rayOrigin,\n          rayDirection,\n          isInsideShape\n        )\n      }\n\n      if (nextStartBinding && !hasStartBinding) {\n        // Bind the arrow's start handle to the start target\n        this.didBind = true\n\n        next.bindings[this.newStartBindingId] = nextStartBinding\n\n        next.shape = Utils.deepMerge(next.shape, {\n          handles: {\n            start: {\n              bindingId: nextStartBinding.id,\n            },\n          },\n        })\n      } else if (!nextStartBinding && hasStartBinding) {\n        // Remove the start binding\n        this.didBind = false\n\n        next.bindings[this.newStartBindingId] = undefined\n\n        next.shape = Utils.deepMerge(initialShape, {\n          handles: {\n            start: {\n              bindingId: undefined,\n            },\n          },\n        })\n      }\n    }\n\n    // DRAGGED POINT BINDING\n    if (!metaKey) {\n      const rayOrigin = Vec.add(oppositeHandle.point, next.shape.point)\n\n      const rayPoint = Vec.add(draggingHandle.point, next.shape.point)\n\n      const rayDirection = Vec.uni(Vec.sub(rayPoint, rayOrigin))\n\n      const startPoint = Vec.add(next.shape.point!, next.shape.handles!.start.point!)\n\n      const endPoint = Vec.add(next.shape.point!, next.shape.handles!.end.point!)\n\n      const targets = this.bindableShapeIds\n        .map((id) => this.app.page.shapes[id])\n        .sort((a, b) => b.childIndex - a.childIndex)\n        .filter((shape) => {\n          if (shape.isLocked) return false\n          const utils = TLDR.getShapeUtil(shape)\n          return ![startPoint, endPoint].every((point) => utils.hitTestPoint(shape, point))\n        })\n\n      for (const target of targets) {\n        draggedBinding = this.findBindingPoint(\n          shape,\n          target,\n          this.handleId,\n          this.draggedBindingId,\n          rayPoint,\n          rayOrigin,\n          rayDirection,\n          altKey\n        )\n\n        if (draggedBinding) break\n      }\n    }\n\n    if (draggedBinding) {\n      // Create the dragged point binding\n      this.didBind = true\n\n      next.bindings[this.draggedBindingId] = draggedBinding\n\n      next.shape = Utils.deepMerge(next.shape, {\n        handles: {\n          [this.handleId]: {\n            bindingId: this.draggedBindingId,\n          },\n        },\n      })\n    } else {\n      // Remove the dragging point binding\n      this.didBind = this.didBind || false\n\n      const currentBindingId = shape.handles[this.handleId].bindingId\n\n      if (currentBindingId !== undefined) {\n        next.bindings[currentBindingId] = undefined\n\n        next.shape = Utils.deepMerge(next.shape, {\n          handles: {\n            [this.handleId]: {\n              bindingId: undefined,\n            },\n          },\n        })\n      }\n    }\n\n    const change = TLDR.getShapeUtil<ArrowShape>(next.shape).onHandleChange?.(\n      next.shape,\n      next.shape.handles\n    )\n\n    return {\n      document: {\n        pages: {\n          [this.app.currentPageId]: {\n            shapes: {\n              [shape.id]: { ...next.shape, ...(change ?? {}) },\n            },\n            bindings: next.bindings,\n          },\n        },\n        pageStates: {\n          [this.app.currentPageId]: {\n            bindingId: next.shape.handles[handleId].bindingId,\n          },\n        },\n      },\n    }\n  }\n\n  cancel = (): TldrawPatch | undefined => {\n    const { initialShape, initialBinding, newStartBindingId, draggedBindingId } = this\n\n    const currentShape = TLDR.onSessionComplete(this.app.page.shapes[initialShape.id]) as ArrowShape\n\n    const isDeleting =\n      this.isCreate ||\n      Vec.dist(currentShape.handles.start.point, currentShape.handles.end.point) < 4\n\n    const afterBindings: Record<string, TDBinding | undefined> = {}\n\n    afterBindings[draggedBindingId] = undefined\n\n    if (initialBinding) {\n      afterBindings[initialBinding.id] = isDeleting ? undefined : initialBinding\n    }\n\n    if (newStartBindingId) {\n      afterBindings[newStartBindingId] = undefined\n    }\n\n    return {\n      document: {\n        pages: {\n          [this.app.currentPageId]: {\n            shapes: {\n              [initialShape.id]: isDeleting ? undefined : initialShape,\n            },\n            bindings: afterBindings,\n          },\n        },\n        pageStates: {\n          [this.app.currentPageId]: {\n            selectedIds: isDeleting ? [] : [initialShape.id],\n            bindingId: undefined,\n            hoveredId: undefined,\n            editingId: undefined,\n          },\n        },\n      },\n    }\n  }\n\n  complete = (): TldrawPatch | TldrawCommand | undefined => {\n    const { initialShape, initialBinding, newStartBindingId, startBindingShapeId, handleId } = this\n\n    const currentShape = TLDR.onSessionComplete(this.app.page.shapes[initialShape.id]) as ArrowShape\n\n    const currentBindingId = currentShape.handles[handleId].bindingId\n\n    const length = Vec.dist(currentShape.handles.start.point, currentShape.handles.end.point)\n\n    if (!(currentBindingId || initialBinding) && length < 4) return this.cancel()\n\n    const beforeBindings: Partial<Record<string, TDBinding>> = {}\n\n    const afterBindings: Partial<Record<string, TDBinding>> = {}\n\n    if (initialBinding) {\n      beforeBindings[initialBinding.id] = this.isCreate ? undefined : initialBinding\n      afterBindings[initialBinding.id] = undefined\n    }\n\n    if (currentBindingId) {\n      beforeBindings[currentBindingId] = undefined\n      afterBindings[currentBindingId] = this.app.page.bindings[currentBindingId]\n    }\n\n    if (startBindingShapeId) {\n      beforeBindings[newStartBindingId] = undefined\n      afterBindings[newStartBindingId] = this.app.page.bindings[newStartBindingId]\n    }\n\n    return {\n      id: 'arrow',\n      before: {\n        document: {\n          pages: {\n            [this.app.currentPageId]: {\n              shapes: {\n                [initialShape.id]: this.isCreate ? undefined : initialShape,\n              },\n              bindings: beforeBindings,\n            },\n          },\n          pageStates: {\n            [this.app.currentPageId]: {\n              selectedIds: this.isCreate ? [] : [initialShape.id],\n              bindingId: undefined,\n              hoveredId: undefined,\n              editingId: undefined,\n            },\n          },\n        },\n      },\n      after: {\n        document: {\n          pages: {\n            [this.app.currentPageId]: {\n              shapes: {\n                [initialShape.id]: currentShape,\n              },\n              bindings: afterBindings,\n            },\n          },\n          pageStates: {\n            [this.app.currentPageId]: {\n              selectedIds: [initialShape.id],\n              bindingId: undefined,\n              hoveredId: undefined,\n              editingId: undefined,\n            },\n          },\n        },\n      },\n    }\n  }\n\n  private findBindingPoint = (\n    shape: ArrowShape,\n    target: TDShape,\n    handleId: 'start' | 'end',\n    bindingId: string,\n    point: number[],\n    origin: number[],\n    direction: number[],\n    bindAnywhere: boolean\n  ) => {\n    const util = TLDR.getShapeUtil<TDShape>(target.type)\n\n    const bindingPoint = util.getBindingPoint(\n      target,\n      shape,\n      point, // fix dead center bug\n      origin,\n      direction,\n      bindAnywhere\n    )\n\n    // Not all shapes will produce a binding point\n    if (!bindingPoint) return\n\n    return {\n      id: bindingId,\n      type: 'arrow',\n      fromId: shape.id,\n      toId: target.id,\n      handleId: handleId,\n      point: Vec.toFixed(bindingPoint.point),\n      distance: bindingPoint.distance,\n    }\n  }\n}\n", "import type { TLPerformanceMode } from '@tldraw/core'\nimport type { TldrawApp } from '~state/TldrawApp'\nimport type { SessionType, TldrawCommand, TldrawPatch } from '~types'\n\nexport abstract class BaseSession {\n  abstract type: SessionType\n  abstract performanceMode: TLPerformanceMode | undefined\n  constructor(public app: TldrawApp) {}\n  abstract start: () => TldrawPatch | undefined\n  abstract update: () => TldrawPatch | undefined\n  abstract complete: () => TldrawPatch | TldrawCommand | undefined\n  abstract cancel: () => TldrawPatch | undefined\n}\n", "import { TLBounds, Utils } from '@tldraw/core'\nimport type { TldrawApp } from '~state/TldrawApp'\nimport { BaseSession } from '~state/sessions/BaseSession'\nimport { SessionType, TDStatus, TldrawCommand, TldrawPatch } from '~types'\n\nexport class BrushSession extends BaseSession {\n  type = SessionType.Brush\n  performanceMode = undefined\n  status = TDStatus.Brushing\n  initialSelectedIds: Set<string>\n  shapesToTest: {\n    id: string\n    bounds: TLBounds\n    selectId: string\n  }[]\n\n  constructor(app: TldrawApp) {\n    super(app)\n    const { currentPageId } = app\n    this.initialSelectedIds = new Set(this.app.selectedIds)\n    this.shapesToTest = this.app.shapes\n      .filter(\n        (shape) =>\n          !(\n            shape.isLocked ||\n            shape.isHidden ||\n            shape.parentId !== currentPageId ||\n            this.initialSelectedIds.has(shape.id) ||\n            this.initialSelectedIds.has(shape.parentId)\n          )\n      )\n      .map((shape) => ({\n        id: shape.id,\n        bounds: this.app.getShapeUtil(shape).getBounds(shape),\n        selectId: shape.id, //TLDR.getTopParentId(data, shape.id, currentPageId),\n      }))\n\n    this.update()\n  }\n\n  start = (): TldrawPatch | undefined => void null\n\n  update = (): TldrawPatch | undefined => {\n    const {\n      initialSelectedIds,\n      shapesToTest,\n      app: { metaKey, settings, originPoint, currentPoint },\n    } = this\n\n    // Create a bounding box between the origin and the new point\n    const brush = Utils.getBoundsFromPoints([originPoint, currentPoint])\n\n    // Decide weather to select by intersecting or by overlapping\n    // Using a xor to revers the behaviour if the ctrl key is pressed\n    // Do it only if the user choose to enable cad like selection\n    const selectByContain = settings.isCadSelectMode\n      ? !metaKey && originPoint[0] < currentPoint[0]\n      : metaKey\n\n    // Find ids of brushed shapes\n    const hits = new Set<string>()\n\n    const selectedIds = new Set(initialSelectedIds)\n\n    shapesToTest.forEach(({ id, selectId }) => {\n      const shape = this.app.getShape(id)\n\n      if (!hits.has(selectId)) {\n        const util = this.app.getShapeUtil(shape)\n        if (\n          selectByContain\n            ? Utils.boundsContain(brush, util.getBounds(shape))\n            : util.hitTestBounds(shape, brush)\n        ) {\n          hits.add(selectId)\n\n          // When brushing a shape, select its top group parent.\n          if (!selectedIds.has(selectId)) {\n            selectedIds.add(selectId)\n          }\n        } else if (selectedIds.has(selectId)) {\n          selectedIds.delete(selectId)\n        }\n      }\n    })\n\n    const currentSelectedIds = this.app.selectedIds\n\n    const didChange =\n      selectedIds.size !== currentSelectedIds.length ||\n      currentSelectedIds.some((id) => !selectedIds.has(id))\n\n    const afterSelectedIds = didChange ? Array.from(selectedIds.values()) : currentSelectedIds\n\n    if (!didChange)\n      return {\n        appState: {\n          selectByContain,\n        },\n        document: {\n          pageStates: {\n            [this.app.currentPageId]: {\n              brush,\n            },\n          },\n        },\n      }\n\n    return {\n      appState: {\n        selectByContain,\n      },\n      document: {\n        pageStates: {\n          [this.app.currentPageId]: {\n            brush,\n            selectedIds: afterSelectedIds,\n          },\n        },\n      },\n    }\n  }\n\n  cancel = (): TldrawPatch | undefined => {\n    return {\n      appState: {\n        selectByContain: false,\n      },\n      document: {\n        pageStates: {\n          [this.app.currentPageId]: {\n            brush: null,\n            selectedIds: Array.from(this.initialSelectedIds.values()),\n          },\n        },\n      },\n    }\n  }\n\n  complete = (): TldrawPatch | TldrawCommand | undefined => {\n    return {\n      appState: {\n        selectByContain: false,\n      },\n      document: {\n        pageStates: {\n          [this.app.currentPageId]: {\n            brush: null,\n            selectedIds: [...this.app.selectedIds],\n          },\n        },\n      },\n    }\n  }\n}\n", "import { Utils } from '@tldraw/core'\nimport { Vec } from '@tldraw/vec'\nimport type { TldrawApp } from '~state/TldrawApp'\nimport { BaseSession } from '~state/sessions/BaseSession'\nimport { DrawShape, SessionType, TDStatus, TldrawCommand, TldrawPatch } from '~types'\n\nexport class DrawSession extends BaseSession {\n  type = SessionType.Draw\n  performanceMode = undefined\n  status = TDStatus.Creating\n  topLeft: number[]\n  points: number[][]\n  initialShape: DrawShape\n  lastAdjustedPoint: number[]\n  shiftedPoints: number[][] = []\n  shapeId: string\n  isLocked?: boolean\n  isExtending: boolean\n  lockedDirection?: 'horizontal' | 'vertical'\n\n  constructor(app: TldrawApp, id: string) {\n    super(app)\n    const { originPoint } = this.app\n    this.shapeId = id\n    this.initialShape = this.app.getShape<DrawShape>(id)\n    this.topLeft = [...this.initialShape.point]\n    const currentPoint = [0, 0, originPoint[2] ?? 0.5]\n    const delta = Vec.sub(originPoint, this.topLeft)\n    const initialPoints = this.initialShape.points.map((pt) => Vec.sub(pt, delta).concat(pt[2]))\n    this.isExtending = initialPoints.length > 0\n    const newPoints: number[][] = []\n    if (this.isExtending) {\n      // Continuing with shift\n      const prevPoint = initialPoints[initialPoints.length - 1]\n      if (prevPoint) {\n        newPoints.push(prevPoint, prevPoint)\n        const len = Math.floor(Vec.dist(prevPoint, currentPoint) / 16)\n\n        if (len > 1) {\n          for (let i = 0; i < len; i++) {\n            const t = i / (len - 1)\n            newPoints.push(Vec.lrp(prevPoint, currentPoint, t).concat(prevPoint[2]))\n          }\n        } else {\n          newPoints.push(currentPoint, currentPoint)\n        }\n      }\n    } else {\n      newPoints.push(currentPoint)\n    }\n    // Add a first point but don't update the shape yet. We'll update\n    // when the draw session ends; if the user hasn't added additional\n    // points, this single point will be interpreted as a \"dot\" shape.\n    this.points = [...initialPoints, ...newPoints]\n    this.shiftedPoints = this.points.map((pt) => Vec.add(pt, delta).concat(pt[2]))\n    this.lastAdjustedPoint = this.points[this.points.length - 1]\n  }\n\n  start = () => {\n    const currentPoint = this.app.originPoint\n    const newAdjustedPoint = [0, 0, currentPoint[2] ?? 0.5]\n    // Add the new adjusted point to the points array\n    this.points.push(newAdjustedPoint)\n    const topLeft = [\n      Math.min(this.topLeft[0], currentPoint[0]),\n      Math.min(this.topLeft[1], currentPoint[1]),\n    ]\n    const delta = Vec.sub(topLeft, currentPoint)\n    this.topLeft = topLeft\n    this.shiftedPoints = this.points.map((pt) => Vec.toFixed(Vec.sub(pt, delta)).concat(pt[2]))\n\n    return {\n      document: {\n        pages: {\n          [this.app.currentPageId]: {\n            shapes: {\n              [this.shapeId]: {\n                point: this.topLeft,\n                points: this.shiftedPoints,\n              },\n            },\n          },\n        },\n        pageStates: {\n          [this.app.currentPageId]: {\n            selectedIds: [this.shapeId],\n          },\n        },\n      },\n    }\n  }\n\n  update = (): TldrawPatch | undefined => {\n    const { shapeId } = this\n    const { currentPoint, originPoint, shiftKey, zoom } = this.app\n\n    // Even if we're not locked yet, we base the future locking direction\n    // on the first dimension to reach a threshold, or the bigger dimension\n    // once one or both dimensions have reached the threshold.\n    if (!this.lockedDirection && this.points.length > 1) {\n      const delta = Vec.sub(currentPoint, originPoint)\n      if (Vec.len(delta) > 3 / zoom) {\n        this.lockedDirection = Math.abs(delta[0]) > Math.abs(delta[1]) ? 'horizontal' : 'vertical'\n      }\n    }\n\n    // Drawing while holding shift will \"lock\" the pen to either the\n    // x or y axis, depending on the locking direction.\n    if (shiftKey) {\n      if (!this.isLocked && this.points.length > 2) {\n        // If we're locking before knowing what direction we're in, set it\n        // early based on the bigger dimension.\n        if (!this.lockedDirection) {\n          const delta = Vec.sub(currentPoint, originPoint)\n          if (Vec.len(delta) > 3 / zoom) {\n            this.lockedDirection =\n              Math.abs(delta[0]) > Math.abs(delta[1]) ? 'horizontal' : 'vertical'\n          }\n        }\n\n        this.isLocked = true\n        // Start locking\n        const returning = [...this.lastAdjustedPoint]\n\n        if (this.lockedDirection === 'vertical') {\n          returning[0] = 0\n        } else {\n          returning[1] = 0\n        }\n\n        this.points.push(returning.concat(currentPoint[2]))\n      }\n    } else if (this.isLocked) {\n      this.isLocked = false\n    }\n\n    if (this.isLocked) {\n      if (this.lockedDirection === 'vertical') {\n        currentPoint[0] = originPoint[0]\n      } else {\n        currentPoint[1] = originPoint[1]\n      }\n    }\n\n    const change = this.addPoint(currentPoint)\n\n    if (!change) return\n\n    return {\n      document: {\n        pages: {\n          [this.app.currentPageId]: {\n            shapes: {\n              [shapeId]: change,\n            },\n          },\n        },\n        pageStates: {\n          [this.app.currentPageId]: {\n            selectedIds: [shapeId],\n          },\n        },\n      },\n    }\n  }\n\n  cancel = (): TldrawPatch | undefined => {\n    const { shapeId } = this\n    const pageId = this.app.currentPageId\n\n    return {\n      document: {\n        pages: {\n          [pageId]: {\n            shapes: {\n              [shapeId]: this.isExtending ? this.initialShape : undefined,\n            },\n          },\n        },\n        pageStates: {\n          [pageId]: {\n            selectedIds: [],\n          },\n        },\n      },\n    }\n  }\n\n  complete = (): TldrawPatch | TldrawCommand | undefined => {\n    const { shapeId } = this\n    const pageId = this.app.currentPageId\n    const shape = this.app.getShape<DrawShape>(shapeId)\n    return {\n      id: 'create_draw',\n      before: {\n        document: {\n          pages: {\n            [pageId]: {\n              shapes: {\n                [shapeId]: this.isExtending ? this.initialShape : undefined,\n              },\n            },\n          },\n          pageStates: {\n            [pageId]: {\n              selectedIds: [],\n            },\n          },\n        },\n      },\n      after: {\n        document: {\n          pages: {\n            [pageId]: {\n              shapes: {\n                [shapeId]: {\n                  ...shape,\n                  point: Vec.toFixed(shape.point),\n                  points: shape.points.map((pt) => Vec.toFixed(pt)),\n                  isComplete: true,\n                },\n              },\n            },\n          },\n          pageStates: {\n            [this.app.currentPageId]: {\n              selectedIds: [],\n            },\n          },\n        },\n      },\n    }\n  }\n\n  addPoint = (currentPoint: number[]) => {\n    const { originPoint } = this.app\n    // The new adjusted point\n    const newAdjustedPoint = Vec.toFixed(Vec.sub(currentPoint, originPoint)).concat(currentPoint[2])\n\n    // Don't add duplicate points.\n    if (Vec.isEqual(this.lastAdjustedPoint, newAdjustedPoint)) return\n\n    // Add the new adjusted point to the points array\n    this.points.push(newAdjustedPoint)\n\n    // The new adjusted point is now the previous adjusted point.\n    this.lastAdjustedPoint = newAdjustedPoint\n\n    // Does the input point create a new top left?\n    const prevTopLeft = [...this.topLeft]\n\n    const topLeft = [\n      Math.min(this.topLeft[0], currentPoint[0]),\n      Math.min(this.topLeft[1], currentPoint[1]),\n    ]\n\n    const delta = Vec.sub(topLeft, originPoint)\n\n    // Time to shift some points!\n    let points: number[][]\n\n    if (prevTopLeft[0] !== topLeft[0] || prevTopLeft[1] !== topLeft[1]) {\n      this.topLeft = topLeft\n      // If we have a new top left, then we need to iterate through\n      // the \"unshifted\" points array and shift them based on the\n      // offset between the new top left and the original top left.\n      points = this.points.map((pt) => Vec.toFixed(Vec.sub(pt, delta)).concat(pt[2]))\n    } else {\n      // If the new top left is the same as the previous top left,\n      // we don't need to shift anything: we just shift the new point\n      // and add it to the shifted points array.\n      points = [...this.shiftedPoints, Vec.sub(newAdjustedPoint, delta).concat(newAdjustedPoint[2])]\n    }\n\n    this.shiftedPoints = points\n\n    return {\n      point: this.topLeft,\n      points,\n    }\n  }\n}\n", "import type { TldrawApp } from '~state/TldrawApp'\nimport { BaseSession } from '~state/sessions/BaseSession'\nimport { SessionType, TDShape, TldrawCommand, TldrawPatch } from '~types'\n\nexport class EditSession extends BaseSession {\n  type = SessionType.Edit\n  performanceMode = undefined\n\n  initialShape: TDShape\n  initialSelectedIds: string[]\n  currentPageId: string\n  isCreating: boolean\n\n  constructor(app: TldrawApp, id: string, isCreating: boolean) {\n    super(app)\n    this.initialShape = app.getShape(id, app.currentPageId)\n    this.currentPageId = app.currentPageId\n    this.isCreating = isCreating\n    this.initialSelectedIds = [...app.selectedIds]\n  }\n\n  start = (): TldrawPatch | undefined => void null\n\n  update = (): TldrawPatch | undefined => void null\n\n  cancel = (): TldrawPatch | undefined => {\n    return {\n      document: {\n        pages: {\n          [this.currentPageId]: {\n            shapes: {\n              [this.initialShape.id]: this.isCreating ? undefined : this.initialShape,\n            },\n          },\n        },\n        pageStates: {\n          [this.currentPageId]: {\n            selectedIds: this.isCreating ? [] : this.initialSelectedIds,\n            editingId: undefined,\n          },\n        },\n      },\n    }\n  }\n\n  complete = (): TldrawPatch | TldrawCommand | undefined => {\n    const shape = this.app.getShape(this.initialShape.id)\n\n    return {\n      id: 'edit',\n      before: {\n        document: {\n          pages: {\n            [this.currentPageId]: {\n              shapes: {\n                [this.initialShape.id]: this.isCreating ? undefined : this.initialShape,\n              },\n            },\n          },\n          pageStates: {\n            [this.currentPageId]: {\n              selectedIds: this.isCreating ? [] : this.initialSelectedIds,\n              editingId: undefined,\n            },\n          },\n        },\n      },\n      after: {\n        document: {\n          pages: {\n            [this.currentPageId]: {\n              shapes: {\n                [this.initialShape.id]: shape,\n              },\n            },\n          },\n          pageStates: {\n            [this.currentPageId]: {\n              selectedIds: [shape.id],\n              editingId: undefined,\n            },\n          },\n        },\n      },\n    }\n  }\n}\n", "import { Vec } from '@tldraw/vec'\nimport type { TldrawApp } from '~state/TldrawApp'\nimport { BaseSession } from '~state/sessions/BaseSession'\nimport {\n  PagePartial,\n  SessionType,\n  TDBinding,\n  TDShape,\n  TDStatus,\n  TldrawCommand,\n  TldrawPatch,\n} from '~types'\n\nexport class EraseSession extends BaseSession {\n  type = SessionType.Draw\n  performanceMode = undefined\n  status = TDStatus.Creating\n  isLocked?: boolean\n  lockedDirection?: 'horizontal' | 'vertical'\n  erasedShapes = new Set<TDShape>()\n  erasedBindings = new Set<TDBinding>()\n  initialSelectedShapes: TDShape[]\n  erasableShapes: Set<TDShape>\n  prevPoint: number[]\n  prevEraseShapesSize = 0\n\n  constructor(app: TldrawApp) {\n    super(app)\n    this.prevPoint = [...app.originPoint]\n    this.initialSelectedShapes = this.app.selectedIds.map((id) => this.app.getShape(id))\n    this.erasableShapes = new Set(this.app.shapes.filter((shape) => !shape.isLocked))\n    this.interval = this.loop()\n  }\n\n  interval: any\n  timestamp1 = 0\n  timestamp2 = 0\n  prevErasePoint: number[] = []\n\n  loop = () => {\n    const now = Date.now()\n    const elapsed1 = now - this.timestamp1\n    const elapsed2 = now - this.timestamp2\n    const { eraseLine } = this.app.appState\n\n    let next = [...eraseLine]\n    let didUpdate = false\n\n    if (elapsed1 > 16 && this.prevErasePoint !== this.prevPoint) {\n      didUpdate = true\n      next = [...eraseLine, this.prevPoint]\n      this.prevErasePoint = this.prevPoint\n    }\n\n    if (elapsed2 > 32) {\n      if (next.length > 1) {\n        didUpdate = true\n        next.splice(0, Math.ceil(next.length * 0.1))\n        this.timestamp2 = now\n      }\n    }\n\n    if (didUpdate) {\n      this.app.patchState(\n        {\n          appState: {\n            eraseLine: next,\n          },\n        },\n        'eraseline'\n      )\n    }\n\n    this.interval = requestAnimationFrame(this.loop)\n  }\n\n  start = (): TldrawPatch | undefined => void null\n\n  update = (): TldrawPatch | undefined => {\n    const { page, shiftKey, originPoint, currentPoint, zoom } = this.app\n\n    if (shiftKey) {\n      const delta = Vec.sub(currentPoint, originPoint)\n      if (!this.isLocked && Vec.len(delta) > 3 / zoom) {\n        // If we're locking before knowing what direction we're in, set it\n        // early based on the bigger dimension.\n        if (!this.lockedDirection) {\n          const delta = Vec.sub(currentPoint, originPoint)\n          this.lockedDirection = Math.abs(delta[0]) > Math.abs(delta[1]) ? 'horizontal' : 'vertical'\n        }\n\n        this.isLocked = true\n      }\n    } else if (this.isLocked) {\n      this.isLocked = false\n    }\n\n    if (this.isLocked) {\n      if (this.lockedDirection === 'vertical') {\n        currentPoint[0] = originPoint[0]\n      } else {\n        currentPoint[1] = originPoint[1]\n      }\n    }\n\n    const newPoint = Vec.toFixed(Vec.add(originPoint, Vec.sub(currentPoint, originPoint)))\n\n    const deletedShapeIds = new Set<string>([])\n\n    this.erasableShapes.forEach((shape) => {\n      if (this.erasedShapes.has(shape)) return\n      if (this.app.getShapeUtil(shape).hitTestLineSegment(shape, this.prevPoint, newPoint)) {\n        this.erasedShapes.add(shape)\n        deletedShapeIds.add(shape.id)\n\n        if (shape.children !== undefined) {\n          for (const childId of shape.children) {\n            this.erasedShapes.add(this.app.getShape(childId))\n            deletedShapeIds.add(childId)\n          }\n        }\n      }\n    })\n\n    // Erase bindings that reference deleted shapes\n\n    Object.values(page.bindings).forEach((binding) => {\n      for (const id of [binding.toId, binding.fromId]) {\n        if (deletedShapeIds.has(id)) {\n          this.erasedBindings.add(binding)\n        }\n      }\n    })\n\n    this.erasedShapes.forEach((shape) => {\n      // Has the shape been deleted? If so, pull it from the list.\n      if (!this.app.getShape(shape.id)) {\n        this.erasedShapes.delete(shape)\n        this.erasableShapes.delete(shape)\n        deletedShapeIds.delete(shape.id)\n      }\n    })\n\n    const erasedShapes = Array.from(this.erasedShapes.values())\n\n    this.prevPoint = newPoint\n\n    if (erasedShapes.length === this.prevEraseShapesSize) {\n      return\n    }\n\n    this.prevEraseShapesSize = erasedShapes.length\n\n    return {\n      document: {\n        pages: {\n          [page.id]: {\n            shapes: Object.fromEntries(erasedShapes.map((shape) => [shape.id, { isGhost: true }])),\n          },\n        },\n      },\n    }\n  }\n\n  cancel = (): TldrawPatch | undefined => {\n    const { page } = this.app\n\n    cancelAnimationFrame(this.interval)\n\n    this.erasedShapes.forEach((shape) => {\n      if (!this.app.getShape(shape.id)) {\n        this.erasedShapes.delete(shape)\n        this.erasableShapes.delete(shape)\n      }\n    })\n\n    const erasedShapes = Array.from(this.erasedShapes.values())\n\n    return {\n      document: {\n        pages: {\n          [page.id]: {\n            shapes: Object.fromEntries(erasedShapes.map((shape) => [shape.id, { isGhost: false }])),\n          },\n        },\n        pageStates: {\n          [page.id]: {\n            selectedIds: this.initialSelectedShapes.map((shape) => shape.id),\n          },\n        },\n      },\n      appState: {\n        eraseLine: [],\n      },\n    }\n  }\n\n  complete = (): TldrawPatch | TldrawCommand | undefined => {\n    const { page } = this.app\n\n    cancelAnimationFrame(this.interval)\n\n    this.erasedShapes.forEach((shape) => {\n      if (!this.app.getShape(shape.id)) {\n        this.erasedShapes.delete(shape)\n        this.erasableShapes.delete(shape)\n      }\n    })\n\n    this.erasedBindings.forEach((binding) => {\n      if (!this.app.getBinding(binding.id)) {\n        this.erasedBindings.delete(binding)\n      }\n    })\n\n    const erasedShapes = Array.from(this.erasedShapes.values())\n    const erasedBindings = Array.from(this.erasedBindings.values())\n    const erasedShapeIds = erasedShapes.map((shape) => shape.id)\n    const erasedBindingIds = erasedBindings.map((binding) => binding.id)\n\n    const before: PagePartial = {\n      shapes: Object.fromEntries(erasedShapes.map((shape) => [shape.id, shape])),\n      bindings: Object.fromEntries(erasedBindings.map((binding) => [binding.id, binding])),\n    }\n\n    const after: PagePartial = {\n      shapes: Object.fromEntries(erasedShapes.map((shape) => [shape.id, undefined])),\n      bindings: Object.fromEntries(erasedBindings.map((binding) => [binding.id, undefined])),\n    }\n\n    // Remove references on any shape's handles to any deleted bindings\n    this.app.shapes.forEach((shape) => {\n      if (shape.handles && !after.shapes[shape.id]) {\n        Object.values(shape.handles).forEach((handle) => {\n          if (handle.bindingId && erasedBindingIds.includes(handle.bindingId)) {\n            // Save the binding reference in the before patch\n            before.shapes[shape.id] = {\n              ...before.shapes[shape.id],\n              handles: {\n                ...before.shapes[shape.id]?.handles,\n                [handle.id]: handle,\n              },\n            }\n\n            // Save the binding reference in the before patch\n            if (!erasedShapeIds.includes(shape.id)) {\n              after.shapes[shape.id] = {\n                ...after.shapes[shape.id],\n                handles: {\n                  ...after.shapes[shape.id]?.handles,\n                  [handle.id]: {\n                    ...handle,\n                    bindingId: undefined,\n                  },\n                },\n              }\n            }\n          }\n        })\n      }\n    })\n\n    return {\n      id: 'erase',\n      before: {\n        document: {\n          pages: {\n            [page.id]: before,\n          },\n          pageStates: {\n            [page.id]: {\n              selectedIds: this.initialSelectedShapes\n                .filter((shape) => !!this.app.getShape(shape.id))\n                .map((shape) => shape.id),\n            },\n          },\n        },\n        appState: {\n          eraseLine: [],\n        },\n      },\n      after: {\n        document: {\n          pages: {\n            [page.id]: after,\n          },\n          pageStates: {\n            [page.id]: {\n              selectedIds: this.initialSelectedShapes\n                .filter((shape) => !!this.app.getShape(shape.id))\n                .filter((shape) => !erasedShapeIds.includes(shape.id))\n                .map((shape) => shape.id),\n            },\n          },\n        },\n        appState: {\n          eraseLine: [],\n        },\n      },\n    }\n  }\n}\n", "import { TLBounds, TLPageState, Utils } from '@tldraw/core'\nimport { Vec } from '@tldraw/vec'\nimport type { TldrawApp } from '~state/TldrawApp'\nimport { BaseSession } from '~state/sessions/BaseSession'\nimport {\n  Patch,\n  SessionType,\n  TDShape,\n  TDShapeType,\n  TDStatus,\n  TldrawCommand,\n  TldrawPatch,\n} from '~types'\n\nexport class GridSession extends BaseSession {\n  type = SessionType.Grid\n  performanceMode = undefined\n  status = TDStatus.Translating\n  shape: TDShape\n  bounds: TLBounds\n  initialSelectedIds: string[]\n  initialSiblings?: string[]\n  grid: Record<string, string> = {}\n  columns = 1\n  rows = 1\n  isCopying = false\n\n  constructor(app: TldrawApp, id: string) {\n    super(app)\n    this.shape = this.app.getShape(id)\n    this.grid['0_0'] = this.shape.id\n    this.bounds = this.app.getShapeBounds(id)\n    this.initialSelectedIds = [...this.app.selectedIds]\n    if (this.shape.parentId !== this.app.currentPageId) {\n      this.initialSiblings = this.app\n        .getShape(this.shape.parentId)\n        .children?.filter((id) => id !== this.shape.id)\n    }\n  }\n\n  start = (): TldrawPatch | undefined => void null\n\n  update = (): TldrawPatch | undefined => {\n    const { currentPageId, altKey, shiftKey, currentPoint } = this.app\n\n    const nextShapes: Patch<Record<string, TDShape>> = {}\n\n    const nextPageState: Patch<TLPageState> = {}\n\n    const center = Utils.getBoundsCenter(this.bounds)\n\n    const offset = Vec.sub(currentPoint, center)\n\n    if (shiftKey) {\n      if (Math.abs(offset[0]) < Math.abs(offset[1])) {\n        offset[0] = 0\n      } else {\n        offset[1] = 0\n      }\n    }\n    // use the distance from center to determine the grid\n\n    const gapX = this.bounds.width + 32\n    const gapY = this.bounds.height + 32\n\n    const columns = Math.ceil(offset[0] / gapX)\n    const rows = Math.ceil(offset[1] / gapY)\n\n    const minX = Math.min(columns, 0)\n    const minY = Math.min(rows, 0)\n    const maxX = Math.max(columns, 1)\n    const maxY = Math.max(rows, 1)\n\n    const inGrid = new Set<string>()\n\n    const isCopying = altKey\n\n    if (isCopying !== this.isCopying) {\n      // Recreate shapes copying\n      Object.values(this.grid)\n        .filter((id) => id !== this.shape.id)\n        .forEach((id) => (nextShapes[id] = undefined))\n\n      this.grid = { '0_0': this.shape.id }\n\n      this.isCopying = isCopying\n    }\n\n    // Go through grid, adding items in positions\n    // that aren't already filled.\n    for (let x = minX; x < maxX; x++) {\n      for (let y = minY; y < maxY; y++) {\n        const position = `${x}_${y}`\n\n        inGrid.add(position)\n\n        if (this.grid[position]) continue\n\n        if (x === 0 && y === 0) continue\n\n        const clone = this.getClone(Vec.add(this.shape.point, [x * gapX, y * gapY]), isCopying)\n\n        nextShapes[clone.id] = clone\n\n        this.grid[position] = clone.id\n      }\n    }\n\n    // Remove any other items from the grid\n    Object.entries(this.grid).forEach(([position, id]) => {\n      if (!inGrid.has(position)) {\n        nextShapes[id] = undefined\n        delete this.grid[position]\n      }\n    })\n\n    if (Object.values(nextShapes).length === 0) return\n\n    // Add shapes to parent id\n    if (this.initialSiblings) {\n      nextShapes[this.shape.parentId] = {\n        children: [...this.initialSiblings, ...Object.values(this.grid)],\n      }\n    }\n\n    return {\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes: nextShapes,\n          },\n        },\n        pageStates: {\n          [currentPageId]: nextPageState,\n        },\n      },\n    }\n  }\n\n  cancel = (): TldrawPatch | undefined => {\n    const { currentPageId } = this.app\n    const nextShapes: Record<string, Partial<TDShape> | undefined> = {}\n\n    // Delete clones\n    Object.values(this.grid).forEach((id) => {\n      nextShapes[id] = undefined\n      // TODO: Remove from parent if grouped\n    })\n\n    // Put back the initial shape\n    nextShapes[this.shape.id] = { ...nextShapes[this.shape.id], point: this.shape.point }\n\n    if (this.initialSiblings) {\n      nextShapes[this.shape.parentId] = {\n        children: [...this.initialSiblings, this.shape.id],\n      }\n    }\n\n    return {\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes: nextShapes,\n          },\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: [this.shape.id],\n          },\n        },\n      },\n    }\n  }\n\n  complete = (): TldrawPatch | TldrawCommand | undefined => {\n    const { currentPageId } = this.app\n\n    const beforeShapes: Patch<Record<string, TDShape>> = {}\n\n    const afterShapes: Patch<Record<string, TDShape>> = {}\n\n    const afterSelectedIds: string[] = []\n\n    Object.values(this.grid).forEach((id) => {\n      beforeShapes[id] = undefined\n      afterShapes[id] = this.app.getShape(id)\n      afterSelectedIds.push(id)\n      // TODO: Add shape to parent if grouped\n    })\n\n    beforeShapes[this.shape.id] = this.shape\n\n    // Add shapes to parent id\n    if (this.initialSiblings) {\n      beforeShapes[this.shape.parentId] = {\n        children: [...this.initialSiblings, this.shape.id],\n      }\n\n      afterShapes[this.shape.parentId] = {\n        children: [...this.initialSiblings, ...Object.values(this.grid)],\n      }\n    }\n\n    // If no new shapes have been created, bail\n    if (afterSelectedIds.length === 1) return\n\n    return {\n      id: 'grid',\n      before: {\n        document: {\n          pages: {\n            [currentPageId]: {\n              shapes: beforeShapes,\n            },\n          },\n          pageStates: {\n            [currentPageId]: {\n              selectedIds: [],\n              hoveredId: undefined,\n            },\n          },\n        },\n      },\n      after: {\n        document: {\n          pages: {\n            [currentPageId]: {\n              shapes: afterShapes,\n            },\n          },\n          pageStates: {\n            [currentPageId]: {\n              selectedIds: afterSelectedIds,\n              hoveredId: undefined,\n            },\n          },\n        },\n      },\n    }\n  }\n\n  private getClone = (point: number[], copy: boolean) => {\n    const clone = {\n      ...this.shape,\n      id: Utils.uniqueId(),\n      point,\n    }\n\n    if (!copy) {\n      if (clone.type === TDShapeType.Sticky) {\n        clone.text = ''\n      }\n    }\n\n    return clone\n  }\n}\n", "import { Vec } from '@tldraw/vec'\nimport { TLDR } from '~state/TLDR'\nimport type { TldrawApp } from '~state/TldrawApp'\nimport { BaseSession } from '~state/sessions/BaseSession'\nimport { SessionType, ShapesWithProp, TDStatus, TldrawCommand, TldrawPatch } from '~types'\n\nexport class HandleSession extends BaseSession {\n  type = SessionType.Handle\n  performanceMode = undefined\n  status = TDStatus.TranslatingHandle\n  commandId: string\n  topLeft: number[]\n  shiftKey = false\n  initialShape: ShapesWithProp<'handles'>\n  handleId: string\n\n  constructor(app: TldrawApp, shapeId: string, handleId: string, commandId = 'move_handle') {\n    super(app)\n    const { originPoint } = app\n    this.topLeft = [...originPoint]\n    this.handleId = handleId\n    this.initialShape = this.app.getShape(shapeId)\n    this.commandId = commandId\n  }\n\n  start = (): TldrawPatch | undefined => void null\n\n  update = (): TldrawPatch | undefined => {\n    const {\n      initialShape,\n      app: { currentPageId, currentPoint },\n    } = this\n\n    const shape = this.app.getShape<ShapesWithProp<'handles'>>(initialShape.id)\n\n    if (shape.isLocked) return void null\n\n    const handles = shape.handles\n\n    const handleId = this.handleId as keyof typeof handles\n\n    const delta = Vec.sub(currentPoint, handles[handleId].point)\n\n    const handleChanges = {\n      [handleId]: {\n        ...handles[handleId],\n        point: Vec.sub(Vec.add(handles[handleId].point, delta), shape.point),\n      },\n    }\n\n    // First update the handle's next point\n    const change = TLDR.getShapeUtil(shape).onHandleChange?.(shape, handleChanges)\n\n    if (!change) return\n\n    return {\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes: {\n              [shape.id]: change,\n            },\n          },\n        },\n      },\n    }\n  }\n\n  cancel = (): TldrawPatch | undefined => {\n    const {\n      initialShape,\n      app: { currentPageId },\n    } = this\n\n    return {\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes: {\n              [initialShape.id]: initialShape,\n            },\n          },\n        },\n      },\n    }\n  }\n\n  complete = (): TldrawPatch | TldrawCommand | undefined => {\n    const {\n      initialShape,\n      app: { currentPageId },\n    } = this\n\n    return {\n      id: this.commandId,\n      before: {\n        document: {\n          pages: {\n            [currentPageId]: {\n              shapes: {\n                [initialShape.id]: initialShape,\n              },\n            },\n          },\n        },\n      },\n      after: {\n        document: {\n          pages: {\n            [currentPageId]: {\n              shapes: {\n                [initialShape.id]: TLDR.onSessionComplete(this.app.getShape(this.initialShape.id)),\n              },\n            },\n          },\n        },\n      },\n    }\n  }\n}\n", "import { Utils } from '@tldraw/core'\nimport { Vec } from '@tldraw/vec'\nimport { TLDR } from '~state/TLDR'\nimport type { TldrawApp } from '~state/TldrawApp'\nimport { BaseSession } from '~state/sessions/BaseSession'\nimport { SessionType, TDShape, TDStatus, TldrawCommand, TldrawPatch } from '~types'\n\nexport class RotateSession extends BaseSession {\n  type = SessionType.Rotate\n  status = TDStatus.Transforming\n  performanceMode = undefined\n  delta = [0, 0]\n  commonBoundsCenter: number[]\n  initialAngle: number\n  initialShapes: {\n    shape: TDShape\n    center: number[]\n  }[]\n  changes: Record<string, Partial<TDShape>> = {}\n\n  constructor(app: TldrawApp) {\n    super(app)\n\n    const {\n      app: { currentPageId, pageState, originPoint },\n    } = this\n\n    const initialShapes = TLDR.getSelectedBranchSnapshot(app.state, currentPageId).filter(\n      (shape) => !shape.isLocked\n    )\n\n    if (initialShapes.length === 0) {\n      throw Error('No selected shapes!')\n    }\n\n    if (app.rotationInfo.selectedIds === pageState.selectedIds) {\n      if (app.rotationInfo.center === undefined) {\n        throw Error('We should have a center for rotation!')\n      }\n\n      this.commonBoundsCenter = app.rotationInfo.center\n    } else {\n      this.commonBoundsCenter = Utils.getBoundsCenter(\n        Utils.getCommonBounds(initialShapes.map(TLDR.getBounds))\n      )\n      app.rotationInfo.selectedIds = pageState.selectedIds\n      app.rotationInfo.center = this.commonBoundsCenter\n    }\n\n    this.initialShapes = initialShapes\n      .filter((shape) => shape.children === undefined)\n      .map((shape) => {\n        return {\n          shape,\n          center: this.app.getShapeUtil(shape).getCenter(shape),\n        }\n      })\n\n    this.initialAngle = Vec.angle(this.commonBoundsCenter, originPoint)\n  }\n\n  start = (): TldrawPatch | undefined => void null\n\n  update = (): TldrawPatch | undefined => {\n    const {\n      commonBoundsCenter,\n      initialShapes,\n      app: { currentPageId, currentPoint, shiftKey },\n    } = this\n\n    const shapes: Record<string, Partial<TDShape>> = {}\n\n    let directionDelta = Vec.angle(commonBoundsCenter, currentPoint) - this.initialAngle\n\n    if (shiftKey) {\n      directionDelta = Utils.snapAngleToSegments(directionDelta, 24) // 15 degrees\n    }\n\n    // Update the shapes\n    initialShapes.forEach(({ center, shape }) => {\n      const { rotation = 0 } = shape\n      let shapeDelta = 0\n\n      if (shiftKey) {\n        const snappedRotation = Utils.snapAngleToSegments(rotation, 24)\n        shapeDelta = snappedRotation - rotation\n      }\n\n      const change = TLDR.getRotatedShapeMutation(\n        shape,\n        center,\n        commonBoundsCenter,\n        shiftKey ? directionDelta + shapeDelta : directionDelta\n      )\n\n      if (change) {\n        shapes[shape.id] = change\n      }\n    })\n\n    this.changes = shapes\n\n    return {\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes,\n          },\n        },\n      },\n    }\n  }\n\n  cancel = (): TldrawPatch | undefined => {\n    const {\n      initialShapes,\n      app: { currentPageId },\n    } = this\n\n    const shapes: Record<string, TDShape> = {}\n    initialShapes.forEach(({ shape }) => (shapes[shape.id] = shape))\n\n    return {\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes,\n          },\n        },\n      },\n    }\n  }\n\n  complete = (): TldrawPatch | TldrawCommand | undefined => {\n    const {\n      initialShapes,\n      app: { currentPageId },\n    } = this\n\n    const beforeShapes = {} as Record<string, Partial<TDShape>>\n    const afterShapes = this.changes\n\n    initialShapes.forEach(({ shape: { id, point, rotation, handles } }) => {\n      beforeShapes[id] = { point, rotation, handles }\n    })\n\n    return {\n      id: 'rotate',\n      before: {\n        document: {\n          pages: {\n            [currentPageId]: {\n              shapes: beforeShapes,\n            },\n          },\n        },\n      },\n      after: {\n        document: {\n          pages: {\n            [currentPageId]: {\n              shapes: afterShapes,\n            },\n          },\n        },\n      },\n    }\n  }\n}\n", "import { TLBounds, TLBoundsCorner, TLBoundsEdge, Utils } from '@tldraw/core'\nimport type { TLBoundsWithCenter, TLSnapLine } from '@tldraw/core'\nimport { Vec } from '@tldraw/vec'\nimport { SLOW_SPEED, SNAP_DISTANCE } from '~constants'\nimport { TLDR } from '~state/TLDR'\nimport type { TldrawApp } from '~state/TldrawApp'\nimport { BaseSession } from '~state/sessions/BaseSession'\nimport { SessionType, TDShape, TDStatus, TldrawCommand, TldrawPatch } from '~types'\n\ntype SnapInfo =\n  | {\n      state: 'empty'\n    }\n  | {\n      state: 'ready'\n      bounds: TLBoundsWithCenter[]\n    }\n\nexport class TransformSession extends BaseSession {\n  type = SessionType.Transform\n  performanceMode = undefined\n  status = TDStatus.Transforming\n  scaleX = 1\n  scaleY = 1\n  initialShapes: TDShape[]\n  initialShapeIds: string[]\n  initialSelectedIds: string[]\n  shapeBounds: {\n    initialShape: TDShape\n    initialShapeBounds: TLBounds\n    transformOrigin: number[]\n  }[]\n  hasUnlockedShapes: boolean\n  isAllAspectRatioLocked: boolean\n  initialCommonBounds: TLBounds\n  snapInfo: SnapInfo = { state: 'empty' }\n  prevPoint = [0, 0]\n  speed = 1\n\n  constructor(\n    app: TldrawApp,\n    public transformType: TLBoundsEdge | TLBoundsCorner = TLBoundsCorner.BottomRight,\n    public isCreate = false\n  ) {\n    super(app)\n    this.initialSelectedIds = [...this.app.selectedIds]\n    this.app.rotationInfo.selectedIds = [...this.initialSelectedIds]\n\n    this.initialShapes = TLDR.getSelectedBranchSnapshot(\n      this.app.state,\n      this.app.currentPageId\n    ).filter((shape) => !shape.isLocked)\n\n    this.initialShapeIds = this.initialShapes.map((shape) => shape.id)\n\n    this.hasUnlockedShapes = this.initialShapes.length > 0\n\n    this.isAllAspectRatioLocked = this.initialShapes.every(\n      (shape) => shape.isAspectRatioLocked || TLDR.getShapeUtil(shape).isAspectRatioLocked\n    )\n\n    const shapesBounds = Object.fromEntries(\n      this.initialShapes.map((shape) => [shape.id, TLDR.getBounds(shape)])\n    )\n\n    const boundsArr = Object.values(shapesBounds)\n\n    this.initialCommonBounds = Utils.getCommonBounds(boundsArr)\n\n    const initialInnerBounds = Utils.getBoundsFromPoints(boundsArr.map(Utils.getBoundsCenter))\n\n    // Return a mapping of shapes to bounds together with the relative\n    // positions of the shape's bounds within the common bounds shape.\n    this.shapeBounds = this.initialShapes.map((shape) => {\n      const initialShapeBounds = shapesBounds[shape.id]\n      const ic = Utils.getBoundsCenter(initialShapeBounds)\n\n      const ix = (ic[0] - initialInnerBounds.minX) / initialInnerBounds.width\n      const iy = (ic[1] - initialInnerBounds.minY) / initialInnerBounds.height\n\n      return {\n        initialShape: shape,\n        initialShapeBounds,\n        transformOrigin: [ix, iy],\n      }\n    })\n  }\n\n  start = (): TldrawPatch | undefined => {\n    this.snapInfo = {\n      state: 'ready',\n      bounds: this.app.shapes\n        .filter((shape) => !this.initialShapeIds.includes(shape.id))\n        .map((shape) => Utils.getBoundsWithCenter(TLDR.getRotatedBounds(shape))),\n    }\n\n    return void null\n  }\n\n  update = (): TldrawPatch | undefined => {\n    const {\n      transformType,\n      shapeBounds,\n      initialCommonBounds,\n      isAllAspectRatioLocked,\n      app: {\n        currentPageId,\n        pageState: { camera },\n        viewport,\n        currentPoint,\n        previousPoint,\n        originPoint,\n        shiftKey,\n        altKey,\n        metaKey,\n        currentGrid,\n        settings: { isSnapping, showGrid },\n      },\n    } = this\n\n    const shapes = {} as Record<string, TDShape>\n\n    const delta = altKey\n      ? Vec.mul(Vec.sub(currentPoint, originPoint), 2)\n      : Vec.sub(currentPoint, originPoint)\n\n    let newBounds = Utils.getTransformedBoundingBox(\n      initialCommonBounds,\n      transformType,\n      delta,\n      0,\n      shiftKey || isAllAspectRatioLocked\n    )\n\n    if (altKey) {\n      newBounds = {\n        ...newBounds,\n        ...Utils.centerBounds(newBounds, Utils.getBoundsCenter(initialCommonBounds)),\n      }\n    }\n\n    if (showGrid) {\n      newBounds = {\n        ...newBounds,\n        ...Utils.snapBoundsToGrid(newBounds, currentGrid),\n      }\n    }\n\n    // Should we snap?\n\n    const speed = Vec.dist(currentPoint, previousPoint)\n\n    const speedChange = speed - this.speed\n\n    this.speed = this.speed + speedChange * (speedChange > 1 ? 0.5 : 0.15)\n\n    let snapLines: TLSnapLine[] = []\n\n    if (\n      ((isSnapping && !metaKey) || (!isSnapping && metaKey)) &&\n      this.speed * camera.zoom < SLOW_SPEED &&\n      this.snapInfo.state === 'ready'\n    ) {\n      const snapResult = Utils.getSnapPoints(\n        Utils.getBoundsWithCenter(newBounds),\n        this.snapInfo.bounds.filter(\n          (bounds) => Utils.boundsContain(viewport, bounds) || Utils.boundsCollide(viewport, bounds)\n        ),\n        SNAP_DISTANCE / camera.zoom\n      )\n\n      if (snapResult) {\n        snapLines = snapResult.snapLines\n\n        newBounds = Utils.getTransformedBoundingBox(\n          initialCommonBounds,\n          transformType,\n          Vec.sub(delta, snapResult.offset),\n          0,\n          shiftKey || isAllAspectRatioLocked\n        )\n      }\n    }\n\n    // Now work backward to calculate a new bounding box for each of the shapes.\n\n    this.scaleX = newBounds.scaleX\n    this.scaleY = newBounds.scaleY\n\n    shapeBounds.forEach(({ initialShape, initialShapeBounds, transformOrigin }) => {\n      let newShapeBounds = Utils.getRelativeTransformedBoundingBox(\n        newBounds,\n        initialCommonBounds,\n        initialShapeBounds,\n        this.scaleX < 0,\n        this.scaleY < 0\n      )\n\n      if (showGrid) {\n        newShapeBounds = Utils.snapBoundsToGrid(newShapeBounds, currentGrid)\n      }\n\n      const afterShape = TLDR.transform(this.app.getShape(initialShape.id), newShapeBounds, {\n        type: this.transformType,\n        initialShape,\n        scaleX: this.scaleX,\n        scaleY: this.scaleY,\n        transformOrigin,\n      })\n\n      shapes[initialShape.id] = afterShape\n    })\n\n    return {\n      appState: {\n        snapLines,\n      },\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes,\n          },\n        },\n      },\n    }\n  }\n\n  cancel = (): TldrawPatch | undefined => {\n    const {\n      shapeBounds,\n      app: { currentPageId },\n    } = this\n\n    const shapes = {} as Record<string, TDShape | undefined>\n\n    if (this.isCreate) {\n      shapeBounds.forEach((shape) => (shapes[shape.initialShape.id] = undefined))\n    } else {\n      shapeBounds.forEach((shape) => (shapes[shape.initialShape.id] = shape.initialShape))\n    }\n\n    return {\n      appState: {\n        snapLines: [],\n      },\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes,\n          },\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: this.isCreate ? [] : shapeBounds.map((shape) => shape.initialShape.id),\n          },\n        },\n      },\n    }\n  }\n\n  complete = (): TldrawPatch | TldrawCommand | undefined => {\n    const {\n      isCreate,\n      shapeBounds,\n      hasUnlockedShapes,\n      app: { currentPageId },\n    } = this\n\n    if (!hasUnlockedShapes) return\n\n    if (this.isCreate && Vec.dist(this.app.originPoint, this.app.currentPoint) < 2) {\n      return this.cancel()\n    }\n\n    const beforeShapes: Record<string, TDShape | undefined> = {}\n    const afterShapes: Record<string, TDShape> = {}\n\n    let beforeSelectedIds: string[]\n    let afterSelectedIds: string[]\n\n    if (isCreate) {\n      beforeSelectedIds = []\n      afterSelectedIds = []\n      shapeBounds.forEach(({ initialShape }) => {\n        beforeShapes[initialShape.id] = undefined\n        afterShapes[initialShape.id] = this.app.getShape(initialShape.id)\n      })\n    } else {\n      beforeSelectedIds = this.initialSelectedIds\n      afterSelectedIds = this.initialSelectedIds\n      shapeBounds.forEach(({ initialShape }) => {\n        beforeShapes[initialShape.id] = initialShape\n        afterShapes[initialShape.id] = this.app.getShape(initialShape.id)\n      })\n    }\n\n    return {\n      id: 'transform',\n      before: {\n        appState: {\n          snapLines: [],\n        },\n        document: {\n          pages: {\n            [currentPageId]: {\n              shapes: beforeShapes,\n            },\n          },\n          pageStates: {\n            [currentPageId]: {\n              selectedIds: beforeSelectedIds,\n              hoveredId: undefined,\n              editingId: undefined,\n            },\n          },\n        },\n      },\n      after: {\n        appState: {\n          snapLines: [],\n        },\n        document: {\n          pages: {\n            [currentPageId]: {\n              shapes: afterShapes,\n            },\n          },\n          pageStates: {\n            [currentPageId]: {\n              selectedIds: afterSelectedIds,\n              hoveredId: undefined,\n              editingId: undefined,\n            },\n          },\n        },\n      },\n    }\n  }\n}\n", "import {\n  TLBounds,\n  TLBoundsCorner,\n  TLBoundsEdge,\n  TLBoundsWithCenter,\n  TLSnapLine,\n  Utils,\n} from '@tldraw/core'\nimport { Vec } from '@tldraw/vec'\nimport { SLOW_SPEED, SNAP_DISTANCE } from '~constants'\nimport { TLDR } from '~state/TLDR'\nimport type { TldrawApp } from '~state/TldrawApp'\nimport { BaseSession } from '~state/sessions/BaseSession'\nimport { SessionType, TDShape, TDStatus, TldrawCommand, TldrawPatch } from '~types'\n\ntype SnapInfo =\n  | {\n      state: 'empty'\n    }\n  | {\n      state: 'ready'\n      bounds: TLBoundsWithCenter[]\n    }\n\nexport class TransformSingleSession extends BaseSession {\n  type = SessionType.TransformSingle\n  status = TDStatus.Transforming\n  performanceMode = undefined\n  transformType: TLBoundsEdge | TLBoundsCorner\n  scaleX = 1\n  scaleY = 1\n  isCreate: boolean\n  initialShape: TDShape\n  initialShapeBounds: TLBounds\n  initialCommonBounds: TLBounds\n  snapInfo: SnapInfo = { state: 'empty' }\n  prevPoint = [0, 0]\n  speed = 1\n\n  constructor(\n    app: TldrawApp,\n    id: string,\n    transformType: TLBoundsEdge | TLBoundsCorner,\n    isCreate = false\n  ) {\n    super(app)\n    this.isCreate = isCreate\n    this.transformType = transformType\n\n    const shape = this.app.getShape(id)\n    this.initialShape = shape\n    this.initialShapeBounds = TLDR.getBounds(shape)\n    this.initialCommonBounds = TLDR.getRotatedBounds(shape)\n    this.app.rotationInfo.selectedIds = [shape.id]\n  }\n\n  start = (): TldrawPatch | undefined => {\n    this.snapInfo = {\n      state: 'ready',\n      bounds: this.app.shapes\n        .filter((shape) => shape.id !== this.initialShape.id)\n        .map((shape) => Utils.getBoundsWithCenter(TLDR.getRotatedBounds(shape))),\n    }\n\n    return void null\n  }\n\n  update = (): TldrawPatch | undefined => {\n    const {\n      transformType,\n      initialShape,\n      initialShapeBounds,\n      app: {\n        settings: { isSnapping, showGrid },\n        currentPageId,\n        pageState: { camera },\n        viewport,\n        currentPoint,\n        previousPoint,\n        originPoint,\n        currentGrid,\n        shiftKey,\n        altKey,\n        metaKey,\n      },\n    } = this\n\n    if (initialShape.isLocked) return void null\n\n    const shapes = {} as Record<string, Partial<TDShape>>\n\n    const delta = altKey\n      ? Vec.mul(Vec.sub(currentPoint, originPoint), 2)\n      : Vec.sub(currentPoint, originPoint)\n\n    const shape = this.app.getShape(initialShape.id)\n\n    const utils = TLDR.getShapeUtil(shape)\n\n    let newBounds = Utils.getTransformedBoundingBox(\n      initialShapeBounds,\n      transformType,\n      delta,\n      shape.rotation,\n      shiftKey || shape.isAspectRatioLocked || utils.isAspectRatioLocked\n    )\n\n    if (altKey) {\n      newBounds = {\n        ...newBounds,\n        ...Utils.centerBounds(newBounds, Utils.getBoundsCenter(initialShapeBounds)),\n      }\n    }\n\n    if (showGrid) {\n      newBounds = {\n        ...newBounds,\n        ...Utils.snapBoundsToGrid(newBounds, currentGrid),\n      }\n    }\n\n    // Should we snap?\n\n    const speed = Vec.dist(currentPoint, previousPoint)\n\n    const speedChange = speed - this.speed\n\n    this.speed = this.speed + speedChange * (speedChange > 1 ? 0.5 : 0.15)\n\n    let snapLines: TLSnapLine[] = []\n\n    if (\n      ((isSnapping && !metaKey) || (!isSnapping && metaKey)) &&\n      !initialShape.rotation && // not now anyway\n      this.speed * camera.zoom < SLOW_SPEED &&\n      this.snapInfo.state === 'ready'\n    ) {\n      const snapResult = Utils.getSnapPoints(\n        Utils.getBoundsWithCenter(newBounds),\n        this.snapInfo.bounds.filter(\n          (bounds) => Utils.boundsContain(viewport, bounds) || Utils.boundsCollide(viewport, bounds)\n        ),\n        SNAP_DISTANCE / camera.zoom\n      )\n\n      if (snapResult) {\n        snapLines = snapResult.snapLines\n\n        newBounds = Utils.getTransformedBoundingBox(\n          initialShapeBounds,\n          transformType,\n          Vec.sub(delta, snapResult.offset),\n          shape.rotation,\n          shiftKey || shape.isAspectRatioLocked || utils.isAspectRatioLocked\n        )\n      }\n    }\n\n    const afterShape = TLDR.getShapeUtil(shape).transformSingle(shape, newBounds, {\n      initialShape,\n      type: this.transformType,\n      scaleX: newBounds.scaleX,\n      scaleY: newBounds.scaleY,\n      transformOrigin: [0.5, 0.5],\n    })\n\n    if (afterShape) {\n      shapes[shape.id] = afterShape\n    }\n\n    if (showGrid && afterShape && afterShape.point) {\n      afterShape.point = Vec.snap(afterShape.point, currentGrid)\n    }\n\n    return {\n      appState: {\n        snapLines,\n      },\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes,\n          },\n        },\n      },\n    }\n  }\n\n  cancel = (): TldrawPatch | undefined => {\n    const {\n      initialShape,\n      app: { currentPageId },\n    } = this\n\n    const shapes = {} as Record<string, TDShape | undefined>\n\n    if (this.isCreate) {\n      shapes[initialShape.id] = undefined\n    } else {\n      shapes[initialShape.id] = initialShape\n    }\n\n    return {\n      appState: {\n        snapLines: [],\n      },\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes,\n          },\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: this.isCreate ? [] : [initialShape.id],\n          },\n        },\n      },\n    }\n  }\n\n  complete = (): TldrawPatch | TldrawCommand | undefined => {\n    const {\n      initialShape,\n      app: { currentPageId },\n    } = this\n\n    if (initialShape.isLocked) return\n\n    if (this.isCreate && Vec.dist(this.app.originPoint, this.app.currentPoint) < 2) {\n      return this.cancel()\n    }\n\n    const beforeShapes = {} as Record<string, Partial<TDShape> | undefined>\n    const afterShapes = {} as Record<string, Partial<TDShape>>\n\n    beforeShapes[initialShape.id] = this.isCreate ? undefined : initialShape\n\n    afterShapes[initialShape.id] = TLDR.onSessionComplete(this.app.getShape(initialShape.id))\n\n    return {\n      id: 'transform_single',\n      before: {\n        appState: {\n          snapLines: [],\n        },\n        document: {\n          pages: {\n            [currentPageId]: {\n              shapes: beforeShapes,\n            },\n          },\n          pageStates: {\n            [currentPageId]: {\n              selectedIds: this.isCreate ? [] : [initialShape.id],\n              editingId: undefined,\n              hoveredId: undefined,\n            },\n          },\n        },\n      },\n      after: {\n        appState: {\n          snapLines: [],\n        },\n        document: {\n          pages: {\n            [currentPageId]: {\n              shapes: afterShapes,\n            },\n          },\n          pageStates: {\n            [currentPageId]: {\n              selectedIds: [initialShape.id],\n              editingId: undefined,\n              hoveredId: undefined,\n            },\n          },\n        },\n      },\n    }\n  }\n}\n", "import { TLBounds, TLBoundsWithCenter, TLPageState, TLSnapLine, Utils } from '@tldraw/core'\nimport { Vec } from '@tldraw/vec'\nimport { SLOW_SPEED, SNAP_DISTANCE } from '~constants'\nimport { TLDR } from '~state/TLDR'\nimport type { TldrawApp } from '~state/TldrawApp'\nimport { BaseSession } from '~state/sessions/BaseSession'\nimport {\n  ArrowBinding,\n  ArrowShape,\n  GroupShape,\n  Patch,\n  SessionType,\n  TDBinding,\n  TDShape,\n  TDShapeType,\n  TDStatus,\n  TldrawCommand,\n  TldrawPatch,\n} from '~types'\n\ntype CloneInfo =\n  | {\n      state: 'empty'\n    }\n  | {\n      state: 'ready'\n      cloneMap: Record<string, string>\n      clones: TDShape[]\n      clonedBindings: ArrowBinding[]\n    }\n\ntype SnapInfo =\n  | {\n      state: 'empty'\n    }\n  | {\n      state: 'ready'\n      others: TLBoundsWithCenter[]\n      bounds: TLBoundsWithCenter[]\n    }\n\nexport class TranslateSession extends BaseSession {\n  performanceMode = undefined\n  type = SessionType.Translate\n  status = TDStatus.Translating\n  delta = [0, 0]\n  prev = [0, 0]\n  prevPoint = [0, 0]\n  speed = 1\n  cloneInfo: CloneInfo = {\n    state: 'empty',\n  }\n  snapInfo: SnapInfo = {\n    state: 'empty',\n  }\n  snapLines: TLSnapLine[] = []\n  isCloning = false\n  isCreate: boolean\n  link: 'left' | 'right' | 'center' | false\n\n  initialIds: Set<string>\n  hasUnlockedShapes: boolean\n  initialSelectedIds: string[]\n  initialCommonBounds: TLBounds\n  initialShapes: TDShape[]\n  initialParentChildren: Record<string, string[]>\n  bindingsToDelete: ArrowBinding[]\n\n  constructor(app: TldrawApp, isCreate = false, link: 'left' | 'right' | 'center' | false = false) {\n    super(app)\n    this.isCreate = isCreate\n    this.link = link\n\n    const { currentPageId, selectedIds, page } = this.app\n\n    this.initialSelectedIds = [...selectedIds]\n\n    const selectedShapes = (\n      link ? TLDR.getLinkedShapeIds(this.app.state, currentPageId, link, false) : selectedIds\n    )\n      .map((id) => this.app.getShape(id))\n      .filter((shape) => !shape.isLocked)\n\n    const selectedShapeIds = new Set(selectedShapes.map((shape) => shape.id))\n\n    this.hasUnlockedShapes = selectedShapes.length > 0\n\n    this.initialShapes = Array.from(\n      new Set(\n        selectedShapes\n          .filter((shape) => !selectedShapeIds.has(shape.parentId))\n          .flatMap((shape) => {\n            return shape.children\n              ? [shape, ...shape.children.map((childId) => this.app.getShape(childId))]\n              : [shape]\n          })\n      ).values()\n    )\n\n    this.initialIds = new Set(this.initialShapes.map((shape) => shape.id))\n\n    this.bindingsToDelete = []\n\n    Object.values(page.bindings)\n      .filter((binding) => this.initialIds.has(binding.fromId) || this.initialIds.has(binding.toId))\n      .forEach((binding) => {\n        if (this.initialIds.has(binding.fromId)) {\n          if (!this.initialIds.has(binding.toId)) {\n            this.bindingsToDelete.push(binding)\n          }\n        }\n      })\n\n    this.initialParentChildren = {}\n\n    this.initialShapes\n      .map((s) => s.parentId)\n      .filter((id) => id !== page.id)\n      .forEach((id) => {\n        this.initialParentChildren[id] = this.app.getShape(id).children!\n      })\n\n    this.initialCommonBounds = Utils.getCommonBounds(this.initialShapes.map(TLDR.getRotatedBounds))\n\n    this.app.rotationInfo.selectedIds = [...this.app.selectedIds]\n  }\n\n  start = (): TldrawPatch | undefined => {\n    const {\n      bindingsToDelete,\n      initialIds,\n      app: { currentPageId, page },\n    } = this\n\n    const allBounds: TLBoundsWithCenter[] = []\n    const otherBounds: TLBoundsWithCenter[] = []\n\n    Object.values(page.shapes).forEach((shape) => {\n      const bounds = Utils.getBoundsWithCenter(TLDR.getRotatedBounds(shape))\n      allBounds.push(bounds)\n      if (!initialIds.has(shape.id)) {\n        otherBounds.push(bounds)\n      }\n    })\n\n    this.snapInfo = {\n      state: 'ready',\n      bounds: allBounds,\n      others: otherBounds,\n    }\n\n    if (bindingsToDelete.length === 0) return\n\n    const nextBindings: Patch<Record<string, TDBinding>> = {}\n    const nextShapes: Patch<Record<string, TDShape>> = {}\n\n    bindingsToDelete.forEach((binding) => {\n      nextBindings[binding.id] = undefined\n      const fromShape = this.app.getShape(binding.fromId)\n      nextShapes[binding.fromId] = {\n        handles: {\n          ...fromShape.handles,\n          [binding.handleId]: {\n            // @ts-expect-error\n            ...fromShape.handles[binding.handleId],\n            bindingId: undefined,\n          },\n        },\n      }\n    })\n\n    return {\n      document: {\n        pages: {\n          [currentPageId]: {\n            bindings: nextBindings,\n            shapes: nextShapes,\n          },\n        },\n      },\n    }\n  }\n\n  update = (): TldrawPatch | undefined => {\n    const {\n      initialParentChildren,\n      initialShapes,\n      initialCommonBounds,\n      bindingsToDelete,\n      app: {\n        pageState: { camera },\n        settings: { isSnapping, showGrid },\n        currentPageId,\n        viewport,\n        selectedIds,\n        currentPoint,\n        previousPoint,\n        originPoint,\n        altKey,\n        shiftKey,\n        metaKey,\n        currentGrid,\n      },\n    } = this\n\n    const nextBindings: Patch<Record<string, TDBinding>> = {}\n    const nextShapes: Patch<Record<string, TDShape>> = {}\n    const nextPageState: Patch<TLPageState> = {}\n\n    let delta = Vec.sub(currentPoint, originPoint)\n\n    let didChangeCloning = false\n\n    if (!this.isCreate) {\n      if (altKey && !this.isCloning) {\n        this.isCloning = true\n        didChangeCloning = true\n      } else if (!altKey && this.isCloning) {\n        this.isCloning = false\n        didChangeCloning = true\n      }\n    }\n\n    if (shiftKey) {\n      if (Math.abs(delta[0]) < Math.abs(delta[1])) {\n        delta[0] = 0\n      } else {\n        delta[1] = 0\n      }\n    }\n\n    // Should we snap?\n\n    // Speed is used to decide which snap points to use. At a high\n    // speed, we don't use any snap points. At a low speed, we only\n    // allow center-to-center snap points. At very low speed, we\n    // enable all snap points (still preferring middle snaps). We're\n    // using an acceleration function here to smooth the changes in\n    // speed, but we also want the speed to accelerate faster than\n    // it decelerates.\n\n    const speed = Vec.dist(currentPoint, previousPoint)\n\n    const change = speed - this.speed\n\n    this.speed = this.speed + change * (change > 1 ? 0.5 : 0.15)\n\n    this.snapLines = []\n\n    if (\n      ((isSnapping && !metaKey) || (!isSnapping && metaKey)) &&\n      this.speed * camera.zoom < SLOW_SPEED &&\n      this.snapInfo.state === 'ready'\n    ) {\n      const snapResult = Utils.getSnapPoints(\n        Utils.getBoundsWithCenter(\n          showGrid\n            ? Utils.snapBoundsToGrid(Utils.translateBounds(initialCommonBounds, delta), currentGrid)\n            : Utils.translateBounds(initialCommonBounds, delta)\n        ),\n        (this.isCloning ? this.snapInfo.bounds : this.snapInfo.others).filter((bounds) => {\n          return Utils.boundsContain(viewport, bounds) || Utils.boundsCollide(viewport, bounds)\n        }),\n        SNAP_DISTANCE / camera.zoom\n      )\n\n      if (snapResult) {\n        this.snapLines = snapResult.snapLines\n        delta = Vec.sub(delta, snapResult.offset)\n      }\n    }\n\n    // We've now calculated the \"delta\", or difference between the\n    // cursor's position (real or adjusted by snaps or axis locking)\n    // and the cursor's original position (\"origin\").\n\n    // The \"movement\" is the actual change of position between this\n    // computed position and the previous computed position.\n\n    this.prev = delta\n\n    // If cloning...\n    if (this.isCloning) {\n      // Not Cloning -> Cloning\n      if (didChangeCloning) {\n        if (this.cloneInfo.state === 'empty') {\n          this.createCloneInfo()\n        }\n\n        if (this.cloneInfo.state === 'empty') {\n          throw Error\n        }\n\n        const { clones, clonedBindings } = this.cloneInfo\n\n        this.isCloning = true\n\n        // Put back any bindings we deleted\n        bindingsToDelete.forEach((binding) => (nextBindings[binding.id] = binding))\n\n        // Move original shapes back to start\n        initialShapes.forEach((shape) => (nextShapes[shape.id] = { point: shape.point }))\n\n        // Add the clones to the page\n        clones.forEach((clone) => {\n          nextShapes[clone.id] = { ...clone }\n\n          // Add clones to non-selected parents\n          if (clone.parentId !== currentPageId && !selectedIds.includes(clone.parentId)) {\n            const children =\n              nextShapes[clone.parentId]?.children || initialParentChildren[clone.parentId]\n\n            if (!children.includes(clone.id)) {\n              nextShapes[clone.parentId] = {\n                ...nextShapes[clone.parentId],\n                children: [...children, clone.id],\n              }\n            }\n          }\n        })\n\n        // Add the cloned bindings\n        for (const binding of clonedBindings) {\n          nextBindings[binding.id] = binding\n        }\n\n        // Set the selected ids to the clones\n        nextPageState.selectedIds = clones.map((clone) => clone.id)\n\n        // Either way, move the clones\n        clones.forEach((clone) => {\n          nextShapes[clone.id] = {\n            ...clone,\n            point: showGrid\n              ? Vec.snap(Vec.toFixed(Vec.add(clone.point, delta)), currentGrid)\n              : Vec.toFixed(Vec.add(clone.point, delta)),\n          }\n        })\n      } else {\n        if (this.cloneInfo.state === 'empty') throw Error\n\n        const { clones } = this.cloneInfo\n\n        clones.forEach((clone) => {\n          nextShapes[clone.id] = {\n            point: showGrid\n              ? Vec.snap(Vec.toFixed(Vec.add(clone.point, delta)), currentGrid)\n              : Vec.toFixed(Vec.add(clone.point, delta)),\n          }\n        })\n      }\n    } else {\n      // If not cloning...\n\n      // Cloning -> Not Cloning\n      if (didChangeCloning) {\n        if (this.cloneInfo.state === 'empty') throw Error\n\n        const { clones, clonedBindings } = this.cloneInfo\n\n        this.isCloning = false\n\n        // Delete the bindings\n        bindingsToDelete.forEach((binding) => (nextBindings[binding.id] = undefined))\n\n        // Remove the clones from parents\n        clones.forEach((clone) => {\n          if (clone.parentId !== currentPageId) {\n            nextShapes[clone.parentId] = {\n              ...nextShapes[clone.parentId],\n              children: initialParentChildren[clone.parentId],\n            }\n          }\n        })\n\n        // Delete the clones (including any parent clones)\n        clones.forEach((clone) => (nextShapes[clone.id] = undefined))\n\n        // Move the original shapes back to the cursor position\n        initialShapes.forEach((shape) => {\n          nextShapes[shape.id] = {\n            point: showGrid\n              ? Vec.snap(Vec.toFixed(Vec.add(shape.point, delta)), currentGrid)\n              : Vec.toFixed(Vec.add(shape.point, delta)),\n          }\n        })\n\n        // Delete the cloned bindings\n        for (const binding of clonedBindings) {\n          nextBindings[binding.id] = undefined\n        }\n\n        // Set selected ids\n        nextPageState.selectedIds = initialShapes.map((shape) => shape.id)\n      } else {\n        // Move the shapes by the delta\n        initialShapes.forEach((shape) => {\n          // const current = (nextShapes[shape.id] || this.app.getShape(shape.id)) as TDShape\n\n          nextShapes[shape.id] = {\n            point: showGrid\n              ? Vec.snap(Vec.toFixed(Vec.add(shape.point, delta)), currentGrid)\n              : Vec.toFixed(Vec.add(shape.point, delta)),\n          }\n        })\n      }\n    }\n\n    return {\n      appState: {\n        snapLines: this.snapLines,\n      },\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes: nextShapes,\n            bindings: nextBindings,\n          },\n        },\n        pageStates: {\n          [currentPageId]: nextPageState,\n        },\n      },\n    }\n  }\n\n  cancel = (): TldrawPatch | undefined => {\n    const {\n      initialShapes,\n      initialSelectedIds,\n      bindingsToDelete,\n      app: { currentPageId },\n    } = this\n\n    const nextBindings: Record<string, Partial<TDBinding> | undefined> = {}\n    const nextShapes: Record<string, Partial<TDShape> | undefined> = {}\n    const nextPageState: Partial<TLPageState> = {\n      editingId: undefined,\n      hoveredId: undefined,\n    }\n\n    if (this.isCreate) {\n      initialShapes.forEach(({ id }) => (nextShapes[id] = undefined))\n      nextPageState.selectedIds = []\n    } else {\n      // Put initial shapes back to where they started\n      initialShapes.forEach(\n        ({ id, point, handles }) =>\n          (nextShapes[id] = handles\n            ? ({ ...nextShapes[id], point, handles } as any)\n            : { ...nextShapes[id], point })\n      )\n      nextPageState.selectedIds = initialSelectedIds\n\n      // Put back any deleted bindings\n      bindingsToDelete.forEach((binding) => {\n        nextBindings[binding.id] = binding\n      })\n    }\n\n    if (this.cloneInfo.state === 'ready') {\n      const { clones, clonedBindings } = this.cloneInfo\n      // Delete clones\n      clones.forEach((clone) => (nextShapes[clone.id] = undefined))\n\n      // Delete cloned bindings\n      clonedBindings.forEach((binding) => (nextBindings[binding.id] = undefined))\n    }\n\n    return {\n      appState: {\n        snapLines: [],\n      },\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes: nextShapes,\n            bindings: nextBindings,\n          },\n        },\n        pageStates: {\n          [currentPageId]: nextPageState,\n        },\n      },\n    }\n  }\n\n  complete = (): TldrawPatch | TldrawCommand | undefined => {\n    const {\n      initialShapes,\n      initialParentChildren,\n      bindingsToDelete,\n      app: { currentPageId },\n    } = this\n\n    const beforeBindings: Patch<Record<string, TDBinding>> = {}\n    const beforeShapes: Patch<Record<string, TDShape>> = {}\n\n    const afterBindings: Patch<Record<string, TDBinding>> = {}\n    const afterShapes: Patch<Record<string, TDShape>> = {}\n\n    if (this.isCloning) {\n      if (this.cloneInfo.state === 'empty') {\n        this.createCloneInfo()\n      }\n\n      if (this.cloneInfo.state !== 'ready') throw Error\n      const { clones, clonedBindings } = this.cloneInfo\n\n      // Update the clones\n      clones.forEach((clone) => {\n        beforeShapes[clone.id] = undefined\n\n        afterShapes[clone.id] = this.app.getShape(clone.id)\n\n        if (clone.parentId !== currentPageId) {\n          beforeShapes[clone.parentId] = {\n            ...beforeShapes[clone.parentId],\n            children: initialParentChildren[clone.parentId],\n          }\n\n          afterShapes[clone.parentId] = {\n            ...afterShapes[clone.parentId],\n            children: this.app.getShape<GroupShape>(clone.parentId).children,\n          }\n        }\n      })\n\n      // Update the cloned bindings\n      clonedBindings.forEach((binding) => {\n        beforeBindings[binding.id] = undefined\n        afterBindings[binding.id] = this.app.getBinding(binding.id)\n      })\n    } else {\n      // If we aren't cloning, then update the initial shapes\n      initialShapes.forEach((shape) => {\n        beforeShapes[shape.id] = this.isCreate\n          ? undefined\n          : {\n              ...beforeShapes[shape.id],\n              point: shape.point,\n            }\n\n        afterShapes[shape.id] = {\n          ...afterShapes[shape.id],\n          ...(this.isCreate\n            ? this.app.getShape(shape.id)\n            : { point: this.app.getShape(shape.id).point }),\n        }\n      })\n    }\n\n    // Update the deleted bindings and any associated shapes\n    bindingsToDelete.forEach((binding) => {\n      beforeBindings[binding.id] = binding\n\n      beforeShapes[binding.fromId] = {\n        ...beforeShapes[binding.fromId],\n        id: binding.fromId,\n        handles: {\n          ...beforeShapes[binding.fromId]?.handles,\n          [binding.handleId]: {\n            ...beforeShapes[binding.fromId]?.handles?.[binding.handleId],\n            bindingId: binding.id,\n          },\n        },\n      }\n\n      afterShapes[binding.fromId] = {\n        ...afterShapes[binding.fromId],\n        id: binding.fromId,\n        handles: {\n          // @ts-expect-error\n          ...afterShapes[binding.fromId].handles!,\n          [binding.handleId]: {\n            ...afterShapes[binding.fromId]?.handles?.[binding.handleId],\n            bindingId: undefined,\n          },\n        },\n      }\n    })\n\n    bindingsToDelete.forEach((binding) => (afterBindings[binding.id] = undefined))\n\n    return {\n      id: 'translate',\n      before: {\n        appState: {\n          snapLines: [],\n        },\n        document: {\n          pages: {\n            [currentPageId]: {\n              shapes: beforeShapes,\n              bindings: beforeBindings,\n            },\n          },\n          pageStates: {\n            [currentPageId]: {\n              selectedIds: this.isCreate ? [] : [...this.initialSelectedIds],\n            },\n          },\n        },\n      },\n      after: {\n        appState: {\n          snapLines: [],\n        },\n        document: {\n          pages: {\n            [currentPageId]: {\n              shapes: afterShapes,\n              bindings: afterBindings,\n            },\n          },\n          pageStates: {\n            [currentPageId]: {\n              selectedIds: [...this.app.selectedIds],\n            },\n          },\n        },\n      },\n    }\n  }\n\n  private createCloneInfo = () => {\n    // Create clones when as they're needed.\n    // Consider doing this work in a worker.\n\n    const {\n      initialShapes,\n      initialParentChildren,\n      app: { selectedIds, currentPageId, page },\n    } = this\n\n    const cloneMap: Record<string, string> = {}\n    const clonedBindingsMap: Record<string, string> = {}\n    const clonedBindings: TDBinding[] = []\n\n    // Create clones of selected shapes\n    const clones: TDShape[] = []\n\n    initialShapes.forEach((shape) => {\n      const newId = Utils.uniqueId()\n\n      initialParentChildren[newId] = initialParentChildren[shape.id]\n\n      cloneMap[shape.id] = newId\n\n      const clone = {\n        ...Utils.deepClone(shape),\n        id: newId,\n        parentId: shape.parentId,\n        childIndex: TLDR.getChildIndexAbove(this.app.state, shape.id, currentPageId),\n      }\n\n      if (clone.type === TDShapeType.Video) {\n        const element = document.getElementById(shape.id + '_video') as HTMLVideoElement\n        if (element) clone.currentTime = (element.currentTime + 16) % element.duration\n      }\n\n      clones.push(clone)\n    })\n\n    clones.forEach((clone) => {\n      if (clone.children !== undefined) {\n        clone.children = clone.children.map((childId) => cloneMap[childId])\n      }\n    })\n\n    clones.forEach((clone) => {\n      if (selectedIds.includes(clone.parentId)) {\n        clone.parentId = cloneMap[clone.parentId]\n      }\n    })\n\n    // Potentially confusing name here: these are the ids of the\n    // original shapes that were cloned, not their clones' ids.\n    const clonedShapeIds = new Set(Object.keys(cloneMap))\n\n    // Create cloned bindings for shapes where both to and from shapes are selected\n    // (if the user clones, then we will create a new binding for the clones)\n    Object.values(page.bindings)\n      .filter((binding) => clonedShapeIds.has(binding.fromId) || clonedShapeIds.has(binding.toId))\n      .forEach((binding) => {\n        if (clonedShapeIds.has(binding.fromId)) {\n          if (clonedShapeIds.has(binding.toId)) {\n            const cloneId = Utils.uniqueId()\n\n            const cloneBinding = {\n              ...Utils.deepClone(binding),\n              id: cloneId,\n              fromId: cloneMap[binding.fromId] || binding.fromId,\n              toId: cloneMap[binding.toId] || binding.toId,\n            }\n            clonedBindingsMap[binding.id] = cloneId\n            clonedBindings.push(cloneBinding)\n          }\n        }\n      })\n\n    // Assign new binding ids to clones (or delete them!)\n    clones.forEach((clone) => {\n      if (clone.handles) {\n        if (clone.handles) {\n          for (const id in clone.handles) {\n            const handle = clone.handles[id as keyof ArrowShape['handles']]\n            handle.bindingId = handle.bindingId ? clonedBindingsMap[handle.bindingId] : undefined\n          }\n        }\n      }\n    })\n\n    clones.forEach((clone) => {\n      if (page.shapes[clone.id]) {\n        throw Error(\"uh oh, we didn't clone correctly\")\n      }\n    })\n\n    this.cloneInfo = {\n      state: 'ready',\n      clones,\n      cloneMap,\n      clonedBindings,\n    }\n  }\n}\n", "import { ExceptFirst, SessionType } from '~types'\nimport { ArrowSession } from './ArrowSession'\nimport { BrushSession } from './BrushSession'\nimport { DrawSession } from './DrawSession'\nimport { EditSession } from './EditSession'\nimport { EraseSession } from './EraseSession'\nimport { GridSession } from './GridSession'\nimport { HandleSession } from './HandleSession'\nimport { RotateSession } from './RotateSession'\nimport { TransformSession } from './TransformSession'\nimport { TransformSingleSession } from './TransformSingleSession'\nimport { TranslateSession } from './TranslateSession'\n\nexport type TldrawSession =\n  | ArrowSession\n  | BrushSession\n  | DrawSession\n  | HandleSession\n  | RotateSession\n  | TransformSession\n  | TransformSingleSession\n  | TranslateSession\n  | EraseSession\n  | GridSession\n  | EditSession\n\nexport interface SessionsMap {\n  [SessionType.Arrow]: typeof ArrowSession\n  [SessionType.Brush]: typeof BrushSession\n  [SessionType.Draw]: typeof DrawSession\n  [SessionType.Erase]: typeof EraseSession\n  [SessionType.Handle]: typeof HandleSession\n  [SessionType.Rotate]: typeof RotateSession\n  [SessionType.Transform]: typeof TransformSession\n  [SessionType.TransformSingle]: typeof TransformSingleSession\n  [SessionType.Translate]: typeof TranslateSession\n  [SessionType.Grid]: typeof GridSession\n  [SessionType.Edit]: typeof EditSession\n}\n\nexport type SessionOfType<K extends SessionType> = SessionsMap[K]\n\nexport type SessionArgsOfType<K extends SessionType> = ExceptFirst<\n  ConstructorParameters<SessionOfType<K>>\n>\n\nexport const sessions: { [K in SessionType]: SessionsMap[K] } = {\n  [SessionType.Arrow]: ArrowSession,\n  [SessionType.Brush]: BrushSession,\n  [SessionType.Draw]: DrawSession,\n  [SessionType.Erase]: EraseSession,\n  [SessionType.Handle]: HandleSession,\n  [SessionType.Rotate]: RotateSession,\n  [SessionType.Transform]: TransformSession,\n  [SessionType.TransformSingle]: TransformSingleSession,\n  [SessionType.Translate]: TranslateSession,\n  [SessionType.Grid]: GridSession,\n  [SessionType.Edit]: EditSession,\n}\n\nexport const getSession = <K extends SessionType>(type: K): SessionOfType<K> => {\n  return sessions[type]\n}\n", "import { TLPointerEventHandler, Utils } from '@tldraw/core'\nimport Vec from '@tldraw/vec'\nimport { Arrow } from '~state/shapes'\nimport { BaseTool, Status } from '~state/tools/BaseTool'\nimport { SessionType, TDShapeType } from '~types'\n\nexport class ArrowTool extends BaseTool {\n  type = TDShapeType.Arrow as const\n\n  /* ----------------- Event Handlers ----------------- */\n\n  onPointerDown: TLPointerEventHandler = () => {\n    if (this.status !== Status.Idle) return\n\n    const {\n      currentPoint,\n      currentGrid,\n      settings: { showGrid },\n      appState: { currentPageId, currentStyle },\n    } = this.app\n\n    const childIndex = this.getNextChildIndex()\n\n    const id = Utils.uniqueId()\n\n    const newShape = Arrow.create({\n      id,\n      parentId: currentPageId,\n      childIndex,\n      point: showGrid ? Vec.snap(currentPoint, currentGrid) : currentPoint,\n      style: { ...currentStyle },\n    })\n\n    this.app.patchCreate([newShape])\n\n    this.app.startSession(SessionType.Arrow, newShape.id, 'end', true)\n\n    this.setStatus(Status.Creating)\n  }\n}\n", "import {\n  TLKeyboardEventHandler,\n  TLPinchEventHandler,\n  TLPointerEventHandler,\n  Utils,\n} from '@tldraw/core'\nimport type { TldrawApp } from '~state/TldrawApp'\nimport { TDEventHandler, TDToolType } from '~types'\n\nexport enum Status {\n  Idle = 'idle',\n  Creating = 'creating',\n  Pinching = 'pinching',\n}\n\nexport abstract class BaseTool<T extends string = any> extends TDEventHandler {\n  type: TDToolType = 'select' as const\n\n  previous?: TDToolType\n\n  status: Status | T = Status.Idle\n\n  constructor(public app: TldrawApp) {\n    super()\n  }\n\n  protected readonly setStatus = (status: Status | T) => {\n    this.status = status as Status | T\n    this.app.setStatus(this.status as string)\n  }\n\n  onEnter = () => {\n    this.setStatus(Status.Idle)\n  }\n\n  onExit = () => {\n    this.setStatus(Status.Idle)\n  }\n\n  onCancel = () => {\n    if (this.status === Status.Idle) {\n      this.app.selectTool('select')\n    } else {\n      this.setStatus(Status.Idle)\n    }\n\n    this.app.cancelSession()\n  }\n\n  getNextChildIndex = () => {\n    const {\n      shapes,\n      appState: { currentPageId },\n    } = this.app\n\n    return shapes.length === 0\n      ? 1\n      : shapes\n          .filter((shape) => shape.parentId === currentPageId)\n          .sort((a, b) => b.childIndex - a.childIndex)[0].childIndex + 1\n  }\n\n  /* --------------------- Camera --------------------- */\n\n  onPinchStart: TLPinchEventHandler = () => {\n    this.app.cancelSession()\n    this.setStatus(Status.Pinching)\n  }\n\n  onPinchEnd: TLPinchEventHandler = () => {\n    if (Utils.isMobileSafari()) {\n      this.app.undoSelect()\n    }\n    this.setStatus(Status.Idle)\n  }\n\n  onPinch: TLPinchEventHandler = (info, e) => {\n    if (this.status !== 'pinching') return\n    if (isNaN(info.delta[0]) || isNaN(info.delta[1])) return\n    this.app.pinchZoom(info.point, info.delta, info.delta[2])\n    this.onPointerMove?.(info, e as unknown as React.PointerEvent)\n  }\n\n  /* ---------------------- Keys ---------------------- */\n\n  onKeyDown: TLKeyboardEventHandler = (key) => {\n    if (key === 'Escape') {\n      this.onCancel()\n      return\n    }\n\n    if (key === 'Meta' || key === 'Control' || key === 'Alt') {\n      this.app.updateSession()\n      return\n    }\n  }\n\n  onKeyUp: TLKeyboardEventHandler = (key) => {\n    if (key === 'Meta' || key === 'Control' || key === 'Alt') {\n      this.app.updateSession()\n      return\n    }\n  }\n\n  /* --------------------- Pointer -------------------- */\n\n  onPointerMove: TLPointerEventHandler = () => {\n    if (this.status === Status.Creating) {\n      this.app.updateSession()\n    }\n  }\n\n  onPointerUp: TLPointerEventHandler = () => {\n    if (this.status === Status.Creating) {\n      this.app.completeSession()\n\n      const { isToolLocked } = this.app.appState\n\n      if (!isToolLocked) {\n        this.app.selectTool('select')\n      }\n    }\n\n    this.setStatus(Status.Idle)\n  }\n}\n", "import { TLPointerEventHandler, Utils } from '@tldraw/core'\nimport { Draw } from '~state/shapes'\nimport { BaseTool } from '~state/tools/BaseTool'\nimport { SessionType, TDShapeType } from '~types'\n\nenum Status {\n  Idle = 'idle',\n  Creating = 'creating',\n  Extending = 'extending',\n  Pinching = 'pinching',\n}\n\nexport class DrawTool extends BaseTool {\n  type = TDShapeType.Draw as const\n\n  private lastShapeId?: string\n\n  onEnter = () => {\n    this.lastShapeId = undefined\n  }\n\n  onCancel = () => {\n    switch (this.status) {\n      case Status.Idle: {\n        this.app.selectTool('select')\n        break\n      }\n      default: {\n        this.setStatus(Status.Idle)\n        break\n      }\n    }\n\n    this.app.cancelSession()\n  }\n\n  /* ----------------- Event Handlers ----------------- */\n\n  onPointerDown: TLPointerEventHandler = (info) => {\n    if (this.status !== Status.Idle) return\n    if (this.app.readOnly) return\n    const {\n      currentPoint,\n      appState: { currentPageId, currentStyle },\n    } = this.app\n    const previous = this.lastShapeId && this.app.getShape(this.lastShapeId)\n    if (info.shiftKey && previous) {\n      // Extend the previous shape\n      this.app.startSession(SessionType.Draw, previous.id)\n      this.setStatus(Status.Extending)\n    } else {\n      // Create a new shape\n      const childIndex = this.getNextChildIndex()\n      const id = Utils.uniqueId()\n      const newShape = Draw.create({\n        id,\n        parentId: currentPageId,\n        childIndex,\n        point: currentPoint,\n        style: { ...currentStyle },\n      })\n      this.lastShapeId = id\n      this.app.patchCreate([newShape])\n      this.app.startSession(SessionType.Draw, id)\n      this.setStatus(Status.Creating)\n    }\n  }\n\n  onPointerMove: TLPointerEventHandler = () => {\n    if (this.app.readOnly) return\n\n    switch (this.status) {\n      case Status.Extending:\n      case Status.Creating: {\n        this.app.updateSession()\n      }\n    }\n  }\n\n  onPointerUp: TLPointerEventHandler = () => {\n    this.app.completeSession()\n    this.setStatus(Status.Idle)\n  }\n}\n", "import { TLBoundsCorner, TLPointerEventHandler, Utils } from '@tldraw/core'\nimport Vec from '@tldraw/vec'\nimport { Ellipse } from '~state/shapes'\nimport { BaseTool, Status } from '~state/tools/BaseTool'\nimport { SessionType, TDShapeType } from '~types'\n\nexport class EllipseTool extends BaseTool {\n  type = TDShapeType.Ellipse as const\n\n  /* ----------------- Event Handlers ----------------- */\n\n  onPointerDown: TLPointerEventHandler = () => {\n    if (this.app.readOnly) return\n    if (this.status !== Status.Idle) return\n\n    const {\n      currentPoint,\n      currentGrid,\n      settings: { showGrid },\n      appState: { currentPageId, currentStyle },\n    } = this.app\n\n    const childIndex = this.getNextChildIndex()\n\n    const id = Utils.uniqueId()\n\n    const newShape = Ellipse.create({\n      id,\n      parentId: currentPageId,\n      childIndex,\n      point: showGrid ? Vec.snap(currentPoint, currentGrid) : currentPoint,\n      style: { ...currentStyle },\n    })\n\n    this.app.patchCreate([newShape])\n\n    this.app.startSession(\n      SessionType.TransformSingle,\n      newShape.id,\n      TLBoundsCorner.BottomRight,\n      true\n    )\n\n    this.setStatus(Status.Creating)\n  }\n}\n", "import type { TLPointerEventHandler } from '@tldraw/core'\nimport Vec from '@tldraw/vec'\nimport { DEAD_ZONE } from '~constants'\nimport { BaseTool } from '~state/tools/BaseTool'\nimport { SessionType } from '~types'\n\nenum Status {\n  Idle = 'idle',\n  Pointing = 'pointing',\n  Erasing = 'erasing',\n}\n\nexport class EraseTool extends BaseTool {\n  type = 'erase' as const\n\n  status: Status = Status.Idle\n\n  /* ----------------- Event Handlers ----------------- */\n\n  onPointerDown: TLPointerEventHandler = () => {\n    if (this.app.readOnly) return\n    if (this.status !== Status.Idle) return\n\n    this.setStatus(Status.Pointing)\n  }\n\n  onPointerMove: TLPointerEventHandler = (info) => {\n    if (this.app.readOnly) return\n    switch (this.status) {\n      case Status.Pointing: {\n        if (Vec.dist(info.origin, info.point) > DEAD_ZONE) {\n          this.app.startSession(SessionType.Erase)\n          this.app.updateSession()\n          this.setStatus(Status.Erasing)\n        }\n        break\n      }\n      case Status.Erasing: {\n        this.app.updateSession()\n      }\n    }\n  }\n\n  onPointerUp: TLPointerEventHandler = () => {\n    if (this.app.readOnly) return\n    switch (this.status) {\n      case Status.Pointing: {\n        const shapeIdsAtPoint = this.app.shapes\n          .filter((shape) => !shape.isLocked)\n          .filter((shape) =>\n            this.app.getShapeUtil(shape).hitTestPoint(shape, this.app.currentPoint)\n          )\n          .flatMap((shape) => (shape.children ? [shape.id, ...shape.children] : shape.id))\n\n        this.app.delete(shapeIdsAtPoint)\n\n        break\n      }\n      case Status.Erasing: {\n        this.app.completeSession()\n\n        // Should the app go back to the previous state, the select\n        // state, or stay in the eraser state?\n\n        // if (this.previous) {\n        //   this.app.selectTool(this.previous)\n        // } else {\n        //   this.app.selectTool('select')\n        // }\n      }\n    }\n\n    this.setStatus(Status.Idle)\n  }\n\n  onCancel = () => {\n    if (this.status === Status.Idle) {\n      if (this.previous) {\n        this.app.selectTool(this.previous)\n      } else {\n        this.app.selectTool('select')\n      }\n    } else {\n      this.setStatus(Status.Idle)\n    }\n\n    this.app.cancelSession()\n  }\n}\n", "import { TLPointerEventHandler, Utils } from '@tldraw/core'\nimport Vec from '@tldraw/vec'\nimport { Arrow } from '~state/shapes'\nimport { BaseTool, Status } from '~state/tools/BaseTool'\nimport { SessionType, TDShapeType } from '~types'\n\nexport class LineTool extends BaseTool {\n  type = TDShapeType.Line as const\n\n  /* ----------------- Event Handlers ----------------- */\n\n  onPointerDown: TLPointerEventHandler = () => {\n    if (this.app.readOnly) return\n    if (this.status !== Status.Idle) return\n\n    const {\n      currentPoint,\n      currentGrid,\n      settings: { showGrid },\n      appState: { currentPageId, currentStyle },\n    } = this.app\n\n    const childIndex = this.getNextChildIndex()\n\n    const id = Utils.uniqueId()\n\n    const newShape = Arrow.create({\n      id,\n      parentId: currentPageId,\n      childIndex,\n      point: showGrid ? Vec.snap(currentPoint, currentGrid) : currentPoint,\n      decorations: {\n        start: undefined,\n        end: undefined,\n      },\n      style: { ...currentStyle },\n    })\n\n    this.app.patchCreate([newShape])\n\n    this.app.startSession(SessionType.Arrow, newShape.id, 'end', true)\n\n    this.setStatus(Status.Creating)\n  }\n}\n", "import { TLBoundsCorner, TLPointerEventHandler, Utils } from '@tldraw/core'\nimport Vec from '@tldraw/vec'\nimport { Rectangle } from '~state/shapes'\nimport { BaseTool, Status } from '~state/tools/BaseTool'\nimport { SessionType, TDShapeType } from '~types'\n\nexport class RectangleTool extends BaseTool {\n  type = TDShapeType.Rectangle as const\n\n  /* ----------------- Event Handlers ----------------- */\n\n  onPointerDown: TLPointerEventHandler = () => {\n    if (this.app.readOnly) return\n    if (this.status !== Status.Idle) return\n\n    const {\n      currentPoint,\n      currentGrid,\n      settings: { showGrid },\n      appState: { currentPageId, currentStyle },\n    } = this.app\n\n    const childIndex = this.getNextChildIndex()\n\n    const id = Utils.uniqueId()\n\n    const newShape = Rectangle.create({\n      id,\n      parentId: currentPageId,\n      childIndex,\n      point: showGrid ? Vec.snap(currentPoint, currentGrid) : currentPoint,\n      style: { ...currentStyle },\n    })\n\n    this.app.patchCreate([newShape])\n\n    this.app.startSession(\n      SessionType.TransformSingle,\n      newShape.id,\n      TLBoundsCorner.BottomRight,\n      true\n    )\n\n    this.setStatus(Status.Creating)\n  }\n}\n", "import {\n  TLBoundsCorner,\n  TLBoundsEdge,\n  TLBoundsEventHandler,\n  TLBoundsHandleEventHandler,\n  TLCanvasEventHandler,\n  TLKeyboardEventHandler,\n  TLPointerEventHandler,\n  TLShapeCloneHandler,\n  Utils,\n} from '@tldraw/core'\nimport Vec from '@tldraw/vec'\nimport { CLONING_DISTANCE, DEAD_ZONE } from '~constants'\nimport { TLDR } from '~state/TLDR'\nimport { BaseTool } from '~state/tools/BaseTool'\nimport { SessionType, TDShapeType } from '~types'\n\nenum Status {\n  Idle = 'idle',\n  Creating = 'creating',\n  Pinching = 'pinching',\n  PointingCanvas = 'pointingCanvas',\n  PointingHandle = 'pointingHandle',\n  PointingBounds = 'pointingBounds',\n  PointingClone = 'pointingClone',\n  TranslatingClone = 'translatingClone',\n  PointingBoundsHandle = 'pointingBoundsHandle',\n  TranslatingHandle = 'translatingHandle',\n  Translating = 'translating',\n  Transforming = 'transforming',\n  Rotating = 'rotating',\n  Brushing = 'brushing',\n  GridCloning = 'gridCloning',\n  ClonePainting = 'clonePainting',\n}\n\nexport class SelectTool extends BaseTool<Status> {\n  type = 'select' as const\n\n  pointedId?: string\n\n  selectedGroupId?: string\n\n  pointedHandleId?: 'start' | 'end' | 'bend'\n\n  pointedBoundsHandle?: TLBoundsCorner | TLBoundsEdge | 'rotate' | 'center' | 'left' | 'right'\n\n  pointedLinkHandleId?: 'left' | 'center' | 'right'\n\n  /* --------------------- Methods -------------------- */\n\n  private deselect(id: string) {\n    this.app.select(...this.app.selectedIds.filter((oid) => oid !== id))\n  }\n\n  private select(id: string) {\n    this.app.select(id)\n  }\n\n  private pushSelect(id: string) {\n    const shape = this.app.getShape(id)\n    this.app.select(...this.app.selectedIds.filter((oid) => oid !== shape.parentId), id)\n  }\n\n  private selectNone() {\n    this.app.selectNone()\n  }\n\n  onEnter = () => {\n    this.setStatus(Status.Idle)\n  }\n\n  onExit = () => {\n    this.setStatus(Status.Idle)\n  }\n\n  clonePaint = (point: number[]) => {\n    if (this.app.selectedIds.length === 0) return\n\n    const shapes = this.app.selectedIds.map((id) => this.app.getShape(id))\n\n    const bounds = Utils.expandBounds(Utils.getCommonBounds(shapes.map(TLDR.getBounds)), 16)\n\n    const center = Utils.getBoundsCenter(bounds)\n\n    const size = [bounds.width, bounds.height]\n\n    const gridPoint = [\n      center[0] + size[0] * Math.floor((point[0] + size[0] / 2 - center[0]) / size[0]),\n      center[1] + size[1] * Math.floor((point[1] + size[1] / 2 - center[1]) / size[1]),\n    ]\n\n    const centeredBounds = Utils.centerBounds(bounds, gridPoint)\n\n    const hit = this.app.shapes.some((shape) =>\n      TLDR.getShapeUtil(shape).hitTestBounds(shape, centeredBounds)\n    )\n\n    if (!hit) {\n      this.app.duplicate(this.app.selectedIds, gridPoint)\n    }\n  }\n\n  getShapeClone = (\n    id: string,\n    side:\n      | 'top'\n      | 'right'\n      | 'bottom'\n      | 'left'\n      | 'topLeft'\n      | 'topRight'\n      | 'bottomRight'\n      | 'bottomLeft'\n  ) => {\n    const shape = this.app.getShape(id)\n\n    const utils = TLDR.getShapeUtil(shape)\n\n    if (utils.canClone) {\n      const bounds = utils.getBounds(shape)\n\n      const center = utils.getCenter(shape)\n\n      let point = {\n        top: [bounds.minX, bounds.minY - (bounds.height + CLONING_DISTANCE)],\n        right: [bounds.maxX + CLONING_DISTANCE, bounds.minY],\n        bottom: [bounds.minX, bounds.maxY + CLONING_DISTANCE],\n        left: [bounds.minX - (bounds.width + CLONING_DISTANCE), bounds.minY],\n        topLeft: [\n          bounds.minX - (bounds.width + CLONING_DISTANCE),\n          bounds.minY - (bounds.height + CLONING_DISTANCE),\n        ],\n        topRight: [\n          bounds.maxX + CLONING_DISTANCE,\n          bounds.minY - (bounds.height + CLONING_DISTANCE),\n        ],\n        bottomLeft: [\n          bounds.minX - (bounds.width + CLONING_DISTANCE),\n          bounds.maxY + CLONING_DISTANCE,\n        ],\n        bottomRight: [bounds.maxX + CLONING_DISTANCE, bounds.maxY + CLONING_DISTANCE],\n      }[side]\n\n      if (shape.rotation !== 0) {\n        const newCenter = Vec.add(point, [bounds.width / 2, bounds.height / 2])\n\n        const rotatedCenter = Vec.rotWith(newCenter, center, shape.rotation || 0)\n\n        point = Vec.sub(rotatedCenter, [bounds.width / 2, bounds.height / 2])\n      }\n\n      const id = Utils.uniqueId()\n\n      const clone = {\n        ...shape,\n        id,\n        point,\n      }\n\n      if (clone.type === TDShapeType.Sticky) {\n        clone.text = ''\n      }\n\n      return clone\n    }\n\n    return\n  }\n\n  /* ----------------- Event Handlers ----------------- */\n\n  onCancel = () => {\n    if (this.app.session) {\n      this.app.cancelSession()\n    } else {\n      this.selectNone()\n    }\n\n    this.setStatus(Status.Idle)\n  }\n\n  onKeyDown: TLKeyboardEventHandler = (key, info, e) => {\n    switch (key) {\n      case 'Escape': {\n        this.onCancel()\n        break\n      }\n      case 'Tab': {\n        if (this.app.readOnly) return\n\n        if (\n          !this.app.pageState.editingId &&\n          this.status === Status.Idle &&\n          this.app.selectedIds.length === 1\n        ) {\n          const [selectedId] = this.app.selectedIds\n          const clonedShape = this.getShapeClone(selectedId, 'right')\n\n          if (clonedShape) {\n            this.app.createShapes(clonedShape)\n            this.setStatus(Status.Idle)\n            if (clonedShape.type === TDShapeType.Sticky) {\n              this.app.select(clonedShape.id)\n              this.app.setEditingId(clonedShape.id)\n            }\n          }\n        }\n        break\n      }\n      case 'Meta':\n      case 'Control':\n      case 'Alt': {\n        this.app.updateSession()\n        break\n      }\n      case 'Enter': {\n        if (this.app.readOnly) return\n\n        const { pageState } = this.app\n        if (pageState.selectedIds.length === 1 && !pageState.editingId) {\n          this.app.setEditingId(pageState.selectedIds[0])\n          e.preventDefault()\n        }\n      }\n    }\n  }\n\n  onKeyUp: TLKeyboardEventHandler = (key, info) => {\n    if (this.status === Status.ClonePainting && !(info.altKey && info.shiftKey)) {\n      this.setStatus(Status.Idle)\n      return\n    }\n\n    /* noop */\n    if (key === 'Meta' || key === 'Control' || key === 'Alt') {\n      this.app.updateSession()\n      return\n    }\n  }\n\n  // Keyup is handled on BaseTool\n\n  // Pointer Events (generic)\n\n  onPointerMove: TLPointerEventHandler = () => {\n    const { originPoint, currentPoint } = this.app\n\n    if (this.app.readOnly && this.app.isPointing) {\n      if (this.app.session) {\n        this.app.updateSession()\n      } else {\n        if (Vec.dist(originPoint, currentPoint) > DEAD_ZONE) {\n          this.app.startSession(SessionType.Brush)\n          this.setStatus(Status.Brushing)\n        }\n      }\n      return\n    }\n\n    switch (this.status) {\n      case Status.PointingBoundsHandle: {\n        if (!this.pointedBoundsHandle) throw Error('No pointed bounds handle')\n        if (Vec.dist(originPoint, currentPoint) > DEAD_ZONE) {\n          if (this.pointedBoundsHandle === 'rotate') {\n            // Stat a rotate session\n            this.setStatus(Status.Rotating)\n            this.app.startSession(SessionType.Rotate)\n          } else if (\n            this.pointedBoundsHandle === 'center' ||\n            this.pointedBoundsHandle === 'left' ||\n            this.pointedBoundsHandle === 'right'\n          ) {\n            this.setStatus(Status.Translating)\n            this.app.startSession(SessionType.Translate, false, this.pointedBoundsHandle)\n          } else {\n            // Stat a transform session\n            this.setStatus(Status.Transforming)\n            const idsToTransform = this.app.selectedIds.flatMap((id) =>\n              TLDR.getDocumentBranch(this.app.state, id, this.app.currentPageId)\n            )\n            if (idsToTransform.length === 1) {\n              // if only one shape is selected, transform single\n              this.app.startSession(\n                SessionType.TransformSingle,\n                idsToTransform[0],\n                this.pointedBoundsHandle\n              )\n            } else {\n              // otherwise, transform\n              this.app.startSession(SessionType.Transform, this.pointedBoundsHandle)\n            }\n          }\n\n          // Also update the session with the current point\n          this.app.updateSession()\n        }\n        break\n      }\n      case Status.PointingCanvas: {\n        if (Vec.dist(originPoint, currentPoint) > DEAD_ZONE) {\n          this.app.startSession(SessionType.Brush)\n          this.setStatus(Status.Brushing)\n        }\n        break\n      }\n      case Status.PointingClone: {\n        if (Vec.dist(originPoint, currentPoint) > DEAD_ZONE) {\n          this.setStatus(Status.TranslatingClone)\n          this.app.startSession(SessionType.Translate)\n          this.app.updateSession()\n        }\n        break\n      }\n      case Status.PointingBounds: {\n        if (Vec.dist(originPoint, currentPoint) > DEAD_ZONE) {\n          this.setStatus(Status.Translating)\n          this.app.startSession(SessionType.Translate)\n          this.app.updateSession()\n        }\n        break\n      }\n      case Status.PointingHandle: {\n        if (!this.pointedHandleId) throw Error('No pointed handle')\n        if (Vec.dist(originPoint, currentPoint) > DEAD_ZONE) {\n          this.setStatus(Status.TranslatingHandle)\n          const selectedShape = this.app.getShape(this.app.selectedIds[0])\n          if (selectedShape) {\n            if (this.pointedHandleId === 'bend') {\n              this.app.startSession(SessionType.Handle, selectedShape.id, this.pointedHandleId)\n              this.app.updateSession()\n            } else {\n              this.app.startSession(\n                SessionType.Arrow,\n                selectedShape.id,\n                this.pointedHandleId,\n                false\n              )\n              this.app.updateSession()\n            }\n          }\n        }\n        break\n      }\n      case Status.ClonePainting: {\n        this.clonePaint(currentPoint)\n        break\n      }\n      default: {\n        if (this.app.session) {\n          this.app.updateSession()\n          break\n        }\n      }\n    }\n  }\n\n  onPointerDown: TLPointerEventHandler = (info, e) => {\n    if (info.target === 'canvas' && this.status === Status.Idle) {\n      const { currentPoint } = this.app\n\n      if (info.spaceKey && e.buttons === 1) return\n\n      if (this.status === Status.Idle && info.altKey && info.shiftKey) {\n        this.setStatus(Status.ClonePainting)\n        this.clonePaint(currentPoint)\n        return\n      }\n\n      // Unless the user is holding shift or meta, clear the current selection\n      if (!info.shiftKey) {\n        this.app.onShapeBlur()\n\n        if (info.altKey && this.app.selectedIds.length > 0) {\n          this.app.duplicate(this.app.selectedIds, currentPoint)\n          return\n        }\n\n        this.selectNone()\n      }\n\n      this.setStatus(Status.PointingCanvas)\n    }\n  }\n\n  onPointerUp: TLPointerEventHandler = (info) => {\n    if (this.status === Status.TranslatingClone || this.status === Status.PointingClone) {\n      if (this.pointedId) {\n        this.app.completeSession()\n        this.app.setEditingId(this.pointedId)\n      }\n      this.setStatus(Status.Idle)\n      this.pointedId = undefined\n      return\n    }\n\n    if (this.status === Status.PointingBounds) {\n      if (info.target === 'bounds') {\n        // If we just clicked the selecting bounds's background,\n        // clear the selection\n        this.selectNone()\n      } else if (this.app.isSelected(info.target)) {\n        // If we're holding shift...\n        if (info.shiftKey) {\n          // unless we just shift-selected the shape, remove it from\n          // the selected shapes\n          if (this.pointedId !== info.target) {\n            this.deselect(info.target)\n          }\n        } else {\n          // If we have other selected shapes, select this one instead\n          if (this.pointedId !== info.target && this.app.selectedIds.length > 1) {\n            this.select(info.target)\n          }\n        }\n      } else if (this.pointedId === info.target) {\n        if (this.app.getShape(info.target).isLocked) return\n        // If the target is not selected and was just pointed\n        // on pointer down...\n        if (info.shiftKey) {\n          this.pushSelect(info.target)\n        } else {\n          this.select(info.target)\n        }\n      }\n    }\n\n    // Complete the current session, if any; and reset the status\n\n    this.setStatus(Status.Idle)\n    this.pointedBoundsHandle = undefined\n    this.pointedHandleId = undefined\n    this.pointedId = undefined\n\n    // Don't complete a session if we've just started one\n    if (this.app.session?.type === SessionType.Edit) {\n      return\n    }\n\n    this.app.completeSession()\n  }\n\n  // Canvas\n\n  onDoubleClickCanvas: TLCanvasEventHandler = () => {\n    if (this.app.readOnly) return\n    // Needs debugging\n    // const { currentPoint } = this.app\n    // this.app.selectTool(TDShapeType.Text)\n    // this.setStatus(Status.Idle)\n    // this.app.createTextShapeAtPoint(currentPoint)\n  }\n\n  // Shape\n\n  onPointShape: TLPointerEventHandler = (info, e) => {\n    if (info.spaceKey && e.buttons === 1) return\n\n    if (this.app.getShape(info.target).isLocked) return\n\n    const { editingId, hoveredId } = this.app.pageState\n\n    if (editingId && info.target !== editingId) {\n      this.app.onShapeBlur()\n    }\n\n    // While holding command and shift, select or deselect\n    // the shape, ignoring any group that may contain it. Yikes!\n    if (\n      (this.status === Status.Idle || this.status === Status.PointingBounds) &&\n      info.metaKey &&\n      info.shiftKey &&\n      hoveredId\n    ) {\n      this.pointedId = hoveredId\n\n      if (this.app.isSelected(hoveredId)) {\n        this.deselect(hoveredId)\n      } else {\n        this.pushSelect(hoveredId)\n        this.setStatus(Status.PointingBounds)\n      }\n\n      return\n    }\n\n    if (this.status === Status.PointingBounds) {\n      // The pointed id should be the shape's group, if it belongs\n      // to a group, or else the shape itself, if it is on the page.\n      const { parentId } = this.app.getShape(info.target)\n      this.pointedId = parentId === this.app.currentPageId ? info.target : parentId\n      return\n    }\n\n    if (this.status === Status.Idle) {\n      this.setStatus(Status.PointingBounds)\n\n      if (info.metaKey) {\n        if (!info.shiftKey) {\n          this.selectNone()\n        }\n\n        this.app.startSession(SessionType.Brush)\n\n        this.setStatus(Status.Brushing)\n        return\n      }\n\n      // If we've clicked on a shape that is inside of a group,\n      // then select the group rather than the shape.\n      let shapeIdToSelect: string\n      const { parentId } = this.app.getShape(info.target)\n\n      // If the pointed shape is a child of the page, select the\n      // target shape and clear the selected group id.\n      if (parentId === this.app.currentPageId) {\n        shapeIdToSelect = info.target\n        this.selectedGroupId = undefined\n      } else {\n        // If the parent is some other group...\n        if (parentId === this.selectedGroupId) {\n          // If that group is the selected group, then select\n          // the target shape.\n          shapeIdToSelect = info.target\n        } else {\n          // Otherwise, select the group and clear the selected\n          // group id.\n          shapeIdToSelect = parentId\n\n          this.selectedGroupId = undefined\n        }\n      }\n\n      if (!this.app.isSelected(shapeIdToSelect)) {\n        // Set the pointed ID to the shape that was clicked.\n        this.pointedId = shapeIdToSelect\n\n        // If the shape is not selected: then if the user is pressing shift,\n        // add the shape to the current selection; otherwise, set the shape as\n        // the only selected shape.\n        if (info.shiftKey) {\n          this.pushSelect(shapeIdToSelect)\n        } else {\n          this.select(shapeIdToSelect)\n        }\n      }\n    }\n  }\n\n  onDoubleClickShape: TLPointerEventHandler = (info) => {\n    if (this.app.readOnly) return\n\n    const shape = this.app.getShape(info.target)\n\n    if (shape.isLocked) {\n      this.app.select(info.target)\n      return\n    }\n\n    // If we can edit the shape (and if we can select the shape) then\n    // start editing\n    if (\n      TLDR.getShapeUtil(shape.type).canEdit &&\n      (shape.parentId === this.app.currentPageId || shape.parentId === this.selectedGroupId)\n    ) {\n      this.app.setEditingId(info.target)\n    }\n\n    // If the shape is the child of a group, then drill into the group?\n    if (shape.parentId !== this.app.currentPageId) {\n      this.selectedGroupId = shape.parentId\n    }\n\n    this.app.select(info.target)\n  }\n\n  onRightPointShape: TLPointerEventHandler = (info) => {\n    if (!this.app.isSelected(info.target)) {\n      this.app.select(info.target)\n    }\n  }\n\n  onHoverShape: TLPointerEventHandler = (info) => {\n    this.app.setHoveredId(info.target)\n  }\n\n  onUnhoverShape: TLPointerEventHandler = (info) => {\n    const { currentPageId: oldCurrentPageId } = this.app\n\n    // Wait a frame; and if we haven't changed the hovered id,\n    // clear the current hovered id\n    requestAnimationFrame(() => {\n      if (\n        oldCurrentPageId === this.app.currentPageId &&\n        this.app.pageState.hoveredId === info.target\n      ) {\n        this.app.setHoveredId(undefined)\n      }\n    })\n  }\n\n  /* --------------------- Bounds --------------------- */\n\n  onPointBounds: TLBoundsEventHandler = (info) => {\n    if (info.metaKey) {\n      if (!info.shiftKey) {\n        this.selectNone()\n      }\n\n      this.app.startSession(SessionType.Brush)\n\n      this.setStatus(Status.Brushing)\n      return\n    }\n\n    this.setStatus(Status.PointingBounds)\n  }\n\n  onRightPointBounds: TLPointerEventHandler = (info, e) => {\n    e.stopPropagation()\n  }\n\n  onReleaseBounds: TLBoundsEventHandler = () => {\n    if (this.status === Status.Translating || this.status === Status.Brushing) {\n      this.app.completeSession()\n    }\n\n    this.setStatus(Status.Idle)\n  }\n\n  /* ----------------- Bounds Handles ----------------- */\n\n  onPointBoundsHandle: TLBoundsHandleEventHandler = (info) => {\n    this.pointedBoundsHandle = info.target\n    this.setStatus(Status.PointingBoundsHandle)\n  }\n\n  onDoubleClickBoundsHandle: TLBoundsHandleEventHandler = (info) => {\n    switch (info.target) {\n      case 'center':\n      case 'left':\n      case 'right': {\n        this.app.select(\n          ...TLDR.getLinkedShapeIds(\n            this.app.state,\n            this.app.currentPageId,\n            info.target,\n            info.shiftKey\n          )\n        )\n        break\n      }\n      default: {\n        if (this.app.selectedIds.length === 1) {\n          this.app.resetBounds(this.app.selectedIds)\n          const shape = this.app.getShape(this.app.selectedIds[0])\n          if ('label' in shape) {\n            this.app.setEditingId(shape.id)\n          }\n        }\n      }\n    }\n  }\n\n  onReleaseBoundsHandle: TLBoundsHandleEventHandler = () => {\n    this.setStatus(Status.Idle)\n  }\n\n  /* --------------------- Handles -------------------- */\n\n  onPointHandle: TLPointerEventHandler = (info) => {\n    this.pointedHandleId = info.target as 'start' | 'end'\n    this.setStatus(Status.PointingHandle)\n  }\n\n  onDoubleClickHandle: TLPointerEventHandler = (info) => {\n    if (info.target === 'bend') {\n      const { selectedIds } = this.app\n      if (selectedIds.length !== 1) return\n      const shape = this.app.getShape(selectedIds[0])\n      if (\n        TLDR.getShapeUtil(shape.type).canEdit &&\n        (shape.parentId === this.app.currentPageId || shape.parentId === this.selectedGroupId)\n      ) {\n        this.app.setEditingId(shape.id)\n      }\n      return\n    }\n\n    this.app.toggleDecoration(info.target)\n  }\n\n  onReleaseHandle: TLPointerEventHandler = () => {\n    this.setStatus(Status.Idle)\n  }\n\n  /* ---------------------- Misc ---------------------- */\n\n  onShapeClone: TLShapeCloneHandler = (info) => {\n    const selectedShapeId = this.app.selectedIds[0]\n\n    const clonedShape = this.getShapeClone(selectedShapeId, info.target)\n\n    if (\n      info.target === 'left' ||\n      info.target === 'right' ||\n      info.target === 'top' ||\n      info.target === 'bottom'\n    ) {\n      if (clonedShape) {\n        this.app.createShapes(clonedShape)\n\n        // Now start pointing the bounds, so that a user can start\n        // dragging to reposition if they wish.\n        this.pointedId = clonedShape.id\n        this.setStatus(Status.PointingClone)\n      }\n    } else {\n      this.setStatus(Status.GridCloning)\n      this.app.startSession(SessionType.Grid, selectedShapeId)\n    }\n  }\n}\n", "import type { TLPointerEventHandler } from '@tldraw/core'\nimport { Utils } from '@tldraw/core'\nimport Vec from '@tldraw/vec'\nimport { Sticky } from '~state/shapes'\nimport { BaseTool, Status } from '~state/tools/BaseTool'\nimport { SessionType, TDShapeType } from '~types'\n\nexport class StickyTool extends BaseTool {\n  type = TDShapeType.Sticky as const\n\n  shapeId?: string\n\n  /* ----------------- Event Handlers ----------------- */\n\n  onPointerDown: TLPointerEventHandler = () => {\n    if (this.app.readOnly) return\n    if (this.status === Status.Creating) {\n      this.setStatus(Status.Idle)\n\n      if (!this.app.appState.isToolLocked) {\n        this.app.selectTool('select')\n      }\n\n      return\n    }\n\n    if (this.status === Status.Idle) {\n      const {\n        currentPoint,\n        currentGrid,\n        settings: { showGrid },\n        appState: { currentPageId, currentStyle },\n      } = this.app\n\n      const childIndex = this.getNextChildIndex()\n\n      const id = Utils.uniqueId()\n\n      this.shapeId = id\n\n      const newShape = Sticky.create({\n        id,\n        parentId: currentPageId,\n        childIndex,\n        point: showGrid ? Vec.snap(currentPoint, currentGrid) : currentPoint,\n        style: { ...currentStyle },\n      })\n\n      const bounds = Sticky.getBounds(newShape)\n\n      newShape.point = Vec.sub(newShape.point, [bounds.width / 2, bounds.height / 2])\n\n      this.app.patchCreate([newShape])\n\n      this.app.startSession(SessionType.Translate)\n\n      this.setStatus(Status.Creating)\n    }\n  }\n\n  onPointerUp: TLPointerEventHandler = () => {\n    if (this.app.readOnly) return\n    if (this.status === Status.Creating) {\n      this.setStatus(Status.Idle)\n      this.app.completeSession()\n      this.app.selectTool('select')\n      this.app.setEditingId(this.shapeId)\n    }\n  }\n}\n", "import type { TLKeyboardEventHandler, TLPointerEventHandler } from '@tldraw/core'\nimport Vec from '@tldraw/vec'\nimport { BaseTool, Status } from '~state/tools/BaseTool'\nimport { TDShapeType } from '~types'\n\nexport class TextTool extends BaseTool {\n  type = TDShapeType.Text as const\n\n  /* --------------------- Methods -------------------- */\n\n  stopEditingShape = () => {\n    this.setStatus(Status.Idle)\n\n    if (!this.app.appState.isToolLocked) {\n      this.app.selectTool('select')\n    }\n  }\n\n  /* ----------------- Event Handlers ----------------- */\n\n  onKeyUp: TLKeyboardEventHandler = () => {\n    // noop\n  }\n\n  onKeyDown: TLKeyboardEventHandler = () => {\n    // noop\n  }\n\n  onPointerDown: TLPointerEventHandler = () => {\n    if (this.status === Status.Creating) {\n      this.stopEditingShape()\n      return\n    }\n\n    if (this.status === Status.Idle) {\n      const {\n        currentPoint,\n        currentGrid,\n        settings: { showGrid },\n      } = this.app\n\n      this.app.createTextShapeAtPoint(\n        showGrid ? Vec.snap(currentPoint, currentGrid) : currentPoint,\n        undefined,\n        true\n      )\n      this.setStatus(Status.Creating)\n      return\n    }\n  }\n\n  onPointerUp: TLPointerEventHandler = () => {\n    // noop important! We don't want the inherited event\n    // from BaseUtil to run.\n  }\n\n  onPointShape: TLPointerEventHandler = (info) => {\n    if (this.app.readOnly) return\n    const shape = this.app.getShape(info.target)\n    if (shape.type === TDShapeType.Text) {\n      this.setStatus(Status.Idle)\n      this.app.setEditingId(shape.id)\n    }\n  }\n\n  onShapeBlur = () => {\n    if (this.app.readOnly) return\n    this.stopEditingShape()\n  }\n}\n", "import { TLBoundsCorner, TLPointerEventHandler, Utils } from '@tldraw/core'\nimport Vec from '@tldraw/vec'\nimport { Triangle } from '~state/shapes'\nimport { BaseTool, Status } from '~state/tools/BaseTool'\nimport { SessionType, TDShapeType } from '~types'\n\nexport class TriangleTool extends BaseTool {\n  type = TDShapeType.Triangle as const\n\n  /* ----------------- Event Handlers ----------------- */\n\n  onPointerDown: TLPointerEventHandler = () => {\n    if (this.app.readOnly) return\n    if (this.status !== Status.Idle) return\n\n    const {\n      currentPoint,\n      currentGrid,\n      settings: { showGrid },\n      appState: { currentPageId, currentStyle },\n    } = this.app\n\n    const childIndex = this.getNextChildIndex()\n\n    const id = Utils.uniqueId()\n\n    const newShape = Triangle.create({\n      id,\n      parentId: currentPageId,\n      childIndex,\n      point: showGrid ? Vec.snap(currentPoint, currentGrid) : currentPoint,\n      style: { ...currentStyle },\n    })\n\n    this.app.patchCreate([newShape])\n\n    this.app.startSession(\n      SessionType.TransformSingle,\n      newShape.id,\n      TLBoundsCorner.BottomRight,\n      true\n    )\n\n    this.setStatus(Status.Creating)\n  }\n}\n", "import { TDShapeType, TDToolType } from '~types'\nimport { ArrowTool } from './ArrowTool'\nimport { DrawTool } from './DrawTool'\nimport { EllipseTool } from './EllipseTool'\nimport { EraseTool } from './EraseTool'\nimport { LineTool } from './LineTool'\nimport { RectangleTool } from './RectangleTool'\nimport { SelectTool } from './SelectTool'\nimport { StickyTool } from './StickyTool'\nimport { TextTool } from './TextTool'\nimport { TriangleTool } from './TriangleTool'\n\nexport interface ToolsMap {\n  select: typeof SelectTool\n  erase: typeof EraseTool\n  [TDShapeType.Text]: typeof TextTool\n  [TDShapeType.Draw]: typeof DrawTool\n  [TDShapeType.Ellipse]: typeof EllipseTool\n  [TDShapeType.Rectangle]: typeof RectangleTool\n  [TDShapeType.Triangle]: typeof TriangleTool\n  [TDShapeType.Line]: typeof LineTool\n  [TDShapeType.Arrow]: typeof ArrowTool\n  [TDShapeType.Sticky]: typeof StickyTool\n}\n\nexport type ToolOfType<K extends TDToolType> = ToolsMap[K]\n\nexport type ArgsOfType<K extends TDToolType> = ConstructorParameters<ToolOfType<K>>\n\nexport const tools: { [K in TDToolType]: ToolsMap[K] } = {\n  select: SelectTool,\n  erase: EraseTool,\n  [TDShapeType.Text]: TextTool,\n  [TDShapeType.Draw]: DrawTool,\n  [TDShapeType.Ellipse]: EllipseTool,\n  [TDShapeType.Rectangle]: RectangleTool,\n  [TDShapeType.Triangle]: TriangleTool,\n  [TDShapeType.Line]: LineTool,\n  [TDShapeType.Arrow]: ArrowTool,\n  [TDShapeType.Sticky]: StickyTool,\n}\n"],
  "mappings": "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",
  "names": []
}
