{
  "version": 3,
  "sources": ["../src/index.ts", "../src/components/Renderer/Renderer.tsx", "../src/components/Canvas/Canvas.tsx", "../src/components/Brush/Brush.tsx", "../src/components/Container/Container.tsx", "../src/hooks/useTLContext.tsx", "../src/hooks/useZoomEvents.ts", "../src/utils/utils.ts", "../src/types.ts", "../src/utils/polyfills.ts", "../src/utils/index.ts", "../src/hooks/useSafariFocusOutFix.tsx", "../src/hooks/useCanvasEvents.tsx", "../src/hooks/useShapeEvents.tsx", "../src/hooks/useShapeTree.tsx", "../src/hooks/useStyle.tsx", "../src/hooks/useBoundsHandleEvents.tsx", "../src/hooks/useCameraCss.tsx", "../src/hooks/useSelection.tsx", "../src/hooks/useHandleEvents.tsx", "../src/hooks/usePreventNavigationCss.tsx", "../src/hooks/useBoundsEvents.tsx", "../src/hooks/usePosition.ts", "../src/hooks/useKeyEvents.ts", "../src/hooks/usePerformanceCss.ts", "../src/components/Cursor/Cursor.tsx", "../src/components/EraseLine/EraseLine.tsx", "../src/components/Grid/Grid.tsx", "../src/components/Overlay/Overlay.tsx", "../src/components/Page/Page.tsx", "../src/components/Bounds/Bounds.tsx", "../src/components/SVGContainer/SVGContainer.tsx", "../src/components/Bounds/CenterHandle.tsx", "../src/components/Bounds/CloneButtons.tsx", "../src/components/Bounds/CloneButton.tsx", "../src/components/Bounds/CornerHandle.tsx", "../src/components/Bounds/EdgeHandle.tsx", "../src/components/Bounds/LinkHandle.tsx", "../src/components/Bounds/RotateHandle.tsx", "../src/components/Bounds/BoundsBg.tsx", "../src/components/Handles/Handles.tsx", "../src/components/Handles/Handle.tsx", "../src/components/Shape/ShapeNode.tsx", "../src/components/Shape/Shape.tsx", "../src/components/Shape/RenderedShape.tsx", "../src/components/ShapeIndicator/ShapeIndicator.tsx", "../src/components/SnapLines/SnapLines.tsx", "../src/components/Users/Users.tsx", "../src/components/User/User.tsx", "../src/components/UsersIndicators/UsersIndicators.tsx", "../src/hooks/useResizeObserver.ts", "../src/inputs.ts", "../src/components/HTMLContainer/HTMLContainer.tsx", "../src/TLShapeUtil/TLShapeUtil.tsx"],
  "sourcesContent": ["export * from './components'\nexport * from './types'\nexport * from './utils'\nexport * from './inputs'\nexport * from './TLShapeUtil'\n", "import * as React from 'react'\nimport { Canvas } from '~/components/Canvas'\nimport { TLShapeUtil } from '~TLShapeUtil'\nimport { CursorComponent } from '~components/Cursor'\nimport { TLContext, TLContextType, useTLTheme } from '~hooks'\nimport { Inputs } from '~inputs'\nimport type {\n  TLAssets,\n  TLBinding,\n  TLBounds,\n  TLCallbacks,\n  TLPage,\n  TLPageState,\n  TLPerformanceMode,\n  TLShape,\n  TLSnapLine,\n  TLTheme,\n  TLUsers,\n} from '~types'\n\nconst EMPTY_OBJECT = Object.freeze({}) as TLAssets\n\nexport type RendererProps<T extends TLShape, M = any> = Partial<TLCallbacks<T>> & {\n  /**\n   * An object containing instances of your shape classes.\n   */\n  shapeUtils: {\n    [K in T['type']]: TLShapeUtil<any>\n  }\n  /**\n   * The current page, containing shapes and bindings.\n   */\n  page: TLPage<T, TLBinding>\n  /**\n   * The current page state.\n   */\n  pageState: TLPageState\n  /**\n   * A map of assets to be used in the renderer.\n   */\n  assets?: TLAssets\n  /**\n   * (optional) A unique id to be applied to the renderer element, used to scope styles.\n   */\n  id?: string\n  /**\n   * (optional) A ref for the renderer's container element, used for scoping event handlers.\n   */\n  containerRef?: React.RefObject<HTMLElement>\n  /**\n   * (optional) Custom components to override parts of the default UI.\n   */\n  components?: {\n    /**\n     * The component to render for multiplayer cursors.\n     */\n    Cursor?: CursorComponent\n  }\n\n  /**\n   * (optional) To hide cursors\n   */\n  hideCursors?: boolean\n  /**\n   * (optional) An object of custom options that should be passed to rendered shapes.\n   */\n  meta?: M\n  /**\n   * (optional) The current users to render.\n   */\n  users?: TLUsers\n  /**\n   * (optional) The current snap lines to render.\n   */\n  snapLines?: TLSnapLine[]\n  /**\n   * (optional) The current erase line to render.\n   */\n  eraseLine?: number[][]\n  /**\n   * (optional) The current user's id, used to identify the user.\n   */\n  userId?: string\n  /**\n   * (optional) An object of custom theme colors.\n   */\n  theme?: Partial<TLTheme>\n  /**\n   * (optional) When true, the renderer will not show the bounds for selected objects.\n   */\n  hideBounds?: boolean\n  /**\n   * (optional) When true, the renderer will not show the handles of shapes with handles.\n   */\n  hideHandles?: boolean\n  /**\n   * (optional) When true, the renderer will not show resize handles for selected objects.\n   */\n  hideResizeHandles?: boolean\n  /**\n   * (optional) When true, the renderer will not show rotate handles for selected objects.\n   */\n  hideRotateHandles?: boolean\n  /**\n   * (optional) When true, the renderer will not show buttons for cloning shapes.\n   */\n  hideCloneHandles?: boolean\n  /**\n   * (optional) When true, the renderer will not show binding controls.\n   */\n  hideBindingHandles?: boolean\n  /**\n   * (optional) When true, the renderer will not show indicators for selected or\n   * hovered objects,\n   */\n  hideIndicators?: boolean\n  /**\n   * (optional) When true, the renderer will not show the grid.\n   */\n  hideGrid?: boolean\n  /**\n   * (optional) When true, the renderer will show a dashed brush.\n   */\n  showDashedBrush?: boolean\n  /**\n   * (optional) The size of the grid step.\n   */\n  grid?: number\n  /**\n   * (optional) Use a performance mode.\n   */\n  performanceMode?: TLPerformanceMode\n  /**\n   * (optional) A callback that receives the renderer's inputs manager.\n   */\n  onMount?: (inputs: Inputs) => void\n  /**\n   * (optional) A callback that is fired when the editor's client bounding box changes.\n   */\n  onBoundsChange?: (bounds: TLBounds) => void\n}\n\n/**\n * The Renderer component is the main component of the library. It\n * accepts the current `page`, the `shapeUtils` needed to interpret\n * and render the shapes and bindings on the `page`, and the current\n * `pageState`.\n * @param props\n * @returns\n */\nfunction _Renderer<T extends TLShape, M extends Record<string, unknown>>({\n  id = 'tl',\n  shapeUtils,\n  page,\n  pageState,\n  assets = EMPTY_OBJECT,\n  users,\n  userId,\n  theme,\n  meta,\n  snapLines,\n  eraseLine,\n  grid,\n  containerRef,\n  performanceMode,\n  components,\n  hideHandles = false,\n  hideIndicators = false,\n  hideCloneHandles = false,\n  hideBindingHandles = false,\n  hideResizeHandles = false,\n  hideRotateHandles = false,\n  hideBounds = false,\n  hideGrid = true,\n  showDashedBrush = false,\n  hideCursors,\n  ...rest\n}: RendererProps<T, M>) {\n  useTLTheme(theme, '#' + id)\n\n  const rSelectionBounds = React.useRef<TLBounds>(null)\n\n  const rPageState = React.useRef<TLPageState>(pageState)\n\n  React.useEffect(() => {\n    rPageState.current = pageState\n  }, [pageState])\n\n  const [context, setContext] = React.useState<TLContextType<T>>(() => ({\n    callbacks: rest,\n    shapeUtils,\n    rSelectionBounds,\n    rPageState,\n    bounds: {\n      minX: 0,\n      minY: 0,\n      maxX: Infinity,\n      maxY: Infinity,\n      width: Infinity,\n      height: Infinity,\n    },\n    inputs: new Inputs(),\n  }))\n\n  const onBoundsChange = React.useCallback((bounds: TLBounds) => {\n    setContext((context) => ({\n      ...context,\n      bounds,\n    }))\n  }, [])\n\n  return (\n    <TLContext.Provider value={context as unknown as TLContextType<TLShape>}>\n      <Canvas\n        id={id}\n        page={page}\n        pageState={pageState}\n        assets={assets}\n        snapLines={snapLines}\n        eraseLine={eraseLine}\n        grid={grid}\n        users={users}\n        userId={userId}\n        externalContainerRef={containerRef}\n        hideBounds={hideBounds}\n        hideIndicators={hideIndicators}\n        hideHandles={hideHandles}\n        hideCloneHandles={hideCloneHandles}\n        hideBindingHandles={hideBindingHandles}\n        hideRotateHandle={hideRotateHandles}\n        hideResizeHandles={hideResizeHandles}\n        hideGrid={hideGrid}\n        showDashedBrush={showDashedBrush}\n        onBoundsChange={onBoundsChange}\n        performanceMode={performanceMode}\n        components={components}\n        meta={meta}\n        hideCursors={hideCursors}\n      />\n    </TLContext.Provider>\n  )\n}\n\nexport const Renderer = React.memo(_Renderer)\n", "import * as React from 'react'\nimport { Brush } from '~components/Brush'\nimport { Cursor, CursorComponent } from '~components/Cursor'\nimport { EraseLine } from '~components/EraseLine'\nimport { Grid } from '~components/Grid'\nimport { Overlay } from '~components/Overlay'\nimport { Page } from '~components/Page'\nimport { SnapLines } from '~components/SnapLines/SnapLines'\nimport { Users } from '~components/Users'\nimport { UsersIndicators } from '~components/UsersIndicators'\nimport {\n  useCameraCss,\n  useCanvasEvents,\n  useKeyEvents,\n  usePerformanceCss,\n  usePreventNavigationCss,\n  useSafariFocusOutFix,\n  useZoomEvents,\n} from '~hooks'\nimport { useResizeObserver } from '~hooks/useResizeObserver'\nimport type {\n  TLAssets,\n  TLBinding,\n  TLBounds,\n  TLPage,\n  TLPageState,\n  TLPerformanceMode,\n  TLShape,\n  TLSnapLine,\n  TLUsers,\n} from '~types'\n\nexport interface CanvasProps<T extends TLShape, M extends Record<string, unknown>> {\n  page: TLPage<T, TLBinding>\n  pageState: TLPageState\n  assets: TLAssets\n  snapLines?: TLSnapLine[]\n  eraseLine?: number[][]\n  grid?: number\n  users?: TLUsers\n  userId?: string\n  hideBounds: boolean\n  hideHandles: boolean\n  hideIndicators: boolean\n  hideBindingHandles: boolean\n  hideCloneHandles: boolean\n  hideResizeHandles: boolean\n  hideRotateHandle: boolean\n  hideGrid: boolean\n  showDashedBrush: boolean\n  externalContainerRef?: React.RefObject<HTMLElement>\n  performanceMode?: TLPerformanceMode\n  components?: {\n    Cursor?: CursorComponent\n  }\n  meta?: M\n  id?: string\n  onBoundsChange: (bounds: TLBounds) => void\n  hideCursors?: boolean\n}\n\nfunction _Canvas<T extends TLShape, M extends Record<string, unknown>>({\n  id,\n  page,\n  pageState,\n  assets,\n  snapLines,\n  eraseLine,\n  grid,\n  users,\n  userId,\n  components = {},\n  meta,\n  performanceMode,\n  showDashedBrush,\n  hideHandles,\n  hideBounds,\n  hideIndicators,\n  hideBindingHandles,\n  hideCloneHandles,\n  hideResizeHandles,\n  hideRotateHandle,\n  hideGrid,\n  onBoundsChange,\n  hideCursors,\n}: CanvasProps<T, M>) {\n  const rCanvas = React.useRef<HTMLDivElement>(null)\n\n  const rZoomRef = React.useRef(pageState.camera.zoom)\n\n  rZoomRef.current = pageState.camera.zoom\n\n  useZoomEvents(rZoomRef, rCanvas)\n\n  useResizeObserver(rCanvas, onBoundsChange)\n\n  useSafariFocusOutFix()\n\n  usePreventNavigationCss(rCanvas)\n\n  const rContainer = React.useRef<HTMLDivElement>(null)\n\n  const rLayer = React.useRef<HTMLDivElement>(null)\n\n  useCameraCss(rLayer, rContainer, pageState)\n\n  usePerformanceCss(performanceMode, rContainer)\n\n  useKeyEvents()\n\n  const events = useCanvasEvents()\n\n  return (\n    <div id={id} className=\"tl-container\" ref={rContainer}>\n      <div id=\"canvas\" className=\"tl-absolute tl-canvas\" ref={rCanvas} {...events}>\n        {!hideGrid && grid && <Grid grid={grid} camera={pageState.camera} />}\n        <div ref={rLayer} className=\"tl-absolute tl-layer\" data-testid=\"layer\">\n          <Page\n            page={page}\n            pageState={pageState}\n            assets={assets}\n            hideBounds={hideBounds}\n            hideIndicators={hideIndicators}\n            hideHandles={hideHandles}\n            hideBindingHandles={hideBindingHandles}\n            hideCloneHandles={hideCloneHandles}\n            hideResizeHandles={hideResizeHandles}\n            hideRotateHandle={hideRotateHandle}\n            meta={meta}\n          />\n          {users && userId && (\n            <UsersIndicators userId={userId} users={users} page={page} meta={meta} />\n          )}\n          {pageState.brush && (\n            <Brush brush={pageState.brush} dashed={showDashedBrush} zoom={pageState.camera.zoom} />\n          )}\n          {users && !hideCursors && (\n            <Users userId={userId} users={users} Cursor={components?.Cursor ?? Cursor} />\n          )}\n        </div>\n        <Overlay camera={pageState.camera}>\n          {eraseLine && <EraseLine points={eraseLine} zoom={pageState.camera.zoom} />}\n          {snapLines && <SnapLines snapLines={snapLines} />}\n        </Overlay>\n      </div>\n    </div>\n  )\n}\n\nexport const Canvas = React.memo(_Canvas)\n", "import * as React from 'react'\nimport { SVGContainer } from '~components'\nimport { Container } from '~components/Container'\nimport type { TLBounds } from '~types'\nimport Utils from '~utils'\n\nexport interface BrushProps {\n  brush: TLBounds\n  zoom: number\n  dashed: boolean | null | undefined\n}\n\nfunction _Brush({ brush, zoom, dashed }: BrushProps) {\n  return (\n    <Container bounds={brush} rotation={0}>\n      <SVGContainer>\n        <rect\n          className={'tl-brush' + (dashed ? ' dashed' : '')}\n          opacity={1}\n          x={0}\n          y={0}\n          width={brush.width}\n          height={brush.height}\n          aria-label=\"brush\"\n        />\n        {dashed && (\n          <g className=\"tl-dashed-brush-line\">\n            <PerfectDashLine x1={0} y1={0} x2={brush.width} y2={0} zoom={zoom} />\n            <PerfectDashLine\n              x1={brush.width}\n              y1={0}\n              x2={brush.width}\n              y2={brush.height}\n              zoom={zoom}\n            />\n            <PerfectDashLine\n              x1={0}\n              y1={brush.height}\n              x2={brush.width}\n              y2={brush.height}\n              zoom={zoom}\n            />\n            <PerfectDashLine x1={0} y1={0} x2={0} y2={brush.height} zoom={zoom} />\n          </g>\n        )}\n      </SVGContainer>\n    </Container>\n  )\n}\n\nexport const Brush = React.memo(_Brush)\n\ninterface PerfectDashLineProps {\n  x1: number\n  y1: number\n  x2: number\n  y2: number\n  zoom: number\n}\n\nfunction PerfectDashLine({ x1, y1, x2, y2, zoom }: PerfectDashLineProps) {\n  const dash = Utils.getPerfectDashProps(\n    Math.hypot(x2 - x1, y2 - y1),\n    1 / zoom,\n    'dashed',\n    1,\n    true,\n    3\n  )\n  return (\n    <line\n      x1={x1}\n      y1={y1}\n      x2={x2}\n      y2={y2}\n      strokeWidth={1 / zoom}\n      strokeDasharray={dash.strokeDasharray}\n      strokeDashoffset={dash.strokeDashoffset}\n    />\n  )\n}\n", "import * as React from 'react'\nimport type { HTMLProps } from 'react'\nimport { usePosition } from '~hooks'\nimport type { TLBounds } from '~types'\n\nexport interface ContainerProps extends HTMLProps<HTMLDivElement> {\n  id?: string\n  bounds: TLBounds\n  rotation?: number\n  isGhost?: boolean\n  isSelected?: boolean\n  children: React.ReactNode\n}\n\nfunction _Container({\n  id,\n  bounds,\n  rotation = 0,\n  isGhost = false,\n  isSelected = false,\n  children,\n  ...props\n}: ContainerProps) {\n  const rPositioned = usePosition(bounds, rotation)\n\n  return (\n    <div\n      id={id}\n      ref={rPositioned}\n      className={`tl-positioned${isGhost ? ' tl-ghost' : ''}${\n        isSelected ? ` tl-positioned-selected` : ''\n      }`}\n      aria-label=\"container\"\n      data-testid=\"container\"\n      {...props}\n    >\n      {children}\n    </div>\n  )\n}\n\nexport const Container = React.memo(_Container)\n", "import * as React from 'react'\nimport type { TLShapeUtilsMap } from '~TLShapeUtil'\nimport type { Inputs } from '~inputs'\nimport type { TLBounds, TLCallbacks, TLPageState, TLShape } from '~types'\n\nexport interface TLContextType<T extends TLShape> {\n  id?: string\n  callbacks: Partial<TLCallbacks<T>>\n  shapeUtils: TLShapeUtilsMap<T>\n  rPageState: React.MutableRefObject<TLPageState>\n  rSelectionBounds: React.MutableRefObject<TLBounds | null>\n  inputs: Inputs\n  bounds: TLBounds\n}\n\nexport const TLContext = React.createContext({} as TLContextType<TLShape>)\n\nexport function useTLContext() {\n  const context = React.useContext(TLContext)\n\n  return context\n}\n", "import { Vec } from '@tldraw/vec'\nimport { Handler, WebKitGestureEvent, useGesture } from '@use-gesture/react'\nimport * as React from 'react'\nimport Utils from '~utils'\nimport { useTLContext } from './useTLContext'\n\n// Capture zoom gestures (pinches, wheels and pans)\nexport function useZoomEvents<T extends HTMLElement>(\n  zoomRef: React.RefObject<number>,\n  ref: React.RefObject<T>\n) {\n  const rOriginPoint = React.useRef<number[] | undefined>(undefined)\n  const rPinchPoint = React.useRef<number[] | undefined>(undefined)\n  const rDelta = React.useRef<number[]>([0, 0])\n  const rWheelLastTimeStamp = React.useRef<number>(0)\n\n  const { inputs, bounds, callbacks } = useTLContext()\n\n  React.useEffect(() => {\n    const preventGesture = (event: TouchEvent) => event.preventDefault()\n    // @ts-ignore\n    document.addEventListener('gesturestart', preventGesture)\n    // @ts-ignore\n    document.addEventListener('gesturechange', preventGesture)\n    return () => {\n      // @ts-ignore\n      document.removeEventListener('gesturestart', preventGesture)\n      // @ts-ignore\n      document.removeEventListener('gesturechange', preventGesture)\n    }\n  }, [])\n\n  const handleWheel = React.useCallback<Handler<'wheel', WheelEvent>>(\n    ({ event: e }) => {\n      e.preventDefault()\n      if (inputs.isPinching || e.timeStamp <= rWheelLastTimeStamp.current) return\n\n      rWheelLastTimeStamp.current = e.timeStamp\n\n      const [x, y, z] = normalizeWheel(e)\n\n      // alt+scroll or ctrl+scroll = zoom (when not clicking)\n      if ((e.altKey || e.ctrlKey || e.metaKey) && e.buttons === 0) {\n        const point = inputs.pointer?.point ?? [bounds.width / 2, bounds.height / 2]\n        const delta = [...point, z * 0.618]\n        const info = inputs.pan(delta, e)\n\n        callbacks.onZoom?.({ ...info, delta }, e)\n        return\n      }\n\n      // otherwise pan\n      const delta = Vec.mul(\n        e.shiftKey && !Utils.isDarwin()\n          ? // shift+scroll = pan horizontally\n            [y, 0]\n          : // scroll = pan vertically (or in any direction on a trackpad)\n            [x, y],\n        0.5\n      )\n\n      if (Vec.isEqual(delta, [0, 0])) return\n\n      const info = inputs.pan(delta, e)\n\n      callbacks.onPan?.(info, e)\n    },\n    [callbacks, inputs, bounds]\n  )\n\n  const handlePinchStart = React.useCallback<\n    Handler<'pinch', WheelEvent | PointerEvent | TouchEvent | WebKitGestureEvent>\n  >(\n    ({ origin, event }) => {\n      if (event instanceof WheelEvent) return\n\n      const elm = ref.current\n      if (!elm || !(event.target === elm || elm.contains(event.target as Node))) return\n      const info = inputs.pinch(origin, origin)\n      inputs.isPinching = true\n      callbacks.onPinchStart?.(info, event)\n      rPinchPoint.current = info.point\n      rOriginPoint.current = info.origin\n      rDelta.current = [0, 0]\n    },\n    [callbacks, inputs, bounds]\n  )\n\n  const handlePinch = React.useCallback<\n    Handler<'pinch', WheelEvent | PointerEvent | TouchEvent | WebKitGestureEvent>\n  >(\n    ({ origin, offset, event }) => {\n      if (event instanceof WheelEvent) return\n\n      const elm = ref.current\n      if (!(event.target === elm || elm?.contains(event.target as Node))) return\n      if (!rOriginPoint.current) return\n      const info = inputs.pinch(origin, rOriginPoint.current)\n      const trueDelta = Vec.sub(info.delta, rDelta.current)\n      rDelta.current = info.delta\n\n      callbacks.onPinch?.(\n        {\n          ...info,\n          point: info.point,\n          origin: rOriginPoint.current,\n          delta: [...trueDelta, offset[0]],\n        },\n        event\n      )\n      rPinchPoint.current = origin\n    },\n    [callbacks, inputs, bounds]\n  )\n\n  const handlePinchEnd = React.useCallback<\n    Handler<'pinch', WheelEvent | PointerEvent | TouchEvent | WebKitGestureEvent>\n  >(({ origin, event }) => {\n    const elm = ref.current\n    if (!(event.target === elm || elm?.contains(event.target as Node))) return\n    const info = inputs.pinch(origin, origin)\n    inputs.isPinching = false\n    callbacks.onPinchEnd?.(info, event)\n    rPinchPoint.current = undefined\n    rOriginPoint.current = undefined\n    rDelta.current = [0, 0]\n  }, [])\n\n  useGesture(\n    {\n      onWheel: handleWheel,\n      onPinchStart: handlePinchStart,\n      onPinch: handlePinch,\n      onPinchEnd: handlePinchEnd,\n    },\n    {\n      target: ref,\n      eventOptions: { passive: false },\n      pinch: {\n        from: [zoomRef.current!, 0],\n        scaleBounds: () => {\n          return { from: zoomRef.current!, max: 5, min: 0.1 }\n        },\n      },\n    }\n  )\n}\n\n// Reasonable defaults\nconst MAX_ZOOM_STEP = 10\n\n// Adapted from https://stackoverflow.com/a/13650579\nfunction normalizeWheel(event: WheelEvent) {\n  const { deltaY, deltaX } = event\n\n  let deltaZ = 0\n\n  if (event.ctrlKey || event.metaKey) {\n    const signY = Math.sign(event.deltaY)\n    const absDeltaY = Math.abs(event.deltaY)\n\n    let dy = deltaY\n\n    if (absDeltaY > MAX_ZOOM_STEP) {\n      dy = MAX_ZOOM_STEP * signY\n    }\n\n    deltaZ = dy\n  }\n\n  return [deltaX, deltaY, deltaZ]\n}\n", "/* eslint-disable @typescript-eslint/no-extra-semi */\nimport { Vec } from '@tldraw/vec'\nimport { StrokePoint } from 'perfect-freehand'\nimport type React from 'react'\nimport type { Patch, TLBoundsWithCenter } from '~index'\nimport { Snap, SnapPoints, TLBounds, TLBoundsCorner, TLBoundsEdge } from '~types'\nimport './polyfills'\n\nconst TAU = Math.PI * 2\n\nexport class Utils {\n  /* -------------------------------------------------- */\n  /*                    Math & Geometry                 */\n  /* -------------------------------------------------- */\n\n  /**\n   * Linear interpolation betwen two numbers.\n   * @param y1\n   * @param y2\n   * @param mu\n   */\n  static lerp(y1: number, y2: number, mu: number): number {\n    mu = Utils.clamp(mu, 0, 1)\n    return y1 * (1 - mu) + y2 * mu\n  }\n\n  /**\n   * Linear interpolation between two colors.\n   *\n   * ### Example\n   *\n   *```ts\n   * lerpColor(\"#000000\", \"#0099FF\", .25)\n   *```\n   */\n\n  static lerpColor(color1: string, color2: string, factor = 0.5): string {\n    function h2r(hex: string) {\n      const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex)!\n      return [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)]\n    }\n\n    function r2h(rgb: number[]) {\n      return '#' + ((1 << 24) + (rgb[0] << 16) + (rgb[1] << 8) + rgb[2]).toString(16).slice(1)\n    }\n\n    const c1 = h2r(color1) || [0, 0, 0]\n    const c2 = h2r(color2) || [0, 0, 0]\n\n    const result = c1.slice()\n\n    for (let i = 0; i < 3; i++) {\n      result[i] = Math.round(result[i] + factor * (c2[i] - c1[i]))\n    }\n\n    return r2h(result)\n  }\n\n  /**\n   * Modulate a value between two ranges.\n   * @param value\n   * @param rangeA from [low, high]\n   * @param rangeB to [low, high]\n   * @param clamp\n   */\n  static modulate(value: number, rangeA: number[], rangeB: number[], clamp = false): number {\n    const [fromLow, fromHigh] = rangeA\n    const [v0, v1] = rangeB\n    const result = v0 + ((value - fromLow) / (fromHigh - fromLow)) * (v1 - v0)\n\n    return clamp\n      ? v0 < v1\n        ? Math.max(Math.min(result, v1), v0)\n        : Math.max(Math.min(result, v0), v1)\n      : result\n  }\n\n  /**\n   * Clamp a value into a range.\n   * @param n\n   * @param min\n   */\n  static clamp(n: number, min: number): number\n  static clamp(n: number, min: number, max: number): number\n  static clamp(n: number, min: number, max?: number): number {\n    return Math.max(min, typeof max !== 'undefined' ? Math.min(n, max) : n)\n  }\n\n  /**\n   * Recursively clone an object or array.\n   * @param obj\n   */\n  static deepClone<T>(obj: T): T {\n    if (obj === null) return obj\n\n    if (Array.isArray(obj)) {\n      return [...obj] as unknown as T\n    }\n\n    if (typeof obj === 'object') {\n      const clone = { ...(obj as Record<string, unknown>) }\n\n      Object.keys(clone).forEach(\n        (key) =>\n          (clone[key] =\n            typeof obj[key as keyof T] === 'object'\n              ? Utils.deepClone(obj[key as keyof T])\n              : obj[key as keyof T])\n      )\n\n      return clone as unknown as T\n    }\n\n    return obj\n  }\n\n  /**\n   * Seeded random number generator, using [xorshift](https://en.wikipedia.org/wiki/Xorshift).\n   * The result will always be betweeen -1 and 1.\n   *\n   * Adapted from [seedrandom](https://github.com/davidbau/seedrandom).\n   */\n  static rng(seed = ''): () => number {\n    let x = 0\n    let y = 0\n    let z = 0\n    let w = 0\n\n    function next() {\n      const t = x ^ (x << 11)\n      x = y\n      y = z\n      z = w\n      w ^= ((w >>> 19) ^ t ^ (t >>> 8)) >>> 0\n      return w / 0x100000000\n    }\n\n    for (let k = 0; k < seed.length + 64; k++) {\n      x ^= seed.charCodeAt(k) | 0\n      next()\n    }\n\n    return next\n  }\n\n  /* ---------------------- Boxes --------------------- */\n\n  static pointsToLineSegments(points: number[][], closed = false) {\n    const segments = []\n    for (let i = 1; i < points.length; i++) segments.push([points[i - 1], points[i]])\n    if (closed) segments.push([points[points.length - 1], points[0]])\n    return segments\n  }\n\n  static getRectangleSides(point: number[], size: number[], rotation = 0): [string, number[][]][] {\n    const center = [point[0] + size[0] / 2, point[1] + size[1] / 2]\n    const tl = Vec.rotWith(point, center, rotation)\n    const tr = Vec.rotWith(Vec.add(point, [size[0], 0]), center, rotation)\n    const br = Vec.rotWith(Vec.add(point, size), center, rotation)\n    const bl = Vec.rotWith(Vec.add(point, [0, size[1]]), center, rotation)\n\n    return [\n      ['top', [tl, tr]],\n      ['right', [tr, br]],\n      ['bottom', [br, bl]],\n      ['left', [bl, tl]],\n    ]\n  }\n\n  /* --------------- Circles and Angles --------------- */\n\n  /**\n   * Get a circle from three points.\n   * @param A\n   * @param B\n   * @param C\n   * @returns [x, y, r]\n   */\n  static circleFromThreePoints(A: number[], B: number[], C: number[]): number[] {\n    const [x1, y1] = A\n    const [x2, y2] = B\n    const [x3, y3] = C\n\n    const a = x1 * (y2 - y3) - y1 * (x2 - x3) + x2 * y3 - x3 * y2\n\n    const b =\n      (x1 * x1 + y1 * y1) * (y3 - y2) +\n      (x2 * x2 + y2 * y2) * (y1 - y3) +\n      (x3 * x3 + y3 * y3) * (y2 - y1)\n\n    const c =\n      (x1 * x1 + y1 * y1) * (x2 - x3) +\n      (x2 * x2 + y2 * y2) * (x3 - x1) +\n      (x3 * x3 + y3 * y3) * (x1 - x2)\n\n    const x = -b / (2 * a)\n\n    const y = -c / (2 * a)\n\n    return [x, y, Math.hypot(x - x1, y - y1)]\n  }\n\n  /**\n   * Find the approximate perimeter of an ellipse.\n   * @param rx\n   * @param ry\n   */\n  static perimeterOfEllipse(rx: number, ry: number): number {\n    const h = Math.pow(rx - ry, 2) / Math.pow(rx + ry, 2)\n    const p = Math.PI * (rx + ry) * (1 + (3 * h) / (10 + Math.sqrt(4 - 3 * h)))\n    return p\n  }\n\n  /**\n   * Get the short angle distance between two angles.\n   * @param a0\n   * @param a1\n   */\n  static shortAngleDist(a0: number, a1: number): number {\n    const max = Math.PI * 2\n    const da = (a1 - a0) % max\n    return ((2 * da) % max) - da\n  }\n\n  /**\n   * Get the long angle distance between two angles.\n   * @param a0\n   * @param a1\n   */\n  static longAngleDist(a0: number, a1: number): number {\n    return Math.PI * 2 - Utils.shortAngleDist(a0, a1)\n  }\n\n  /**\n   * Interpolate an angle between two angles.\n   * @param a0\n   * @param a1\n   * @param t\n   */\n  static lerpAngles(a0: number, a1: number, t: number): number {\n    return a0 + Utils.shortAngleDist(a0, a1) * t\n  }\n\n  /**\n   * Get the short distance between two angles.\n   * @param a0\n   * @param a1\n   */\n  static angleDelta(a0: number, a1: number): number {\n    return Utils.shortAngleDist(a0, a1)\n  }\n\n  /**\n   * Get the \"sweep\" or short distance between two points on a circle's perimeter.\n   * @param C\n   * @param A\n   * @param B\n   */\n  static getSweep(C: number[], A: number[], B: number[]): number {\n    return Utils.angleDelta(Vec.angle(C, A), Vec.angle(C, B))\n  }\n\n  /**\n   * Clamp radians within 0 and 2PI\n   * @param r\n   */\n  static clampRadians(r: number): number {\n    return (Math.PI * 2 + r) % (Math.PI * 2)\n  }\n\n  /**\n   * Clamp rotation to even segments.\n   * @param r\n   * @param segments\n   */\n  static snapAngleToSegments(r: number, segments: number): number {\n    const seg = (Math.PI * 2) / segments\n    return Math.floor((Utils.clampRadians(r) + seg / 2) / seg) * seg\n  }\n\n  /**\n   * Is angle c between angles a and b?\n   * @param a\n   * @param b\n   * @param c\n   */\n  static isAngleBetween(a: number, b: number, c: number): boolean {\n    if (c === a || c === b) return true\n\n    const AB = (b - a + TAU) % TAU\n    const AC = (c - a + TAU) % TAU\n    return AB <= Math.PI !== AC > AB\n  }\n\n  /**\n   * Convert degrees to radians.\n   * @param d\n   */\n  static degreesToRadians(d: number): number {\n    return (d * Math.PI) / 180\n  }\n\n  /**\n   * Convert radians to degrees.\n   * @param r\n   */\n  static radiansToDegrees(r: number): number {\n    return (r * 180) / Math.PI\n  }\n\n  /**\n   * Get the length of an arc between two points on a circle's perimeter.\n   * @param C\n   * @param r\n   * @param A\n   * @param B\n   */\n  static getArcLength(C: number[], r: number, A: number[], B: number[]): number {\n    const sweep = Utils.getSweep(C, A, B)\n    return r * (2 * Math.PI) * (sweep / (2 * Math.PI))\n  }\n\n  static getSweepFlag(A: number[], B: number[], C: number[]) {\n    const angleAC = Vec.angle(A, C)\n    const angleAB = Vec.angle(A, B)\n    const angleCAB = ((angleAB - angleAC + 3 * Math.PI) % (2 * Math.PI)) - Math.PI\n    return angleCAB > 0 ? 0 : 1\n  }\n\n  static getLargeArcFlag(A: number[], C: number[], P: number[]) {\n    const anglePA = Vec.angle(P, A)\n    const anglePC = Vec.angle(P, C)\n    const angleAPC = ((anglePC - anglePA + 3 * Math.PI) % (2 * Math.PI)) - Math.PI\n    return Math.abs(angleAPC) > Math.PI / 2 ? 0 : 1\n  }\n\n  /**\n   * Get a dash offset for an arc, based on its length.\n   * @param C\n   * @param r\n   * @param A\n   * @param B\n   * @param step\n   */\n  static getArcDashOffset(C: number[], r: number, A: number[], B: number[], step: number): number {\n    const del0 = Utils.getSweepFlag(C, A, B)\n    const len0 = Utils.getArcLength(C, r, A, B)\n    const off0 = del0 < 0 ? len0 : 2 * Math.PI * C[2] - len0\n    return -off0 / 2 + step\n  }\n\n  /**\n   * Get a dash offset for an ellipse, based on its length.\n   * @param A\n   * @param step\n   */\n  static getEllipseDashOffset(A: number[], step: number): number {\n    const c = 2 * Math.PI * A[2]\n    return -c / 2 + -step\n  }\n\n  /* -------------------- Hit Tests ------------------- */\n\n  /**\n   * Get whether a point is inside of a circle.\n   * @param A\n   * @param b\n   * @returns\n   */\n  static pointInCircle(A: number[], C: number[], r: number): boolean {\n    return Vec.dist(A, C) <= r\n  }\n\n  /**\n   * Get whether a point is inside of an ellipse.\n   * @param point\n   * @param center\n   * @param rx\n   * @param ry\n   * @param rotation\n   * @returns\n   */\n  static pointInEllipse(A: number[], C: number[], rx: number, ry: number, rotation = 0): boolean {\n    rotation = rotation || 0\n    const cos = Math.cos(rotation)\n    const sin = Math.sin(rotation)\n    const delta = Vec.sub(A, C)\n    const tdx = cos * delta[0] + sin * delta[1]\n    const tdy = sin * delta[0] - cos * delta[1]\n\n    return (tdx * tdx) / (rx * rx) + (tdy * tdy) / (ry * ry) <= 1\n  }\n\n  /**\n   * Get whether a point is inside of a rectangle.\n   * @param point\n   * @param size\n   */\n  static pointInRect(point: number[], size: number[]): boolean {\n    return !(\n      point[0] < size[0] ||\n      point[0] > point[0] + size[0] ||\n      point[1] < size[1] ||\n      point[1] > point[1] + size[1]\n    )\n  }\n\n  static pointInPolygon(p: number[], points: number[][]): boolean {\n    let wn = 0 // winding number\n\n    points.forEach((a, i) => {\n      const b = points[(i + 1) % points.length]\n      if (a[1] <= p[1]) {\n        if (b[1] > p[1] && Vec.cross(a, b, p) > 0) {\n          wn += 1\n        }\n      } else if (b[1] <= p[1] && Vec.cross(a, b, p) < 0) {\n        wn -= 1\n      }\n    })\n\n    return wn !== 0\n  }\n\n  /**\n   * Get whether a point is inside of a bounds.\n   * @param A The point to check.\n   * @param b The bounds to check.\n   * @returns\n   */\n  static pointInBounds(A: number[], b: TLBounds): boolean {\n    return !(A[0] < b.minX || A[0] > b.maxX || A[1] < b.minY || A[1] > b.maxY)\n  }\n\n  /**\n   * Hit test a point and a polyline using a minimum distance.\n   * @param A The point to check.\n   * @param points The points that make up the polyline.\n   * @param distance (optional) The mininum distance that qualifies a hit.\n   */\n  static pointInPolyline(A: number[], points: number[][], distance = 3): boolean {\n    for (let i = 1; i < points.length; i++) {\n      if (Vec.distanceToLineSegment(points[i - 1], points[i], A) < distance) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  /* --------------------- Bounds --------------------- */\n\n  static getBoundsSides(bounds: TLBounds): [string, number[][]][] {\n    return this.getRectangleSides([bounds.minX, bounds.minY], [bounds.width, bounds.height])\n  }\n\n  /**\n   * Expand a bounding box by a delta.\n   *\n   * ### Example\n   *\n   *```ts\n   * expandBounds(myBounds, [100, 100])\n   *```\n   */\n  static expandBounds(bounds: TLBounds, delta: number): TLBounds {\n    return {\n      minX: bounds.minX - delta,\n      minY: bounds.minY - delta,\n      maxX: bounds.maxX + delta,\n      maxY: bounds.maxY + delta,\n      width: bounds.width + delta * 2,\n      height: bounds.height + delta * 2,\n    }\n  }\n\n  /**\n   * Get whether two bounds collide.\n   * @param a Bounds\n   * @param b Bounds\n   * @returns\n   */\n  static boundsCollide(a: TLBounds, b: TLBounds): boolean {\n    return !(a.maxX < b.minX || a.minX > b.maxX || a.maxY < b.minY || a.minY > b.maxY)\n  }\n\n  /**\n   * Get whether the bounds of A contain the bounds of B. A perfect match will return true.\n   * @param a Bounds\n   * @param b Bounds\n   * @returns\n   */\n  static boundsContain(a: TLBounds, b: TLBounds): boolean {\n    return a.minX < b.minX && a.minY < b.minY && a.maxY > b.maxY && a.maxX > b.maxX\n  }\n\n  /**\n   * Get whether the bounds of A are contained by the bounds of B.\n   * @param a Bounds\n   * @param b Bounds\n   * @returns\n   */\n  static boundsContained(a: TLBounds, b: TLBounds): boolean {\n    return Utils.boundsContain(b, a)\n  }\n\n  /**\n   * Get whether two bounds are identical.\n   * @param a Bounds\n   * @param b Bounds\n   * @returns\n   */\n  static boundsAreEqual(a: TLBounds, b: TLBounds): boolean {\n    return !(b.maxX !== a.maxX || b.minX !== a.minX || b.maxY !== a.maxY || b.minY !== a.minY)\n  }\n\n  /**\n   * Find a bounding box from an array of points.\n   * @param points\n   * @param rotation (optional) The bounding box's rotation.\n   */\n  static getBoundsFromPoints(points: number[][], rotation = 0): TLBounds {\n    let minX = Infinity\n    let minY = Infinity\n    let maxX = -Infinity\n    let maxY = -Infinity\n\n    if (points.length < 2) {\n      minX = 0\n      minY = 0\n      maxX = 1\n      maxY = 1\n    } else {\n      for (const [x, y] of points) {\n        minX = Math.min(x, minX)\n        minY = Math.min(y, minY)\n        maxX = Math.max(x, maxX)\n        maxY = Math.max(y, maxY)\n      }\n    }\n\n    if (rotation !== 0) {\n      return Utils.getBoundsFromPoints(\n        points.map((pt) => Vec.rotWith(pt, [(minX + maxX) / 2, (minY + maxY) / 2], rotation))\n      )\n    }\n\n    return {\n      minX,\n      minY,\n      maxX,\n      maxY,\n      width: Math.max(1, maxX - minX),\n      height: Math.max(1, maxY - minY),\n    }\n  }\n\n  /**\n   * Center a bounding box around a given point.\n   * @param bounds\n   * @param center\n   */\n  static centerBounds(bounds: TLBounds, point: number[]): TLBounds {\n    const boundsCenter = this.getBoundsCenter(bounds)\n    const dx = point[0] - boundsCenter[0]\n    const dy = point[1] - boundsCenter[1]\n    return this.translateBounds(bounds, [dx, dy])\n  }\n\n  /**\n   * Snap a bounding box to a grid size.\n   * @param bounds\n   * @param gridSize\n   */\n  static snapBoundsToGrid(bounds: TLBounds, gridSize: number): TLBounds {\n    const minX = Math.round(bounds.minX / gridSize) * gridSize\n    const minY = Math.round(bounds.minY / gridSize) * gridSize\n    const maxX = Math.round(bounds.maxX / gridSize) * gridSize\n    const maxY = Math.round(bounds.maxY / gridSize) * gridSize\n    return {\n      minX,\n      minY,\n      maxX,\n      maxY,\n      width: Math.max(1, maxX - minX),\n      height: Math.max(1, maxY - minY),\n    }\n  }\n\n  /**\n   * Move a bounding box without recalculating it.\n   * @param bounds\n   * @param delta\n   * @returns\n   */\n  static translateBounds(bounds: TLBounds, delta: number[]): TLBounds {\n    return {\n      minX: bounds.minX + delta[0],\n      minY: bounds.minY + delta[1],\n      maxX: bounds.maxX + delta[0],\n      maxY: bounds.maxY + delta[1],\n      width: bounds.width,\n      height: bounds.height,\n    }\n  }\n\n  /**\n   * Rotate a bounding box.\n   * @param bounds\n   * @param center\n   * @param rotation\n   */\n  static rotateBounds(bounds: TLBounds, center: number[], rotation: number): TLBounds {\n    const [minX, minY] = Vec.rotWith([bounds.minX, bounds.minY], center, rotation)\n    const [maxX, maxY] = Vec.rotWith([bounds.maxX, bounds.maxY], center, rotation)\n\n    return {\n      minX,\n      minY,\n      maxX,\n      maxY,\n      width: bounds.width,\n      height: bounds.height,\n    }\n  }\n\n  /**\n   * Get the rotated bounds of an ellipse.\n   * @param x\n   * @param y\n   * @param rx\n   * @param ry\n   * @param rotation\n   */\n  static getRotatedEllipseBounds(\n    x: number,\n    y: number,\n    rx: number,\n    ry: number,\n    rotation = 0\n  ): TLBounds {\n    const c = Math.cos(rotation)\n    const s = Math.sin(rotation)\n    const w = Math.hypot(rx * c, ry * s)\n    const h = Math.hypot(rx * s, ry * c)\n\n    return {\n      minX: x + rx - w,\n      minY: y + ry - h,\n      maxX: x + rx + w,\n      maxY: y + ry + h,\n      width: w * 2,\n      height: h * 2,\n    }\n  }\n\n  /**\n   * Get a bounding box that includes two bounding boxes.\n   * @param a Bounding box\n   * @param b Bounding box\n   * @returns\n   */\n  static getExpandedBounds(a: TLBounds, b: TLBounds): TLBounds {\n    const minX = Math.min(a.minX, b.minX)\n    const minY = Math.min(a.minY, b.minY)\n    const maxX = Math.max(a.maxX, b.maxX)\n    const maxY = Math.max(a.maxY, b.maxY)\n    const width = Math.abs(maxX - minX)\n    const height = Math.abs(maxY - minY)\n\n    return { minX, minY, maxX, maxY, width, height }\n  }\n\n  /**\n   * Get the common bounds of a group of bounds.\n   * @returns\n   */\n  static getCommonBounds(bounds: TLBounds[]): TLBounds {\n    if (bounds.length < 2) return bounds[0]\n\n    let result = bounds[0]\n\n    for (let i = 1; i < bounds.length; i++) {\n      result = Utils.getExpandedBounds(result, bounds[i])\n    }\n\n    return result\n  }\n\n  static getRotatedCorners(b: TLBounds, rotation = 0): number[][] {\n    const center = [b.minX + b.width / 2, b.minY + b.height / 2]\n\n    return [\n      [b.minX, b.minY],\n      [b.maxX, b.minY],\n      [b.maxX, b.maxY],\n      [b.minX, b.maxY],\n    ].map((point) => Vec.rotWith(point, center, rotation))\n  }\n\n  static getTransformedBoundingBox(\n    bounds: TLBounds,\n    handle: TLBoundsCorner | TLBoundsEdge | 'center',\n    delta: number[],\n    rotation = 0,\n    isAspectRatioLocked = false\n  ): TLBounds & { scaleX: number; scaleY: number } {\n    // Create top left and bottom right corners.\n    const [ax0, ay0] = [bounds.minX, bounds.minY]\n    const [ax1, ay1] = [bounds.maxX, bounds.maxY]\n\n    // Create a second set of corners for the new box.\n    let [bx0, by0] = [bounds.minX, bounds.minY]\n    let [bx1, by1] = [bounds.maxX, bounds.maxY]\n\n    // If the drag is on the center, just translate the bounds.\n    if (handle === 'center') {\n      return {\n        minX: bx0 + delta[0],\n        minY: by0 + delta[1],\n        maxX: bx1 + delta[0],\n        maxY: by1 + delta[1],\n        width: bx1 - bx0,\n        height: by1 - by0,\n        scaleX: 1,\n        scaleY: 1,\n      }\n    }\n\n    // Counter rotate the delta. This lets us make changes as if\n    // the (possibly rotated) boxes were axis aligned.\n    const [dx, dy] = Vec.rot(delta, -rotation)\n\n    /*\n1. Delta\n\nUse the delta to adjust the new box by changing its corners.\nThe dragging handle (corner or edge) will determine which \ncorners should change.\n*/\n    switch (handle) {\n      case TLBoundsEdge.Top:\n      case TLBoundsCorner.TopLeft:\n      case TLBoundsCorner.TopRight: {\n        by0 += dy\n        break\n      }\n      case TLBoundsEdge.Bottom:\n      case TLBoundsCorner.BottomLeft:\n      case TLBoundsCorner.BottomRight: {\n        by1 += dy\n        break\n      }\n    }\n\n    switch (handle) {\n      case TLBoundsEdge.Left:\n      case TLBoundsCorner.TopLeft:\n      case TLBoundsCorner.BottomLeft: {\n        bx0 += dx\n        break\n      }\n      case TLBoundsEdge.Right:\n      case TLBoundsCorner.TopRight:\n      case TLBoundsCorner.BottomRight: {\n        bx1 += dx\n        break\n      }\n    }\n\n    const aw = ax1 - ax0\n    const ah = ay1 - ay0\n\n    const scaleX = (bx1 - bx0) / aw\n    const scaleY = (by1 - by0) / ah\n\n    const flipX = scaleX < 0\n    const flipY = scaleY < 0\n\n    const bw = Math.abs(bx1 - bx0)\n    const bh = Math.abs(by1 - by0)\n\n    /*\n2. Aspect ratio\n\nIf the aspect ratio is locked, adjust the corners so that the\nnew box's aspect ratio matches the original aspect ratio.\n*/\n\n    if (isAspectRatioLocked) {\n      const ar = aw / ah\n      const isTall = ar < bw / bh\n      const tw = bw * (scaleY < 0 ? 1 : -1) * (1 / ar)\n      const th = bh * (scaleX < 0 ? 1 : -1) * ar\n\n      switch (handle) {\n        case TLBoundsCorner.TopLeft: {\n          if (isTall) by0 = by1 + tw\n          else bx0 = bx1 + th\n          break\n        }\n        case TLBoundsCorner.TopRight: {\n          if (isTall) by0 = by1 + tw\n          else bx1 = bx0 - th\n          break\n        }\n        case TLBoundsCorner.BottomRight: {\n          if (isTall) by1 = by0 - tw\n          else bx1 = bx0 - th\n          break\n        }\n        case TLBoundsCorner.BottomLeft: {\n          if (isTall) by1 = by0 - tw\n          else bx0 = bx1 + th\n          break\n        }\n        case TLBoundsEdge.Bottom:\n        case TLBoundsEdge.Top: {\n          const m = (bx0 + bx1) / 2\n          const w = bh * ar\n          bx0 = m - w / 2\n          bx1 = m + w / 2\n          break\n        }\n        case TLBoundsEdge.Left:\n        case TLBoundsEdge.Right: {\n          const m = (by0 + by1) / 2\n          const h = bw / ar\n          by0 = m - h / 2\n          by1 = m + h / 2\n          break\n        }\n      }\n    }\n\n    /*\n3. Rotation\n\nIf the bounds are rotated, get a Vector from the rotated anchor\ncorner in the inital bounds to the rotated anchor corner in the\nresult's bounds. Subtract this Vector from the result's corners,\nso that the two anchor points (initial and result) will be equal.\n*/\n\n    if (rotation % (Math.PI * 2) !== 0) {\n      let cv = [0, 0]\n\n      const c0 = Vec.med([ax0, ay0], [ax1, ay1])\n      const c1 = Vec.med([bx0, by0], [bx1, by1])\n\n      switch (handle) {\n        case TLBoundsCorner.TopLeft: {\n          cv = Vec.sub(Vec.rotWith([bx1, by1], c1, rotation), Vec.rotWith([ax1, ay1], c0, rotation))\n          break\n        }\n        case TLBoundsCorner.TopRight: {\n          cv = Vec.sub(Vec.rotWith([bx0, by1], c1, rotation), Vec.rotWith([ax0, ay1], c0, rotation))\n          break\n        }\n        case TLBoundsCorner.BottomRight: {\n          cv = Vec.sub(Vec.rotWith([bx0, by0], c1, rotation), Vec.rotWith([ax0, ay0], c0, rotation))\n          break\n        }\n        case TLBoundsCorner.BottomLeft: {\n          cv = Vec.sub(Vec.rotWith([bx1, by0], c1, rotation), Vec.rotWith([ax1, ay0], c0, rotation))\n          break\n        }\n        case TLBoundsEdge.Top: {\n          cv = Vec.sub(\n            Vec.rotWith(Vec.med([bx0, by1], [bx1, by1]), c1, rotation),\n            Vec.rotWith(Vec.med([ax0, ay1], [ax1, ay1]), c0, rotation)\n          )\n          break\n        }\n        case TLBoundsEdge.Left: {\n          cv = Vec.sub(\n            Vec.rotWith(Vec.med([bx1, by0], [bx1, by1]), c1, rotation),\n            Vec.rotWith(Vec.med([ax1, ay0], [ax1, ay1]), c0, rotation)\n          )\n          break\n        }\n        case TLBoundsEdge.Bottom: {\n          cv = Vec.sub(\n            Vec.rotWith(Vec.med([bx0, by0], [bx1, by0]), c1, rotation),\n            Vec.rotWith(Vec.med([ax0, ay0], [ax1, ay0]), c0, rotation)\n          )\n          break\n        }\n        case TLBoundsEdge.Right: {\n          cv = Vec.sub(\n            Vec.rotWith(Vec.med([bx0, by0], [bx0, by1]), c1, rotation),\n            Vec.rotWith(Vec.med([ax0, ay0], [ax0, ay1]), c0, rotation)\n          )\n          break\n        }\n      }\n\n      ;[bx0, by0] = Vec.sub([bx0, by0], cv)\n      ;[bx1, by1] = Vec.sub([bx1, by1], cv)\n    }\n\n    /*\n4. Flips\n\nIf the axes are flipped (e.g. if the right edge has been dragged\nleft past the initial left edge) then swap points on that axis.\n*/\n\n    if (bx1 < bx0) {\n      ;[bx1, bx0] = [bx0, bx1]\n    }\n\n    if (by1 < by0) {\n      ;[by1, by0] = [by0, by1]\n    }\n\n    return {\n      minX: bx0,\n      minY: by0,\n      maxX: bx1,\n      maxY: by1,\n      width: bx1 - bx0,\n      height: by1 - by0,\n      scaleX: ((bx1 - bx0) / (ax1 - ax0 || 1)) * (flipX ? -1 : 1),\n      scaleY: ((by1 - by0) / (ay1 - ay0 || 1)) * (flipY ? -1 : 1),\n    }\n  }\n\n  static getTransformAnchor(\n    type: TLBoundsEdge | TLBoundsCorner,\n    isFlippedX: boolean,\n    isFlippedY: boolean\n  ): TLBoundsCorner | TLBoundsEdge {\n    let anchor: TLBoundsCorner | TLBoundsEdge = type\n\n    // Change corner anchors if flipped\n    switch (type) {\n      case TLBoundsCorner.TopLeft: {\n        if (isFlippedX && isFlippedY) {\n          anchor = TLBoundsCorner.BottomRight\n        } else if (isFlippedX) {\n          anchor = TLBoundsCorner.TopRight\n        } else if (isFlippedY) {\n          anchor = TLBoundsCorner.BottomLeft\n        } else {\n          anchor = TLBoundsCorner.BottomRight\n        }\n        break\n      }\n      case TLBoundsCorner.TopRight: {\n        if (isFlippedX && isFlippedY) {\n          anchor = TLBoundsCorner.BottomLeft\n        } else if (isFlippedX) {\n          anchor = TLBoundsCorner.TopLeft\n        } else if (isFlippedY) {\n          anchor = TLBoundsCorner.BottomRight\n        } else {\n          anchor = TLBoundsCorner.BottomLeft\n        }\n        break\n      }\n      case TLBoundsCorner.BottomRight: {\n        if (isFlippedX && isFlippedY) {\n          anchor = TLBoundsCorner.TopLeft\n        } else if (isFlippedX) {\n          anchor = TLBoundsCorner.BottomLeft\n        } else if (isFlippedY) {\n          anchor = TLBoundsCorner.TopRight\n        } else {\n          anchor = TLBoundsCorner.TopLeft\n        }\n        break\n      }\n      case TLBoundsCorner.BottomLeft: {\n        if (isFlippedX && isFlippedY) {\n          anchor = TLBoundsCorner.TopRight\n        } else if (isFlippedX) {\n          anchor = TLBoundsCorner.BottomRight\n        } else if (isFlippedY) {\n          anchor = TLBoundsCorner.TopLeft\n        } else {\n          anchor = TLBoundsCorner.TopRight\n        }\n        break\n      }\n    }\n\n    return anchor\n  }\n\n  /**\n   * Get the relative bounds (usually a child) within a transformed bounding box.\n   * @param bounds\n   * @param initialBounds\n   * @param initialShapeBounds\n   * @param isFlippedX\n   * @param isFlippedY\n   */\n  static getRelativeTransformedBoundingBox(\n    bounds: TLBounds,\n    initialBounds: TLBounds,\n    initialShapeBounds: TLBounds,\n    isFlippedX: boolean,\n    isFlippedY: boolean\n  ): TLBounds {\n    const nx =\n      (isFlippedX\n        ? initialBounds.maxX - initialShapeBounds.maxX\n        : initialShapeBounds.minX - initialBounds.minX) / initialBounds.width\n    const ny =\n      (isFlippedY\n        ? initialBounds.maxY - initialShapeBounds.maxY\n        : initialShapeBounds.minY - initialBounds.minY) / initialBounds.height\n    const nw = initialShapeBounds.width / initialBounds.width\n    const nh = initialShapeBounds.height / initialBounds.height\n\n    const minX = bounds.minX + bounds.width * nx\n    const minY = bounds.minY + bounds.height * ny\n    const width = bounds.width * nw\n    const height = bounds.height * nh\n\n    return {\n      minX,\n      minY,\n      maxX: minX + width,\n      maxY: minY + height,\n      width,\n      height,\n    }\n  }\n\n  /**\n   * Get the size of a rotated box.\n   * @param size : ;\n   * @param rotation\n   */\n  static getRotatedSize(size: number[], rotation: number): number[] {\n    const center = Vec.div(size, 2)\n\n    const points = [[0, 0], [size[0], 0], size, [0, size[1]]].map((point) =>\n      Vec.rotWith(point, center, rotation)\n    )\n\n    const bounds = Utils.getBoundsFromPoints(points)\n\n    return [bounds.width, bounds.height]\n  }\n\n  /**\n   * Get the center of a bounding box.\n   * @param bounds\n   */\n  static getBoundsCenter(bounds: TLBounds): number[] {\n    return [bounds.minX + bounds.width / 2, bounds.minY + bounds.height / 2]\n  }\n\n  /**\n   * Get a bounding box with a midX and midY.\n   * @param bounds\n   */\n  static getBoundsWithCenter(bounds: TLBounds): TLBoundsWithCenter {\n    const center = Utils.getBoundsCenter(bounds)\n    return {\n      ...bounds,\n      midX: center[0],\n      midY: center[1],\n    }\n  }\n\n  /**\n   * Given a set of points, get their common [minX, minY].\n   * @param points\n   */\n  static getCommonTopLeft(points: number[][]) {\n    const min = [Infinity, Infinity]\n\n    points.forEach((point) => {\n      min[0] = Math.min(min[0], point[0])\n      min[1] = Math.min(min[1], point[1])\n    })\n\n    return min\n  }\n\n  static getSnapPoints = (\n    bounds: TLBoundsWithCenter,\n    others: TLBoundsWithCenter[],\n    snapDistance: number\n  ) => {\n    const A = { ...bounds }\n\n    const offset = [0, 0]\n\n    const snapLines: number[][][] = []\n\n    // 1.\n    // Find the snap points for the x and y axes\n\n    const snaps: Record<SnapPoints, Snap> = {\n      [SnapPoints.minX]: { id: SnapPoints.minX, isSnapped: false },\n      [SnapPoints.midX]: { id: SnapPoints.midX, isSnapped: false },\n      [SnapPoints.maxX]: { id: SnapPoints.maxX, isSnapped: false },\n      [SnapPoints.minY]: { id: SnapPoints.minY, isSnapped: false },\n      [SnapPoints.midY]: { id: SnapPoints.midY, isSnapped: false },\n      [SnapPoints.maxY]: { id: SnapPoints.maxY, isSnapped: false },\n    }\n\n    const xs = [SnapPoints.midX, SnapPoints.minX, SnapPoints.maxX]\n    const ys = [SnapPoints.midY, SnapPoints.minY, SnapPoints.maxY]\n\n    const snapResults = others.map((B) => {\n      const rx = xs.flatMap((f, i) =>\n        xs.map((t, k) => {\n          const gap = A[f] - B[t]\n          const distance = Math.abs(gap)\n          return {\n            f,\n            t,\n            gap,\n            distance,\n            isCareful: i === 0 || i + k === 3,\n          }\n        })\n      )\n\n      const ry = ys.flatMap((f, i) =>\n        ys.map((t, k) => {\n          const gap = A[f] - B[t]\n          const distance = Math.abs(gap)\n          return {\n            f,\n            t,\n            gap,\n            distance,\n            isCareful: i === 0 || i + k === 3,\n          }\n        })\n      )\n\n      return [B, rx, ry] as const\n    })\n\n    let gapX = Infinity\n    let gapY = Infinity\n\n    let minX = Infinity\n    let minY = Infinity\n\n    snapResults.forEach(([_, rx, ry]) => {\n      rx.forEach((r) => {\n        if (r.distance < snapDistance && r.distance < minX) {\n          minX = r.distance\n          gapX = r.gap\n        }\n      })\n\n      ry.forEach((r) => {\n        if (r.distance < snapDistance && r.distance < minY) {\n          minY = r.distance\n          gapY = r.gap\n        }\n      })\n    })\n\n    // Check for other shapes with the same gap\n\n    snapResults.forEach(([B, rx, ry]) => {\n      if (gapX !== Infinity) {\n        rx.forEach((r) => {\n          if (Math.abs(r.gap - gapX) < 2) {\n            snaps[r.f] = {\n              ...snaps[r.f],\n              isSnapped: true,\n              to: B[r.t],\n              B,\n              distance: r.distance,\n            }\n          }\n        })\n      }\n\n      if (gapY !== Infinity) {\n        ry.forEach((r) => {\n          if (Math.abs(r.gap - gapY) < 2) {\n            snaps[r.f] = {\n              ...snaps[r.f],\n              isSnapped: true,\n              to: B[r.t],\n              B,\n              distance: r.distance,\n            }\n          }\n        })\n      }\n    })\n\n    offset[0] = gapX === Infinity ? 0 : gapX\n    offset[1] = gapY === Infinity ? 0 : gapY\n\n    A.minX -= offset[0]\n    A.midX -= offset[0]\n    A.maxX -= offset[0]\n    A.minY -= offset[1]\n    A.midY -= offset[1]\n    A.maxY -= offset[1]\n\n    // 2.\n    // Calculate snap lines based on adjusted bounds A. This has\n    // to happen after we've adjusted both dimensions x and y of\n    // the bounds A!\n    xs.forEach((from) => {\n      const snap = snaps[from]\n\n      if (!snap.isSnapped) return\n\n      const { id, B } = snap\n      const x = A[id]\n\n      // If A is snapped at its center, show include only the midY;\n      // otherwise, include both its minY and maxY.\n      snapLines.push(\n        id === SnapPoints.minX\n          ? [\n              [x, A.midY],\n              [x, B.minY],\n              [x, B.maxY],\n            ]\n          : [\n              [x, A.minY],\n              [x, A.maxY],\n              [x, B.minY],\n              [x, B.maxY],\n            ]\n      )\n    })\n\n    ys.forEach((from) => {\n      const snap = snaps[from]\n\n      if (!snap.isSnapped) return\n\n      const { id, B } = snap\n      const y = A[id]\n\n      snapLines.push(\n        id === SnapPoints.midY\n          ? [\n              [A.midX, y],\n              [B.minX, y],\n              [B.maxX, y],\n            ]\n          : [\n              [A.minX, y],\n              [A.maxX, y],\n              [B.minX, y],\n              [B.maxX, y],\n            ]\n      )\n    })\n\n    return { offset, snapLines }\n  }\n\n  /* -------------------------------------------------- */\n  /*                Lists and Collections               */\n  /* -------------------------------------------------- */\n\n  static deepMerge = <T>(target: T, patch: Patch<T>): T => {\n    const result: T = { ...target }\n\n    const entries = Object.entries(patch) as [keyof T, T[keyof T]][]\n\n    for (const [key, value] of entries)\n      result[key] =\n        value === Object(value) && !Array.isArray(value)\n          ? Utils.deepMerge(result[key], value)\n          : value\n\n    return result\n  }\n\n  /**\n   * Get a value from a cache (a WeakMap), filling the value if it is not present.\n   *\n   * ### Example\n   *\n   *```ts\n   * getFromCache(boundsCache, shape, (cache) => cache.set(shape, \"value\"))\n   *```\n   */\n  static getFromCache<V, I extends object>(cache: WeakMap<I, V>, item: I, getNext: () => V): V {\n    let value = cache.get(item)\n\n    if (value === undefined) {\n      cache.set(item, getNext())\n      value = cache.get(item)\n\n      if (value === undefined) {\n        throw Error('Cache did not include item!')\n      }\n    }\n\n    return value\n  }\n\n  /**\n   * Get a unique string id.\n   */\n  static uniqueId(a = ''): string {\n    return a\n      ? /* eslint-disable no-bitwise */\n        ((Number(a) ^ (Math.random() * 16)) >> (Number(a) / 4)).toString(16)\n      : `${1e7}-${1e3}-${4e3}-${8e3}-${1e11}`.replace(/[018]/g, Utils.uniqueId)\n  }\n\n  /**\n   * Shuffle the contents of an array.\n   * @param arr\n   * @param offset\n   */\n  static rotateArray<T>(arr: T[], offset: number): T[] {\n    return arr.map((_, i) => arr[(i + offset) % arr.length])\n  }\n\n  /**\n   * Debounce a function.\n   */\n  static debounce<T extends (...args: any[]) => void>(fn: T, ms = 0) {\n    let timeoutId: number | any\n    return function (...args: Parameters<T>) {\n      clearTimeout(timeoutId)\n      timeoutId = setTimeout(() => fn.apply(args), ms)\n    }\n  }\n\n  /**\n   * Turn an array of points into a path of quadradic curves.\n   *\n   * @param points The points returned from perfect-freehand\n   * @param closed Whether the stroke is closed\n   */\n  static getSvgPathFromStroke(points: number[][], closed = true): string {\n    const len = points.length\n\n    if (len < 4) {\n      return ``\n    }\n\n    let a = points[0]\n    let b = points[1]\n    const c = points[2]\n\n    let result = `M${a[0].toFixed(2)},${a[1].toFixed(2)} Q${b[0].toFixed(2)},${b[1].toFixed(\n      2\n    )} ${average(b[0], c[0]).toFixed(2)},${average(b[1], c[1]).toFixed(2)} T`\n\n    for (let i = 2, max = len - 1; i < max; i++) {\n      a = points[i]\n      b = points[i + 1]\n      result += `${average(a[0], b[0]).toFixed(2)},${average(a[1], b[1]).toFixed(2)} `\n    }\n\n    if (closed) {\n      result += 'Z'\n    }\n\n    return result\n  }\n\n  /**\n   * Turn an array of stroke points into a path of quadradic curves.\n   * @param points - the stroke points returned from perfect-freehand\n   */\n  static getSvgPathFromStrokePoints(points: StrokePoint[], closed = false): string {\n    const len = points.length\n\n    if (len < 4) {\n      return ``\n    }\n\n    let a = points[0].point\n    let b = points[1].point\n    const c = points[2].point\n\n    let result = `M${a[0].toFixed(2)},${a[1].toFixed(2)} Q${b[0].toFixed(2)},${b[1].toFixed(\n      2\n    )} ${average(b[0], c[0]).toFixed(2)},${average(b[1], c[1]).toFixed(2)} T`\n\n    for (let i = 2, max = len - 1; i < max; i++) {\n      a = points[i].point\n      b = points[i + 1].point\n      result += `${average(a[0], b[0]).toFixed(2)},${average(a[1], b[1]).toFixed(2)} `\n    }\n\n    if (closed) {\n      result += 'Z'\n    }\n\n    return result\n  }\n\n  /* -------------------------------------------------- */\n  /*                   Browser and DOM                  */\n  /* -------------------------------------------------- */\n\n  /**\n   * Get balanced dash-strokearray and dash-strokeoffset properties for a path of a given length.\n   * @param length The length of the path.\n   * @param strokeWidth The shape's stroke-width property.\n   * @param style The stroke's style: \"dashed\" or \"dotted\" (default \"dashed\").\n   * @param snap An interval for dashes (e.g. 4 will produce arrays with 4, 8, 16, etc dashes).\n   * @param outset Whether to outset the stroke (default false).\n   * @param lengthRatio The ratio to apply to dashed lines (default 2).\n   */\n  static getPerfectDashProps(\n    length: number,\n    strokeWidth: number,\n    style: 'dashed' | 'dotted' | string,\n    snap = 1,\n    outset = true,\n    lengthRatio = 2\n  ): {\n    strokeDasharray: string\n    strokeDashoffset: string\n  } {\n    let dashLength: number\n    let strokeDashoffset: string\n    let ratio: number\n\n    if (style.toLowerCase() === 'dashed') {\n      dashLength = strokeWidth * lengthRatio\n      ratio = 1\n      strokeDashoffset = outset ? (dashLength / 2).toString() : '0'\n    } else if (style.toLowerCase() === 'dotted') {\n      dashLength = strokeWidth / 100\n      ratio = 100\n      strokeDashoffset = '0'\n    } else {\n      return {\n        strokeDasharray: 'none',\n        strokeDashoffset: 'none',\n      }\n    }\n\n    let dashes = Math.floor(length / dashLength / (2 * ratio))\n\n    dashes -= dashes % snap\n\n    dashes = Math.max(dashes, 4)\n\n    const gapLength = Math.max(\n      dashLength,\n      (length - dashes * dashLength) / (outset ? dashes : dashes - 1)\n    )\n\n    return {\n      strokeDasharray: [dashLength, gapLength].join(' '),\n      strokeDashoffset,\n    }\n  }\n\n  static isMobileSafari() {\n    if (typeof window === 'undefined') return false\n    const ua = window.navigator.userAgent\n    const iOS = !!ua.match(/iPad/i) || !!ua.match(/iPhone/i)\n    const webkit = !!ua.match(/WebKit/i)\n    return iOS && webkit && !ua.match(/CriOS/i)\n  }\n\n  // via https://github.com/bameyrick/throttle-typescript\n  static throttle<T extends (...args: any) => any>(\n    func: T,\n    limit: number\n  ): (...args: Parameters<T>) => ReturnType<T> {\n    let inThrottle: boolean\n    let lastResult: ReturnType<T>\n\n    return function (this: any, ...args: any[]): ReturnType<T> {\n      if (!inThrottle) {\n        inThrottle = true\n\n        setTimeout(() => (inThrottle = false), limit)\n\n        // @ts-ignore\n        lastResult = func(...args)\n      }\n\n      return lastResult\n    }\n  }\n\n  /**\n   * Find whether the current display is a touch display.\n   */\n  // static isTouchDisplay(): boolean {\n  //   return (\n  //     'ontouchstart' in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0\n  //   )\n  // }\n\n  /**\n   * Find whether the current device is a Mac / iOS / iPadOS.\n   */\n  static isDarwin(): boolean {\n    return /Mac|iPod|iPhone|iPad/.test(window.navigator.platform)\n  }\n\n  /**\n   * Get whether an event is command (mac) or control (pc).\n   * @param e\n   */\n  static metaKey(e: KeyboardEvent | React.KeyboardEvent): boolean {\n    return Utils.isDarwin() ? e.metaKey : e.ctrlKey\n  }\n\n  /**\n   * Reversable psuedo hash.\n   * @param str string\n   */\n  static lns(str: string) {\n    const result = str.split('')\n    result.push(...result.splice(0, Math.round(result.length / 5)))\n    result.push(...result.splice(0, Math.round(result.length / 4)))\n    result.push(...result.splice(0, Math.round(result.length / 3)))\n    result.push(...result.splice(0, Math.round(result.length / 2)))\n    return result\n      .reverse()\n      .map((n) => (+n ? (+n < 5 ? 5 + +n : +n > 5 ? +n - 5 : n) : n))\n      .join('')\n  }\n}\n\nexport default Utils\n\nfunction average(a: number, b: number): number {\n  return (a + b) / 2\n}\n", "/* --------------------- Primary -------------------- */\nimport type React from 'react'\n\nexport enum TLPerformanceMode {\n  TransformSelected = 'transform_selected',\n  TranslateSelected = 'translate_selected',\n  TransformAll = 'transform_all',\n  TranslateAll = 'translate_all',\n}\n\nexport type TLAssets = Record<string, TLAsset>\n\nexport interface TLAsset {\n  id: string\n  type: string\n}\n\nexport type Patch<T> = Partial<{ [P in keyof T]: T | Partial<T> | Patch<T[P]> }>\n\nexport type TLForwardedRef<T> =\n  | ((instance: T | null) => void)\n  | React.MutableRefObject<T | null>\n  | null\n\nexport interface TLPage<T extends TLShape = TLShape, B extends TLBinding = TLBinding> {\n  id: string\n  name?: string\n  childIndex?: number\n  shapes: Record<string, T>\n  bindings: Record<string, B>\n}\n\nexport interface TLPageState {\n  id: string\n  selectedIds: string[]\n  camera: {\n    point: number[]\n    zoom: number\n  }\n  brush?: TLBounds | null\n  pointedId?: string | null\n  hoveredId?: string | null\n  editingId?: string | null\n  bindingId?: string | null\n}\n\nexport interface TLUser<T = any> {\n  id: string\n  color: string\n  point: number[]\n  selectedIds: string[]\n  session?: boolean\n  metadata?: T\n}\n\nexport type TLUsers = Record<string, TLUser>\n\nexport type TLSnapLine = number[][]\n\nexport interface TLHandle {\n  id: string\n  index: number\n  point: number[]\n}\n\nexport interface TLShape {\n  id: string\n  type: string\n  parentId: string\n  childIndex: number\n  name: string\n  point: number[]\n  assetId?: string\n  rotation?: number\n  children?: string[]\n  handles?: Record<string, TLHandle>\n  isGhost?: boolean\n  isHidden?: boolean\n  isLocked?: boolean\n  isGenerated?: boolean\n  isAspectRatioLocked?: boolean\n}\n\nexport interface TLComponentProps<T extends TLShape, E = any, M = any> {\n  shape: T\n  asset?: TLAsset\n  isEditing: boolean\n  isBinding: boolean\n  isHovered: boolean\n  isSelected: boolean\n  isGhost?: boolean\n  isChildOfSelected?: boolean\n  bounds: TLBounds\n  meta: M\n  onShapeChange?: TLShapeChangeHandler<T, any>\n  onShapeBlur?: TLShapeBlurHandler<any>\n  events: {\n    onPointerDown: (e: React.PointerEvent<E>) => void\n    onPointerUp: (e: React.PointerEvent<E>) => void\n    onPointerEnter: (e: React.PointerEvent<E>) => void\n    onPointerMove: (e: React.PointerEvent<E>) => void\n    onPointerLeave: (e: React.PointerEvent<E>) => void\n  }\n  ref?: React.Ref<E> | undefined\n}\n\nexport interface TLShapeProps<T extends TLShape, E = any, M = any>\n  extends TLComponentProps<T, E, M> {\n  ref: TLForwardedRef<E>\n  shape: T\n}\n\nexport interface TLBinding {\n  id: string\n  toId: string\n  fromId: string\n}\n\nexport interface TLTheme {\n  accent?: string\n  brushFill?: string\n  brushStroke?: string\n  brushDashStroke?: string\n  selectFill?: string\n  selectStroke?: string\n  binding: string\n  background?: string\n  foreground?: string\n  grid?: string\n}\n\nexport type TLWheelEventHandler = (\n  info: TLPointerInfo<string>,\n  e: React.WheelEvent<Element> | WheelEvent\n) => void\n\nexport type TLDropEventHandler = (e: React.DragEvent<Element>) => void\n\nexport type TLPinchEventHandler = (\n  info: TLPointerInfo<string>,\n  e:\n    | React.WheelEvent<Element>\n    | WheelEvent\n    | React.TouchEvent<Element>\n    | TouchEvent\n    | React.PointerEvent<Element>\n    | PointerEventInit\n) => void\n\nexport type TLShapeChangeHandler<T extends TLShape, K = any> = (\n  shape: { id: string } & Partial<T>,\n  info?: K\n) => void\n\nexport type TLShapeBlurHandler<K = any> = (info?: K) => void\n\nexport type TLKeyboardEventHandler = (key: string, info: TLKeyboardInfo, e: KeyboardEvent) => void\n\nexport type TLPointerEventHandler = (info: TLPointerInfo<string>, e: React.PointerEvent) => void\n\nexport type TLShapeCloneHandler = (\n  info: TLPointerInfo<\n    'top' | 'right' | 'bottom' | 'left' | 'topLeft' | 'topRight' | 'bottomLeft' | 'bottomRight'\n  >,\n  e: React.PointerEvent\n) => void\n\nexport type TLShapeLinkHandler = (info: TLPointerInfo<'link'>, e: React.PointerEvent) => void\n\nexport type TLCanvasEventHandler = (info: TLPointerInfo<'canvas'>, e: React.PointerEvent) => void\n\nexport type TLBoundsEventHandler = (info: TLPointerInfo<'bounds'>, e: React.PointerEvent) => void\n\nexport type TLBoundsHandleEventHandler = (\n  info: TLPointerInfo<TLBoundsHandle>,\n  e: React.PointerEvent\n) => void\n\nexport interface TLCallbacks<T extends TLShape> {\n  // Camera events\n  onPan: TLWheelEventHandler\n  onZoom: TLWheelEventHandler\n  onPinchStart: TLPinchEventHandler\n  onPinch: TLPinchEventHandler\n  onPinchEnd: TLPinchEventHandler\n\n  // Pointer Events\n  onPointerMove: TLPointerEventHandler\n  onPointerUp: TLPointerEventHandler\n  onPointerDown: TLPointerEventHandler\n\n  // Canvas (background)\n  onPointCanvas: TLCanvasEventHandler\n  onDoubleClickCanvas: TLCanvasEventHandler\n  onRightPointCanvas: TLCanvasEventHandler\n  onDragCanvas: TLCanvasEventHandler\n  onReleaseCanvas: TLCanvasEventHandler\n  onDragOver: TLDropEventHandler\n  onDrop: TLDropEventHandler\n\n  // Shape\n  onPointShape: TLPointerEventHandler\n  onDoubleClickShape: TLPointerEventHandler\n  onRightPointShape: TLPointerEventHandler\n  onDragShape: TLPointerEventHandler\n  onHoverShape: TLPointerEventHandler\n  onUnhoverShape: TLPointerEventHandler\n  onReleaseShape: TLPointerEventHandler\n\n  // Bounds (bounding box background)\n  onPointBounds: TLBoundsEventHandler\n  onDoubleClickBounds: TLBoundsEventHandler\n  onRightPointBounds: TLBoundsEventHandler\n  onDragBounds: TLBoundsEventHandler\n  onHoverBounds: TLBoundsEventHandler\n  onUnhoverBounds: TLBoundsEventHandler\n  onReleaseBounds: TLBoundsEventHandler\n\n  // Bounds handles (corners, edges)\n  onPointBoundsHandle: TLBoundsHandleEventHandler\n  onDoubleClickBoundsHandle: TLBoundsHandleEventHandler\n  onRightPointBoundsHandle: TLBoundsHandleEventHandler\n  onDragBoundsHandle: TLBoundsHandleEventHandler\n  onHoverBoundsHandle: TLBoundsHandleEventHandler\n  onUnhoverBoundsHandle: TLBoundsHandleEventHandler\n  onReleaseBoundsHandle: TLBoundsHandleEventHandler\n\n  // Handles (ie the handles of a selected arrow)\n  onPointHandle: TLPointerEventHandler\n  onDoubleClickHandle: TLPointerEventHandler\n  onRightPointHandle: TLPointerEventHandler\n  onDragHandle: TLPointerEventHandler\n  onHoverHandle: TLPointerEventHandler\n  onUnhoverHandle: TLPointerEventHandler\n  onReleaseHandle: TLPointerEventHandler\n\n  // Misc\n  onShapeChange: TLShapeChangeHandler<T, any>\n  onShapeBlur: TLShapeBlurHandler<any>\n  onShapeClone: TLShapeCloneHandler\n  onRenderCountChange: (ids: string[]) => void\n  onError: (error: Error) => void\n  onBoundsChange: (bounds: TLBounds) => void\n\n  // Keyboard event handlers\n  onKeyDown: TLKeyboardEventHandler\n  onKeyUp: TLKeyboardEventHandler\n}\n\nexport interface TLBounds {\n  minX: number\n  minY: number\n  maxX: number\n  maxY: number\n  width: number\n  height: number\n  rotation?: number\n}\n\nexport interface TLBoundsWithCenter extends TLBounds {\n  midX: number\n  midY: number\n}\n\nexport enum TLBoundsEdge {\n  Top = 'top_edge',\n  Right = 'right_edge',\n  Bottom = 'bottom_edge',\n  Left = 'left_edge',\n}\n\nexport enum TLBoundsCorner {\n  TopLeft = 'top_left_corner',\n  TopRight = 'top_right_corner',\n  BottomRight = 'bottom_right_corner',\n  BottomLeft = 'bottom_left_corner',\n}\n\nexport type TLBoundsHandle = TLBoundsCorner | TLBoundsEdge | 'rotate' | 'center' | 'left' | 'right'\n\nexport interface TLPointerInfo<T extends string = string> {\n  target: T\n  pointerId: number\n  origin: number[]\n  point: number[]\n  delta: number[]\n  pressure: number\n  shiftKey: boolean\n  ctrlKey: boolean\n  metaKey: boolean\n  altKey: boolean\n  spaceKey: boolean\n}\n\nexport interface TLKeyboardInfo {\n  origin: number[]\n  point: number[]\n  key: string\n  keys: string[]\n  shiftKey: boolean\n  ctrlKey: boolean\n  metaKey: boolean\n  altKey: boolean\n}\n\nexport interface TLTransformInfo<T extends TLShape> {\n  type: TLBoundsEdge | TLBoundsCorner\n  initialShape: T\n  scaleX: number\n  scaleY: number\n  transformOrigin: number[]\n}\n\n// TODO: Move snaps into its own repo\nexport enum SnapPoints {\n  minX = 'minX',\n  midX = 'midX',\n  maxX = 'maxX',\n  minY = 'minY',\n  midY = 'midY',\n  maxY = 'maxY',\n}\n\nexport type Snap =\n  | { id: SnapPoints; isSnapped: false }\n  | {\n      id: SnapPoints\n      isSnapped: true\n      to: number\n      B: TLBoundsWithCenter\n      distance: number\n    }\n\n/* -------------------- Internal -------------------- */\n\nexport interface IShapeTreeNode<T extends TLShape, M = any> {\n  shape: T\n  asset?: TLAsset\n  children?: IShapeTreeNode<TLShape, M>[]\n  isGhost: boolean\n  isChildOfSelected: boolean\n  isEditing: boolean\n  isBinding: boolean\n  isHovered: boolean\n  isSelected: boolean\n  meta?: M extends any ? M : never\n}\n\n/* -------------------------------------------------- */\n/*                    Utility Types                   */\n/* -------------------------------------------------- */\n\nexport type MappedByType<K extends string, T extends { type: K }> = {\n  [P in T['type']]: T extends any ? (P extends T['type'] ? T : never) : never\n}\n\nexport type RequiredKeys<T> = {\n  [K in keyof T]-?: Record<string, unknown> extends Pick<T, K> ? never : K\n}[keyof T]\n", "/**\n * String.prototype.replaceAll() polyfill\n * https://gomakethings.com/how-to-replace-a-section-of-a-string-with-another-one-with-vanilla-js/\n * @author Chris Ferdinandi\n * @license MIT\n */\nif (!String.prototype.replaceAll) {\n  // @ts-ignore\n  String.prototype.replaceAll = function (str: string, newStr: string) {\n    // If a regex pattern\n    if (Object.prototype.toString.call(str).toLowerCase() === '[object regexp]') {\n      return this.replace(str, newStr)\n    }\n\n    // If a string\n    return this.replace(new RegExp(str, 'g'), newStr)\n  }\n}\n", "import { Utils } from './utils'\n\nexport { Utils } from './utils'\n\nexport default Utils\n", "import { useEffect } from 'react'\nimport Utils from '~utils'\nimport { useTLContext } from './useTLContext'\n\n// Send event on iOS when a user presses the \"Done\" key while editing a text element.\n\nexport function useSafariFocusOutFix(): void {\n  const { callbacks } = useTLContext()\n\n  useEffect(() => {\n    function handleFocusOut() {\n      callbacks.onShapeBlur?.()\n    }\n\n    if (Utils.isMobileSafari()) {\n      document.addEventListener('focusout', handleFocusOut)\n      return () => document.removeEventListener('focusout', handleFocusOut)\n    }\n\n    return () => null\n  }, [callbacks])\n}\n", "import * as React from 'react'\nimport { useTLContext } from './useTLContext'\n\nexport function useCanvasEvents() {\n  const { callbacks, inputs } = useTLContext()\n\n  return React.useMemo(() => {\n    return {\n      onPointerDown: (e: React.PointerEvent) => {\n        if ((e as any).dead) return\n        else (e as any).dead = true\n        if (!inputs.pointerIsValid(e)) return\n\n        e.currentTarget.setPointerCapture(e.pointerId)\n\n        // On right click\n        if (e.button === 2) {\n          callbacks.onRightPointCanvas?.(inputs.pointerDown(e, 'canvas'), e)\n          return\n        }\n\n        const info = inputs.pointerDown(e, 'canvas')\n\n        // On left click down\n        if (e.button === 0) {\n          callbacks.onPointCanvas?.(info, e)\n        }\n\n        // On left or middle click down\n        callbacks.onPointerDown?.(info, e)\n      },\n      onPointerMove: (e: React.PointerEvent) => {\n        if ((e as any).dead) return\n        else (e as any).dead = true\n\n        if (!inputs.pointerIsValid(e)) return\n\n        const info = inputs.pointerMove(e, 'canvas')\n\n        // On left click drag\n        if (e.buttons === 1) {\n          if (e.currentTarget.hasPointerCapture(e.pointerId)) {\n            callbacks.onDragCanvas?.(info, e)\n          }\n        }\n\n        // On left or middle click drag\n        callbacks.onPointerMove?.(info, e)\n      },\n      onPointerUp: (e: React.PointerEvent) => {\n        if ((e as any).dead) return\n        else (e as any).dead = true\n\n        inputs.activePointer = undefined\n        if (!inputs.pointerIsValid(e)) return\n\n        const isDoubleClick = inputs.isDoubleClick()\n\n        const info = inputs.pointerUp(e, 'canvas')\n\n        // On right click up\n        if (e.button === 2) {\n          callbacks.onPointerUp?.(info, e)\n          return\n        }\n\n        // Release pointer capture, if any\n        if (e.currentTarget.hasPointerCapture(e.pointerId)) {\n          e.currentTarget?.releasePointerCapture(e.pointerId)\n        }\n\n        // On left click up\n        if (e.button === 0) {\n          if (isDoubleClick && !(info.altKey || info.metaKey)) {\n            callbacks.onDoubleClickCanvas?.(info, e)\n          }\n\n          callbacks.onReleaseCanvas?.(info, e)\n        }\n\n        // On left or middle click up\n        callbacks.onPointerUp?.(info, e)\n      },\n      onDrop: callbacks.onDrop,\n      onDragOver: callbacks.onDragOver,\n    }\n  }, [callbacks, inputs])\n}\n", "import * as React from 'react'\nimport { TLContext } from '~hooks'\nimport { Utils } from '~utils'\n\nexport function useShapeEvents(id: string) {\n  const { rPageState, rSelectionBounds, callbacks, inputs } = React.useContext(TLContext)\n\n  return React.useMemo(\n    () => ({\n      onPointerDown: (e: React.PointerEvent) => {\n        if ((e as any).dead) return\n        else (e as any).dead = true\n\n        if (!inputs.pointerIsValid(e)) return\n\n        // On right click\n        if (e.button === 2) {\n          callbacks.onRightPointShape?.(inputs.pointerDown(e, id), e)\n          return\n        }\n\n        const info = inputs.pointerDown(e, id)\n\n        e.currentTarget?.setPointerCapture(e.pointerId)\n\n        // If we click \"through\" the selection bounding box to hit a shape that isn't selected,\n        // treat the event as a bounding box click. Unfortunately there's no way I know to pipe\n        // the event to the actual bounds background element.\n        if (\n          rSelectionBounds.current &&\n          Utils.pointInBounds(info.point, rSelectionBounds.current) &&\n          !rPageState.current.selectedIds.includes(id)\n        ) {\n          // On left click through bounding box foreground\n          if (e.button === 0) {\n            callbacks.onPointBounds?.(inputs.pointerDown(e, 'bounds'), e)\n            callbacks.onPointShape?.(info, e)\n          }\n\n          // On left or middle click through bounding box foreground\n          callbacks.onPointerDown?.(info, e)\n          return\n        }\n\n        // On left click\n        if (e.button === 0) {\n          callbacks.onPointShape?.(info, e)\n        }\n\n        // On middle click or more\n        callbacks.onPointerDown?.(info, e)\n      },\n      onPointerUp: (e: React.PointerEvent) => {\n        if ((e as any).dead) return\n        else (e as any).dead = true\n        if (!inputs.pointerIsValid(e)) return\n\n        // On right clicks\n        if (e.button === 2) {\n          return\n        }\n\n        inputs.activePointer = undefined\n\n        const isDoubleClick = inputs.isDoubleClick()\n\n        const info = inputs.pointerUp(e, id)\n\n        // Release pointer capture, if any\n        if (e.pointerId && e.currentTarget.hasPointerCapture(e.pointerId)) {\n          e.currentTarget?.releasePointerCapture(e.pointerId)\n        }\n\n        // On left click up\n        if (e.button === 0) {\n          if (isDoubleClick && !(info.altKey || info.metaKey)) {\n            callbacks.onDoubleClickShape?.(info, e)\n          }\n          callbacks.onReleaseShape?.(info, e)\n        }\n\n        // On left or middle click up\n        callbacks.onPointerUp?.(info, e)\n      },\n      onPointerMove: (e: React.PointerEvent) => {\n        if ((e as any).dead) return\n        else (e as any).dead = true\n\n        // On right click drag\n        if (\n          e.buttons === 2 ||\n          !inputs.pointerIsValid(e) ||\n          (inputs.pointer && e.pointerId !== inputs.pointer.pointerId)\n        ) {\n          return\n        }\n\n        const info = inputs.pointerMove(e, id)\n\n        // On left click drag\n        if (e.buttons === 1 && e.currentTarget.hasPointerCapture(e.pointerId)) {\n          callbacks.onDragShape?.(info, e)\n        }\n\n        // Otherwise...\n        callbacks.onPointerMove?.(info, e)\n      },\n      onPointerEnter: (e: React.PointerEvent) => {\n        if (!inputs.pointerIsValid(e)) return\n        const info = inputs.pointerEnter(e, id)\n        callbacks.onHoverShape?.(info, e)\n      },\n      onPointerLeave: (e: React.PointerEvent) => {\n        if (!inputs.pointerIsValid(e)) return\n        const info = inputs.pointerEnter(e, id)\n        callbacks.onUnhoverShape?.(info, e)\n      },\n    }),\n    [inputs, callbacks, id]\n  )\n}\n", "import { Vec } from '@tldraw/vec'\nimport * as React from 'react'\nimport { useTLContext } from '~hooks'\nimport type {\n  IShapeTreeNode,\n  TLAssets,\n  TLBinding,\n  TLBounds,\n  TLPage,\n  TLPageState,\n  TLShape,\n} from '~types'\nimport { Utils } from '~utils'\n\nfunction addToShapeTree<T extends TLShape, M extends Record<string, unknown>>(\n  shape: T,\n  branch: IShapeTreeNode<T, M>[],\n  shapes: TLPage<T, TLBinding>['shapes'],\n  pageState: TLPageState,\n  assets: TLAssets,\n  isChildOfGhost = false,\n  isChildOfSelected = false,\n  meta?: M,\n  bindingTargetId?: string | null\n) {\n  // Create a node for this shape\n  const node: IShapeTreeNode<T, M> = {\n    shape,\n    asset: shape.assetId ? assets[shape.assetId] : undefined,\n    meta: meta as any,\n    isChildOfSelected,\n    isGhost: shape.isGhost || isChildOfGhost,\n    isEditing: pageState.editingId === shape.id,\n    isBinding: bindingTargetId === shape.id,\n    isSelected: pageState.selectedIds.includes(shape.id),\n    isHovered:\n      // The shape is hovered..\n      pageState.hoveredId === shape.id ||\n      // Or the shape has children and...\n      (shape.children !== undefined &&\n        // One of the children is hovered\n        ((pageState.hoveredId && shape.children.includes(pageState.hoveredId)) ||\n          // Or one of the children is selected\n          shape.children.some((childId) => pageState.selectedIds.includes(childId)))),\n  }\n\n  // Add the node to the branch\n  branch.push(node)\n\n  // If the shape has children, add nodes for each child to the node's children array\n  if (shape.children) {\n    node.children = []\n\n    shape.children\n      .map((id) => shapes[id])\n      .filter((childShape) => shapes[childShape.id]) // TODO: Find cases where shapes would be missing.\n      .sort((a, b) => a.childIndex - b.childIndex)\n      .forEach((childShape) =>\n        addToShapeTree(\n          childShape,\n          node.children!,\n          shapes,\n          pageState,\n          assets,\n          node.isGhost,\n          node.isSelected || node.isChildOfSelected,\n          meta\n        )\n      )\n  }\n}\n\nfunction shapeIsInViewport(bounds: TLBounds, viewport: TLBounds) {\n  return Utils.boundsContain(viewport, bounds) || Utils.boundsCollide(viewport, bounds)\n}\n\nexport function useShapeTree<T extends TLShape, M extends Record<string, unknown>>(\n  page: TLPage<T, TLBinding>,\n  pageState: TLPageState,\n  assets: TLAssets,\n  meta?: M\n) {\n  const { callbacks, shapeUtils, bounds } = useTLContext()\n\n  const rTimeout = React.useRef<unknown>()\n  const rPreviousCount = React.useRef(-1)\n  const rShapesIdsToRender = React.useRef(new Set<string>())\n  const rShapesToRender = React.useRef(new Set<TLShape>())\n\n  const { selectedIds, camera } = pageState\n\n  // Filter the page's shapes down to only those that:\n  // - are the direct child of the page\n  // - collide with or are contained by the viewport\n  // - OR are selected\n\n  const [minX, minY] = Vec.sub(Vec.div([0, 0], camera.zoom), camera.point)\n  const [maxX, maxY] = Vec.sub(Vec.div([bounds.width, bounds.height], camera.zoom), camera.point)\n  const viewport = {\n    minX,\n    minY,\n    maxX,\n    maxY,\n    height: maxX - minX,\n    width: maxY - minY,\n  }\n\n  const shapesToRender = rShapesToRender.current\n  const shapesIdsToRender = rShapesIdsToRender.current\n\n  shapesToRender.clear()\n  shapesIdsToRender.clear()\n\n  const allShapes = Object.values(page.shapes)\n\n  allShapes\n    .filter(\n      (shape) =>\n        // Always render shapes that are flagged as stateful\n        shapeUtils[shape.type as T['type']].isStateful ||\n        // Always render selected shapes (this preserves certain drag interactions)\n        selectedIds.includes(shape.id) ||\n        // Otherwise, only render shapes that are in view\n        shapeIsInViewport(shapeUtils[shape.type as T['type']].getBounds(shape as any), viewport)\n    )\n    .forEach((shape) => {\n      // If the shape's parent is the page, add it to our sets of shapes to render\n      if (shape.parentId === page.id) {\n        shapesIdsToRender.add(shape.id)\n        shapesToRender.add(shape)\n        return\n      }\n\n      // If the shape's parent is a different shape (e.g. a group),\n      // add the parent to the sets of shapes to render. The parent's\n      // children will all be rendered.\n      const parent = page.shapes[shape.parentId]\n\n      if (parent === undefined) {\n        throw Error(`A shape (${shape.id}) has a parent (${shape.parentId}) that does not exist!`)\n      } else {\n        shapesIdsToRender.add(parent.id)\n        shapesToRender.add(parent)\n      }\n    })\n\n  // Call onRenderCountChange callback when number of rendering shapes changes\n\n  if (shapesToRender.size !== rPreviousCount.current) {\n    // Use a timeout to clear call stack, in case the onChange handler\n    // produces a new state change, which could cause nested state\n    // changes, which is bad in React.\n    if (rTimeout.current) {\n      clearTimeout(rTimeout.current as number)\n    }\n    rTimeout.current = requestAnimationFrame(() => {\n      callbacks.onRenderCountChange?.(Array.from(shapesIdsToRender.values()))\n    })\n    rPreviousCount.current = shapesToRender.size\n  }\n\n  const bindingTargetId = pageState.bindingId ? page.bindings[pageState.bindingId].toId : undefined\n\n  // Populate the shape tree\n\n  const tree: IShapeTreeNode<T, M>[] = []\n\n  shapesToRender.forEach((shape) => {\n    if (shape === undefined) {\n      throw Error('Rendered shapes included a missing shape')\n    }\n\n    addToShapeTree(\n      shape,\n      tree,\n      page.shapes,\n      pageState,\n      assets,\n      shape.isGhost,\n      false,\n      meta,\n      bindingTargetId\n    )\n  })\n\n  tree.sort((a, b) => a.shape.childIndex - b.shape.childIndex)\n\n  return tree\n}\n", "import * as React from 'react'\nimport type { TLTheme } from '~types'\n\nconst styles = new Map<string, HTMLStyleElement>()\n\ntype AnyTheme = Record<string, string>\n\nfunction makeCssTheme<T = AnyTheme>(prefix: string, theme: T) {\n  return Object.keys(theme).reduce((acc, key) => {\n    const value = theme[key as keyof T]\n    if (value) {\n      return acc + `${`--${prefix}-${key}`}: ${value};\\n`\n    }\n    return acc\n  }, '')\n}\n\nfunction useTheme<T = AnyTheme>(prefix: string, theme: T, selector = ':root') {\n  React.useLayoutEffect(() => {\n    const style = document.createElement('style')\n    const cssTheme = makeCssTheme(prefix, theme)\n\n    style.setAttribute('id', `${prefix}-theme`)\n    style.setAttribute('data-selector', selector)\n    style.innerHTML = `\n        ${selector} {\n          ${cssTheme}\n        }\n      `\n\n    document.head.appendChild(style)\n\n    return () => {\n      if (style && document.head.contains(style)) {\n        document.head.removeChild(style)\n      }\n    }\n  }, [prefix, theme, selector])\n}\n\nfunction useStyle(uid: string, rules: string) {\n  React.useLayoutEffect(() => {\n    if (styles.get(uid)) {\n      return () => void null\n    }\n\n    const style = document.createElement('style')\n    style.innerHTML = rules\n    style.setAttribute('id', uid)\n    document.head.appendChild(style)\n    styles.set(uid, style)\n\n    return () => {\n      if (style && document.head.contains(style)) {\n        document.head.removeChild(style)\n        styles.delete(uid)\n      }\n    }\n  }, [uid, rules])\n}\n\nconst css = (strings: TemplateStringsArray, ...args: unknown[]) =>\n  strings.reduce(\n    (acc, string, index) => acc + string + (index < args.length ? args[index] : ''),\n    ''\n  )\n\nconst defaultTheme: TLTheme = {\n  accent: 'rgb(255, 0, 0)',\n  brushFill: 'rgba(0,0,0,.05)',\n  brushStroke: 'rgba(0,0,0,.25)',\n  brushDashStroke: 'rgba(0,0,0,.6)',\n  selectStroke: 'rgb(66, 133, 244)',\n  selectFill: 'rgba(65, 132, 244, 0.05)',\n  binding: 'rgba(65, 132, 244, 0.12)',\n  background: 'rgb(248, 249, 250)',\n  foreground: 'rgb(51, 51, 51)',\n  grid: 'rgba(144, 144, 144, 1)',\n}\n\nexport const TLCSS = css`\n  .tl-container {\n    --tl-zoom: 1;\n    --tl-scale: calc(1 / var(--tl-zoom));\n    --tl-padding: calc(64px * max(1, var(--tl-scale)));\n    --tl-performance-all: auto;\n    --tl-performance-selected: auto;\n    position: relative;\n    top: 0px;\n    left: 0px;\n    width: 100%;\n    height: 100%;\n    max-width: 100%;\n    max-height: 100%;\n    box-sizing: border-box;\n    padding: 0px;\n    margin: 0px;\n    z-index: 100;\n    overflow: hidden;\n    touch-action: none;\n    overscroll-behavior: none;\n    background-color: var(--tl-background);\n  }\n  .tl-container * {\n    box-sizing: border-box;\n  }\n  .tl-overlay {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    touch-action: none;\n    pointer-events: none;\n  }\n  .tl-grid {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    touch-action: none;\n    pointer-events: none;\n    user-select: none;\n  }\n  .tl-snap-line {\n    stroke: var(--tl-accent);\n    stroke-width: calc(1px * var(--tl-scale));\n  }\n  .tl-snap-point {\n    stroke: var(--tl-accent);\n    stroke-width: calc(1px * var(--tl-scale));\n  }\n  .tl-canvas {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    touch-action: none;\n    pointer-events: all;\n    overflow: clip;\n  }\n  .tl-layer {\n    position: absolute;\n    top: 0px;\n    left: 0px;\n    height: 0px;\n    width: 0px;\n    contain: layout style size;\n  }\n  .tl-absolute {\n    position: absolute;\n    top: 0px;\n    left: 0px;\n    transform-origin: center center;\n    contain: layout style size;\n  }\n  .tl-positioned {\n    position: absolute;\n    top: 0px;\n    left: 0px;\n    transform-origin: center center;\n    pointer-events: none;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    contain: layout style size;\n    will-change: var(--tl-performance-all);\n  }\n  .tl-positioned-svg {\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n    contain: layout style size;\n  }\n  .tl-positioned-div {\n    position: relative;\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n    padding: var(--tl-padding);\n    overflow: hidden;\n    contain: layout style size;\n  }\n  .tl-positioned-selected {\n    will-change: var(--tl-performance-selected);\n  }\n  .tl-inner-div {\n    position: relative;\n    width: 100%;\n    height: 100%;\n  }\n  .tl-stroke-hitarea {\n    fill: none;\n    stroke: transparent;\n    stroke-width: calc(24px * var(--tl-scale));\n    pointer-events: stroke;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n  }\n  .tl-fill-hitarea {\n    fill: transparent;\n    stroke: transparent;\n    stroke-width: calc(24px * var(--tl-scale));\n    pointer-events: all;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n  }\n  .tl-counter-scaled {\n    transform: scale(var(--tl-scale));\n  }\n  .tl-dashed {\n    stroke-dasharray: calc(2px * var(--tl-scale)), calc(2px * var(--tl-scale));\n  }\n  .tl-transparent {\n    fill: transparent;\n    stroke: transparent;\n  }\n  .tl-cursor-ns {\n    cursor: ns-resize;\n  }\n  .tl-cursor-ew {\n    cursor: ew-resize;\n  }\n  .tl-cursor-nesw {\n    cursor: nesw-resize;\n  }\n  .tl-cursor-nwse {\n    cursor: nwse-resize;\n  }\n  .tl-corner-handle {\n    stroke: var(--tl-selectStroke);\n    fill: var(--tl-background);\n    stroke-width: calc(1.5px * var(--tl-scale));\n  }\n  .tl-rotate-handle {\n    stroke: var(--tl-selectStroke);\n    fill: var(--tl-background);\n    stroke-width: calc(1.5px * var(--tl-scale));\n    cursor: grab;\n  }\n  .tl-binding {\n    fill: var(--tl-selectFill);\n    stroke: var(--tl-selectStroke);\n    stroke-width: calc(1px * var(--tl-scale));\n    pointer-events: none;\n  }\n  .tl-user {\n    left: calc(-15px * var(--tl-scale));\n    top: calc(-15px * var(--tl-scale));\n    height: calc(35px * var(--tl-scale));\n    width: calc(35px * var(--tl-scale));\n    transform: scale(var(--tl-scale));\n    pointer-events: none;\n    will-change: transform;\n  }\n  .tl-animated {\n    transition: transform 200ms linear;\n  }\n  .tl-indicator {\n    fill: transparent;\n    stroke-width: calc(1.5px * var(--tl-scale));\n    pointer-events: none;\n  }\n  .tl-user-indicator-bounds {\n    border-style: solid;\n    border-width: calc(1px * var(--tl-scale));\n  }\n  .tl-hovered {\n    stroke: var(--tl-selectStroke);\n  }\n  .tl-selected {\n    stroke: var(--tl-selectStroke);\n  }\n  .tl-locked {\n    stroke-dasharray: calc(3px * var(--tl-scale)) calc(3px * var(--tl-scale));\n  }\n  .tl-editing {\n    stroke-width: calc(2.5px * min(5, var(--tl-scale)));\n  }\n  .tl-performance {\n    will-change: transform, contents;\n  }\n  .tl-clone-target {\n    pointer-events: all;\n  }\n  .tl-clone-target:hover .tl-clone-button {\n    opacity: 1;\n  }\n  .tl-clone-button-target {\n    cursor: pointer;\n    pointer-events: all;\n  }\n  .tl-clone-button-target:hover .tl-clone-button {\n    fill: var(--tl-selectStroke);\n  }\n  .tl-clone-button {\n    opacity: 0;\n    r: calc(8px * var(--tl-scale));\n    stroke-width: calc(1.5px * var(--tl-scale));\n    stroke: var(--tl-selectStroke);\n    fill: var(--tl-background);\n  }\n  .tl-bounds {\n    pointer-events: none;\n    contain: layout style size;\n  }\n  .tl-bounds-bg {\n    stroke: none;\n    fill: var(--tl-selectFill);\n    pointer-events: all;\n    contain: layout style size;\n  }\n  .tl-bounds-center {\n    fill: transparent;\n    stroke: var(--tl-selectStroke);\n    stroke-width: calc(1.5px * var(--tl-scale));\n  }\n  .tl-brush {\n    fill: var(--tl-brushFill);\n    stroke: var(--tl-brushStroke);\n    stroke-width: calc(1px * var(--tl-scale));\n    pointer-events: none;\n    contain: layout style size;\n  }\n  .tl-dashed-brush-line {\n    fill: none;\n    stroke: var(--tl-brushDashStroke);\n    stroke-width: calc(1px * var(--tl-scale));\n    pointer-events: none;\n  }\n  .tl-brush.dashed {\n    stroke: none;\n  }\n  .tl-handle {\n    pointer-events: all;\n    cursor: grab;\n  }\n  .tl-handle:hover .tl-handle-bg {\n    fill: var(--tl-selectFill);\n  }\n  .tl-handle:hover .tl-handle-bg > * {\n    stroke: var(--tl-selectFill);\n  }\n  .tl-handle:active .tl-handle-bg {\n    cursor: grabbing;\n    fill: var(--tl-selectFill);\n  }\n  .tl-handle:active .tl-handle-bg > * {\n    stroke: var(--tl-selectFill);\n  }\n  .tl-handle {\n    fill: var(--tl-background);\n    stroke: var(--tl-selectStroke);\n    stroke-width: 1.5px;\n  }\n  .tl-handle-bg {\n    fill: transparent;\n    stroke: none;\n    pointer-events: all;\n    r: calc(16px / max(1, var(--tl-zoom)));\n  }\n  .tl-binding-indicator {\n    fill: transparent;\n    stroke: var(--tl-binding);\n  }\n  .tl-centered-g {\n    transform: translate(var(--tl-padding), var(--tl-padding));\n  }\n  .tl-current-parent > *[data-shy='true'] {\n    opacity: 1;\n  }\n  .tl-binding {\n    fill: none;\n    stroke: var(--tl-selectStroke);\n    stroke-width: calc(2px * var(--tl-scale));\n  }\n  .tl-grid-dot {\n    fill: var(--tl-grid);\n  }\n  .tl-erase-line {\n    stroke-linejoin: round;\n    stroke-linecap: round;\n    pointer-events: none;\n    fill: var(--tl-grid);\n    opacity: 0.32;\n  }\n`\n\nexport function useTLTheme(theme?: Partial<TLTheme>, selector?: string) {\n  const tltheme = React.useMemo<TLTheme>(\n    () => ({\n      ...defaultTheme,\n      ...theme,\n    }),\n    [theme]\n  )\n\n  useTheme('tl', tltheme, selector)\n\n  useStyle('tl-canvas', TLCSS)\n}\n", "import * as React from 'react'\nimport type { TLBoundsCorner, TLBoundsEdge } from '~types'\nimport { useTLContext } from './useTLContext'\n\nexport function useBoundsHandleEvents(\n  id: TLBoundsCorner | TLBoundsEdge | 'rotate' | 'center' | 'left' | 'right'\n) {\n  const { callbacks, inputs } = useTLContext()\n\n  const onPointerDown = React.useCallback(\n    (e: React.PointerEvent) => {\n      if ((e as any).dead) return\n      else (e as any).dead = true\n      if (!inputs.pointerIsValid(e)) return\n\n      e.currentTarget?.setPointerCapture(e.pointerId)\n\n      const info = inputs.pointerDown(e, id)\n\n      if (e.button === 2) {\n        // On right click\n        callbacks.onRightPointBoundsHandle?.(info, e)\n        return\n      }\n\n      // On left click\n      if (e.button === 0) {\n        callbacks.onPointBoundsHandle?.(info, e)\n      }\n\n      // On middle or left click\n      callbacks.onPointerDown?.(info, e)\n    },\n    [inputs, callbacks, id]\n  )\n\n  const onPointerUp = React.useCallback(\n    (e: React.PointerEvent) => {\n      if ((e as any).dead) return\n      else (e as any).dead = true\n\n      // On right click\n      if (e.button === 2 || !inputs.pointerIsValid(e)) return\n\n      const info = inputs.pointerUp(e, id)\n\n      const isDoubleClick = inputs.isDoubleClick()\n\n      // On left click up\n      if (e.button === 0) {\n        // On double left click\n        if (isDoubleClick && !(info.altKey || info.metaKey)) {\n          callbacks.onDoubleClickBoundsHandle?.(info, e)\n        }\n\n        callbacks.onReleaseBoundsHandle?.(info, e)\n      }\n\n      // On middle or left click up\n      callbacks.onPointerUp?.(info, e)\n    },\n    [inputs, callbacks, id]\n  )\n\n  const onPointerMove = React.useCallback(\n    (e: React.PointerEvent) => {\n      if ((e as any).dead) return\n      else (e as any).dead = true\n\n      if (!inputs.pointerIsValid(e)) return\n\n      // On right click\n      if (e.buttons === 2) {\n        return\n      }\n\n      const info = inputs.pointerMove(e, id)\n\n      // On left click drag\n      if (e.buttons === 1) {\n        if (e.currentTarget.hasPointerCapture(e.pointerId)) {\n          callbacks.onDragBoundsHandle?.(info, e)\n        }\n      }\n\n      // On left or middle click drag\n      callbacks.onPointerMove?.(info, e)\n    },\n    [inputs, callbacks, id]\n  )\n\n  const onPointerEnter = React.useCallback(\n    (e: React.PointerEvent) => {\n      if (!inputs.pointerIsValid(e)) return\n      callbacks.onHoverBoundsHandle?.(inputs.pointerEnter(e, id), e)\n    },\n    [inputs, callbacks, id]\n  )\n\n  const onPointerLeave = React.useCallback(\n    (e: React.PointerEvent) => {\n      if (!inputs.pointerIsValid(e)) return\n      callbacks.onUnhoverBoundsHandle?.(inputs.pointerEnter(e, id), e)\n    },\n    [inputs, callbacks, id]\n  )\n\n  return {\n    onPointerDown,\n    onPointerUp,\n    onPointerEnter,\n    onPointerMove,\n    onPointerLeave,\n  }\n}\n", "import * as React from 'react'\nimport type { TLPageState } from '~types'\n\nexport function useCameraCss(\n  layerRef: React.RefObject<HTMLDivElement>,\n  containerRef: React.ForwardedRef<HTMLDivElement>,\n  pageState: TLPageState\n) {\n  // Update the tl-zoom CSS variable when the zoom changes\n  const rZoom = React.useRef<number>()\n  const rPoint = React.useRef<number[]>()\n\n  React.useLayoutEffect(() => {\n    const { zoom, point } = pageState.camera\n\n    const didZoom = zoom !== rZoom.current\n    const didPan = point !== rPoint.current\n\n    rZoom.current = zoom\n    rPoint.current = point\n\n    if (didZoom || didPan) {\n      const layer = layerRef.current\n      if (containerRef && 'current' in containerRef) {\n        const container = containerRef.current\n\n        // If we zoomed, set the CSS variable for the zoom\n        if (didZoom) {\n          if (container) {\n            container.style.setProperty('--tl-zoom', zoom.toString())\n          }\n        }\n\n        // Either way, position the layer\n        if (layer) {\n          layer.style.setProperty(\n            'transform',\n            `scale(${zoom}) translateX(${point[0]}px) translateY(${point[1]}px)`\n          )\n        }\n      }\n    }\n  }, [pageState.camera.zoom, pageState.camera.point])\n}\n", "import * as React from 'react'\nimport type { TLShapeUtil, TLShapeUtilsMap } from '~TLShapeUtil'\nimport type { TLBinding, TLBounds, TLPage, TLPageState, TLShape } from '~types'\nimport Utils from '~utils'\nimport { useTLContext } from './useTLContext'\n\nfunction canvasToScreen(point: number[], camera: TLPageState['camera']): number[] {\n  return [(point[0] + camera.point[0]) * camera.zoom, (point[1] + camera.point[1]) * camera.zoom]\n}\n\nfunction getShapeUtils<T extends TLShape>(shapeUtils: TLShapeUtilsMap<T>, shape: T) {\n  return shapeUtils[shape.type as T['type']] as unknown as TLShapeUtil<T>\n}\n\nexport function useSelection<T extends TLShape>(\n  page: TLPage<T, TLBinding>,\n  pageState: TLPageState,\n  shapeUtils: TLShapeUtilsMap<T>\n) {\n  const { rSelectionBounds } = useTLContext()\n  const { selectedIds } = pageState\n  const rPrevBounds = React.useRef<TLBounds>()\n\n  let bounds: TLBounds | undefined = undefined\n  let rotation = 0\n  let isLocked = false\n  let isLinked = false\n\n  if (selectedIds.length === 1) {\n    const id = selectedIds[0]\n    const shape = page.shapes[id]\n\n    if (!shape) {\n      throw Error(`selectedIds is set to the id of a shape that doesn't exist: ${id}`)\n    }\n\n    rotation = shape.rotation || 0\n    isLocked = shape.isLocked || false\n\n    const utils = getShapeUtils(shapeUtils, shape)\n\n    bounds = utils.hideBounds ? undefined : utils.getBounds(shape)\n  } else if (selectedIds.length > 1) {\n    const selectedShapes = selectedIds.map((id) => page.shapes[id])\n\n    rotation = 0\n\n    isLocked = selectedShapes.every((shape) => shape.isLocked)\n\n    bounds = selectedShapes.reduce((acc, shape, i) => {\n      if (i === 0) {\n        return getShapeUtils(shapeUtils, shape).getRotatedBounds(shape)\n      }\n      return Utils.getExpandedBounds(acc, getShapeUtils(shapeUtils, shape).getRotatedBounds(shape))\n    }, {} as TLBounds)\n  }\n\n  if (bounds) {\n    const [minX, minY] = canvasToScreen([bounds.minX, bounds.minY], pageState.camera)\n    const [maxX, maxY] = canvasToScreen([bounds.maxX, bounds.maxY], pageState.camera)\n\n    isLinked = !!Object.values(page.bindings).find(\n      (binding) => selectedIds.includes(binding.toId) || selectedIds.includes(binding.fromId)\n    )\n\n    rSelectionBounds.current = {\n      minX,\n      minY,\n      maxX,\n      maxY,\n      width: maxX - minX,\n      height: maxY - minY,\n    }\n  } else {\n    rSelectionBounds.current = null\n  }\n\n  const prevBounds = rPrevBounds.current\n\n  if (!prevBounds || !bounds) {\n    rPrevBounds.current = bounds\n  } else if (bounds) {\n    if (\n      prevBounds.minX === bounds.minX &&\n      prevBounds.minY === bounds.minY &&\n      prevBounds.maxX === bounds.maxX &&\n      prevBounds.maxY === bounds.maxY\n    ) {\n      bounds = rPrevBounds.current\n    }\n  }\n\n  return { bounds, rotation, isLocked, isLinked }\n}\n", "import * as React from 'react'\nimport { useTLContext } from './useTLContext'\n\nexport function useHandleEvents(id: string) {\n  const { inputs, callbacks } = useTLContext()\n\n  return React.useMemo(() => {\n    return {\n      onPointerDown: (e: React.PointerEvent) => {\n        if ((e as any).dead) return\n        else (e as any).dead = true\n        if (!inputs.pointerIsValid(e)) return\n\n        // On left click down\n        if (e.button === 2) {\n          return\n        }\n\n        e.currentTarget?.setPointerCapture(e.pointerId)\n\n        const info = inputs.pointerDown(e, id)\n\n        // On left click down\n        if (e.button === 0) {\n          callbacks.onPointHandle?.(info, e)\n        }\n\n        // On left or middle click down\n        callbacks.onPointerDown?.(info, e)\n      },\n      onPointerUp: (e: React.PointerEvent) => {\n        if ((e as any).dead) return\n        else (e as any).dead = true\n\n        if (!inputs.pointerIsValid(e)) return\n\n        // Right click up\n        if (e.button === 2) {\n          return\n        }\n\n        const isDoubleClick = inputs.isDoubleClick()\n        const info = inputs.pointerUp(e, id)\n\n        if (e.currentTarget.hasPointerCapture(e.pointerId)) {\n          e.currentTarget?.releasePointerCapture(e.pointerId)\n\n          // On left click up\n          if (e.button === 0) {\n            if (isDoubleClick && !(info.altKey || info.metaKey)) {\n              callbacks.onDoubleClickHandle?.(info, e)\n            }\n            callbacks.onReleaseHandle?.(info, e)\n          }\n        }\n\n        // On any click up\n        callbacks.onPointerUp?.(info, e)\n      },\n      onPointerMove: (e: React.PointerEvent) => {\n        if ((e as any).dead) return\n        else (e as any).dead = true\n        if (!inputs.pointerIsValid(e)) return\n        // On right click drag\n        if (e.buttons === 2) {\n          return\n        }\n\n        const info = inputs.pointerMove(e, id)\n\n        // On left click drag\n        if (e.buttons === 1) {\n          if (e.currentTarget.hasPointerCapture(e.pointerId)) {\n            callbacks.onDragHandle?.(info, e)\n          }\n        }\n\n        // On left or middle click drag\n        callbacks.onPointerMove?.(info, e)\n      },\n      onPointerEnter: (e: React.PointerEvent) => {\n        if (!inputs.pointerIsValid(e)) return\n        const info = inputs.pointerEnter(e, id)\n        callbacks.onHoverHandle?.(info, e)\n      },\n      onPointerLeave: (e: React.PointerEvent) => {\n        if (!inputs.pointerIsValid(e)) return\n        const info = inputs.pointerEnter(e, id)\n        callbacks.onUnhoverHandle?.(info, e)\n      },\n    }\n  }, [inputs, callbacks, id])\n}\n", "import * as React from 'react'\nimport { useTLContext } from './useTLContext'\n\nexport function usePreventNavigationCss(rCanvas: React.RefObject<HTMLDivElement>): void {\n  const { bounds } = useTLContext()\n\n  React.useEffect(() => {\n    const preventGestureNavigation = (event: TouchEvent) => {\n      event.preventDefault()\n    }\n\n    const preventNavigation = (event: TouchEvent) => {\n      // Center point of the touch area\n      const touchXPosition = event.touches[0].pageX\n      // Size of the touch area\n      const touchXRadius = event.touches[0].radiusX || 0\n\n      // We set a threshold (10px) on both sizes of the screen,\n      // if the touch area overlaps with the screen edges\n      // it's likely to trigger the navigation. We prevent the\n      // touchstart event in that case.\n      if (touchXPosition - touchXRadius < 10 || touchXPosition + touchXRadius > bounds.width - 10) {\n        event.preventDefault()\n      }\n    }\n\n    const elm = rCanvas.current\n\n    if (!elm) return () => void null\n\n    // @ts-ignore\n    elm.addEventListener('gestureend', preventGestureNavigation)\n\n    // @ts-ignore\n    elm.addEventListener('gesturechange', preventGestureNavigation)\n\n    // @ts-ignore\n    elm.addEventListener('gesturestart', preventGestureNavigation)\n\n    // @ts-ignore\n    elm.addEventListener('touchstart', preventNavigation)\n\n    return () => {\n      if (elm) {\n        // @ts-ignore\n        elm.removeEventListener('gestureend', preventGestureNavigation)\n        // @ts-ignore\n        elm.removeEventListener('gesturechange', preventGestureNavigation)\n        // @ts-ignore\n        elm.removeEventListener('gesturestart', preventGestureNavigation)\n        // @ts-ignore\n        elm.removeEventListener('touchstart', preventNavigation)\n      }\n    }\n  }, [rCanvas, bounds.width])\n}\n", "import * as React from 'react'\nimport { useTLContext } from './useTLContext'\n\nexport function useBoundsEvents() {\n  const { callbacks, inputs } = useTLContext()\n\n  return React.useMemo(() => {\n    return {\n      onPointerDown: (e: React.PointerEvent) => {\n        if ((e as any).dead) return\n        else (e as any).dead = true\n        if (!inputs.pointerIsValid(e)) return\n\n        // On right click\n        if (e.button === 2) {\n          callbacks.onRightPointBounds?.(inputs.pointerDown(e, 'bounds'), e)\n          return\n        }\n\n        const info = inputs.pointerDown(e, 'bounds')\n        e.currentTarget?.setPointerCapture(e.pointerId)\n\n        // On left click\n        if (e.button === 0) {\n          callbacks.onPointBounds?.(info, e)\n        }\n\n        // On left or middle click\n        callbacks.onPointerDown?.(info, e)\n      },\n      onPointerUp: (e: React.PointerEvent) => {\n        if ((e as any).dead) return\n        else (e as any).dead = true\n\n        // On right click\n        if (e.button === 2) {\n          return\n        }\n\n        inputs.activePointer = undefined\n\n        if (!inputs.pointerIsValid(e)) return\n\n        const isDoubleClick = inputs.isDoubleClick()\n\n        const info = inputs.pointerUp(e, 'bounds')\n\n        if (e.currentTarget.hasPointerCapture(e.pointerId)) {\n          e.currentTarget?.releasePointerCapture(e.pointerId)\n        }\n\n        // On left click up\n        if (e.button === 0) {\n          // On double click\n          if (isDoubleClick && !(info.altKey || info.metaKey)) {\n            callbacks.onDoubleClickBounds?.(info, e)\n          }\n\n          callbacks.onReleaseBounds?.(info, e)\n        }\n\n        // On left or middle click up\n        callbacks.onPointerUp?.(info, e)\n      },\n      onPointerMove: (e: React.PointerEvent) => {\n        if ((e as any).dead) return\n        else (e as any).dead = true\n        if (!inputs.pointerIsValid(e)) return\n\n        // On left click move\n        if (e.buttons === 1) {\n          if (e.currentTarget.hasPointerCapture(e.pointerId)) {\n            callbacks.onDragBounds?.(inputs.pointerMove(e, 'bounds'), e)\n          }\n        }\n\n        const info = inputs.pointerMove(e, 'bounds')\n        callbacks.onPointerMove?.(info, e)\n      },\n      onPointerEnter: (e: React.PointerEvent) => {\n        if (!inputs.pointerIsValid(e)) return\n        callbacks.onHoverBounds?.(inputs.pointerEnter(e, 'bounds'), e)\n      },\n      onPointerLeave: (e: React.PointerEvent) => {\n        if (!inputs.pointerIsValid(e)) return\n        callbacks.onUnhoverBounds?.(inputs.pointerEnter(e, 'bounds'), e)\n      },\n    }\n  }, [inputs, callbacks])\n}\n", "import * as React from 'react'\nimport type { TLBounds } from '~types'\n\nexport function usePosition(bounds: TLBounds, rotation = 0) {\n  const rBounds = React.useRef<HTMLDivElement>(null)\n\n  // Update the transform\n  React.useLayoutEffect(() => {\n    const elm = rBounds.current!\n    const transform = `\n    translate(\n      calc(${bounds.minX}px - var(--tl-padding)),\n      calc(${bounds.minY}px - var(--tl-padding))\n    )\n    rotate(${rotation + (bounds.rotation || 0)}rad)`\n    elm.style.setProperty('transform', transform)\n    elm.style.setProperty('width', `calc(${Math.floor(bounds.width)}px + (var(--tl-padding) * 2))`)\n    elm.style.setProperty(\n      'height',\n      `calc(${Math.floor(bounds.height)}px + (var(--tl-padding) * 2))`\n    )\n  }, [bounds, rotation])\n\n  return rBounds\n}\n", "import * as React from 'react'\nimport { useTLContext } from '~hooks'\n\nexport function useKeyEvents() {\n  const { inputs, callbacks } = useTLContext()\n\n  React.useEffect(() => {\n    const handleKeyDown = (e: KeyboardEvent) => {\n      callbacks.onKeyDown?.(e.key, inputs.keydown(e), e)\n    }\n    const handleKeyUp = (e: KeyboardEvent) => {\n      inputs.keyup(e)\n      callbacks.onKeyUp?.(e.key, inputs.keyup(e), e)\n    }\n    window.addEventListener('keydown', handleKeyDown)\n    window.addEventListener('keyup', handleKeyUp)\n    return () => {\n      window.removeEventListener('keydown', handleKeyDown)\n      window.removeEventListener('keyup', handleKeyUp)\n    }\n  }, [inputs, callbacks])\n}\n", "import * as React from 'react'\nimport { TLPerformanceMode } from '~types'\n\nexport function usePerformanceCss(\n  performanceMode: TLPerformanceMode | undefined,\n  rContainer: React.ForwardedRef<HTMLDivElement>\n) {\n  React.useLayoutEffect(() => {\n    if (rContainer && 'current' in rContainer) {\n      const container = rContainer?.current\n      if (!container) return\n      switch (performanceMode) {\n        case TLPerformanceMode.TransformSelected: {\n          container.style.setProperty('--tl-performance-all', 'auto')\n          container.style.setProperty('--tl-performance-selected', 'transform, contents')\n          break\n        }\n        case TLPerformanceMode.TransformAll: {\n          container.style.setProperty('--tl-performance-all', 'transform, contents')\n          container.style.setProperty('--tl-performance-selected', 'transform, contents')\n          break\n        }\n        case TLPerformanceMode.TranslateSelected: {\n          container.style.setProperty('--tl-performance-all', 'auto')\n          container.style.setProperty('--tl-performance-selected', 'transform')\n          break\n        }\n        case TLPerformanceMode.TranslateAll: {\n          container.style.setProperty('--tl-performance-all', 'transform')\n          container.style.setProperty('--tl-performance-selected', 'transform')\n          break\n        }\n        default: {\n          container.style.setProperty('--tl-performance-all', 'auto')\n          container.style.setProperty('--tl-performance-selected', 'auto')\n        }\n      }\n    }\n  }, [performanceMode])\n}\n", "import * as React from 'react'\nimport type { TLUser } from '~types'\n\nexport type CursorComponent<T = any> = (props: Pick<TLUser<T>, 'id' | 'color' | 'metadata'>) => any\n\nexport const Cursor: CursorComponent = React.memo(({ color }) => {\n  return (\n    <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 35 35\" fill=\"none\" fillRule=\"evenodd\">\n      <g fill=\"rgba(0,0,0,.2)\" transform=\"translate(1,1)\">\n        <path d=\"m12 24.4219v-16.015l11.591 11.619h-6.781l-.411.124z\" />\n        <path d=\"m21.0845 25.0962-3.605 1.535-4.682-11.089 3.686-1.553z\" />\n      </g>\n      <g fill=\"white\">\n        <path d=\"m12 24.4219v-16.015l11.591 11.619h-6.781l-.411.124z\" />\n        <path d=\"m21.0845 25.0962-3.605 1.535-4.682-11.089 3.686-1.553z\" />\n      </g>\n      <g fill={color}>\n        <path d=\"m19.751 24.4155-1.844.774-3.1-7.374 1.841-.775z\" />\n        <path d=\"m13 10.814v11.188l2.969-2.866.428-.139h4.768z\" />\n      </g>\n    </svg>\n  )\n})\n", "import getStroke from 'perfect-freehand'\nimport * as React from 'react'\nimport Utils from '~utils'\n\nexport interface UiEraseLineProps {\n  points: number[][]\n  zoom: number\n}\n\nexport type UiEraseLineComponent = (props: UiEraseLineProps) => any | null\n\nfunction _EraseLine({ points, zoom }: UiEraseLineProps) {\n  if (points.length === 0) return null\n\n  const d = Utils.getSvgPathFromStroke(\n    getStroke(points, { size: 16 / zoom, start: { taper: true } })\n  )\n\n  return <path d={d} className=\"tl-erase-line\" />\n}\n\nexport const EraseLine = React.memo(_EraseLine)\n", "import * as React from 'react'\nimport type { TLPageState } from '~types'\nimport Utils from '~utils'\n\nconst STEPS = [\n  [-1, 0.15, 64],\n  [0.05, 0.375, 16],\n  [0.15, 1, 4],\n  [0.7, 2.5, 1],\n]\n\nexport function Grid({ grid, camera }: { camera: TLPageState['camera']; grid: number }) {\n  return (\n    <svg className=\"tl-grid\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\">\n      <defs>\n        {STEPS.map(([min, mid, size], i) => {\n          const s = size * grid * camera.zoom\n          const xo = camera.point[0] * camera.zoom\n          const yo = camera.point[1] * camera.zoom\n          const gxo = xo > 0 ? xo % s : s + (xo % s)\n          const gyo = yo > 0 ? yo % s : s + (yo % s)\n          const opacity = camera.zoom < mid ? Utils.modulate(camera.zoom, [min, mid], [0, 1]) : 1\n\n          return (\n            <pattern\n              key={`grid-pattern-${i}`}\n              id={`grid-${i}`}\n              width={s}\n              height={s}\n              patternUnits=\"userSpaceOnUse\"\n            >\n              <circle className={`tl-grid-dot`} cx={gxo} cy={gyo} r={1} opacity={opacity} />\n            </pattern>\n          )\n        })}\n      </defs>\n      {STEPS.map((_, i) => (\n        <rect key={`grid-rect-${i}`} width=\"100%\" height=\"100%\" fill={`url(#grid-${i})`} />\n      ))}\n    </svg>\n  )\n}\n", "import * as React from 'react'\n\nexport type OverlayProps = {\n  camera: { point: number[]; zoom: number }\n  children: React.ReactNode\n}\n\nfunction _Overlay({ camera: { zoom, point }, children }: OverlayProps) {\n  const l = 2.5 / zoom\n  return (\n    <svg className=\"tl-overlay\">\n      <defs>\n        <g id=\"tl-snap-point\">\n          <path\n            className=\"tl-snap-point\"\n            d={`M ${-l},${-l} L ${l},${l} M ${-l},${l} L ${l},${-l}`}\n          />\n        </g>\n      </defs>\n      <g transform={`scale(${zoom}) translate(${point})`}>{children}</g>\n    </svg>\n  )\n}\n\nexport const Overlay = React.memo(_Overlay)\n", "import * as React from 'react'\nimport type { TLShapeUtil } from '~TLShapeUtil'\nimport { Bounds } from '~components/Bounds'\nimport { BoundsBg } from '~components/Bounds/BoundsBg'\nimport { Handles } from '~components/Handles'\nimport { ShapeNode } from '~components/Shape'\nimport { ShapeIndicator } from '~components/ShapeIndicator'\nimport { useSelection, useShapeTree, useTLContext } from '~hooks'\nimport type { TLAssets, TLBinding, TLPage, TLPageState, TLShape } from '~types'\n\nexport interface PageProps<T extends TLShape, M extends Record<string, unknown>> {\n  page: TLPage<T, TLBinding>\n  pageState: TLPageState\n  assets: TLAssets\n  hideBounds: boolean\n  hideHandles: boolean\n  hideIndicators: boolean\n  hideBindingHandles: boolean\n  hideCloneHandles: boolean\n  hideRotateHandle: boolean\n  hideResizeHandles: boolean\n  meta?: M\n}\n\n/**\n * The Page component renders the current page.\n */\nfunction _Page<T extends TLShape, M extends Record<string, unknown>>({\n  page,\n  pageState,\n  assets,\n  hideBounds,\n  hideHandles,\n  hideIndicators,\n  hideBindingHandles,\n  hideCloneHandles,\n  hideRotateHandle,\n  hideResizeHandles,\n  meta,\n}: PageProps<T, M>) {\n  const { bounds: rendererBounds, shapeUtils } = useTLContext()\n\n  const shapeTree = useShapeTree(page, pageState, assets, meta)\n\n  const { bounds, isLinked, isLocked, rotation } = useSelection(page, pageState, shapeUtils)\n\n  const {\n    selectedIds,\n    hoveredId,\n    editingId,\n    camera: { zoom },\n  } = pageState\n\n  let _hideIndicators = hideIndicators\n  let _hideCloneHandles = true\n  let _isEditing = false\n\n  // Does the selected shape have handles?\n  let shapeWithHandles: TLShape | undefined = undefined\n  const selectedShapes = selectedIds.map((id) => page.shapes[id])\n\n  if (selectedShapes.length === 1) {\n    const shape = selectedShapes[0]\n    _isEditing = editingId === shape.id\n    if (_isEditing) _hideIndicators = true\n    const utils = shapeUtils[shape.type] as TLShapeUtil<any, any>\n    _hideCloneHandles = hideCloneHandles || !utils.showCloneHandles\n    if (shape.handles !== undefined && !_isEditing) {\n      shapeWithHandles = shape\n    }\n  }\n\n  return (\n    <>\n      {bounds && <BoundsBg bounds={bounds} rotation={rotation} isHidden={hideBounds} />}\n      {shapeTree.map((node) => (\n        <ShapeNode key={node.shape.id} utils={shapeUtils} {...node} />\n      ))}\n      {!_hideIndicators &&\n        selectedShapes.map((shape) => (\n          <ShapeIndicator\n            key={'selected_' + shape.id}\n            shape={shape}\n            meta={meta as any}\n            isSelected\n            isEditing={_isEditing}\n          />\n        ))}\n      {!_hideIndicators && hoveredId && hoveredId !== editingId && (\n        <ShapeIndicator\n          key={'hovered_' + hoveredId}\n          shape={page.shapes[hoveredId]}\n          meta={meta as any}\n          isHovered\n        />\n      )}\n      {bounds && (\n        <Bounds\n          zoom={zoom}\n          bounds={bounds}\n          viewportWidth={rendererBounds.width}\n          isLocked={isLocked}\n          rotation={rotation}\n          isHidden={hideBounds}\n          hideRotateHandle={hideRotateHandle}\n          hideResizeHandles={hideResizeHandles}\n          hideBindingHandles={hideBindingHandles || !isLinked}\n          hideCloneHandles={_hideCloneHandles}\n        />\n      )}\n      {!hideHandles && shapeWithHandles && <Handles shape={shapeWithHandles} zoom={zoom} />}\n    </>\n  )\n}\n\nexport const Page = React.memo(_Page)\n", "import * as React from 'react'\nimport { Container } from '~components/Container'\nimport { SVGContainer } from '~components/SVGContainer'\nimport { TLBounds, TLBoundsCorner, TLBoundsEdge } from '~types'\nimport { CenterHandle } from './CenterHandle'\nimport { CloneButtons } from './CloneButtons'\nimport { CornerHandle } from './CornerHandle'\nimport { EdgeHandle } from './EdgeHandle'\nimport { LinkHandle } from './LinkHandle'\nimport { RotateHandle } from './RotateHandle'\n\nexport interface BoundsProps {\n  zoom: number\n  bounds: TLBounds\n  rotation: number\n  isLocked: boolean\n  isHidden: boolean\n  hideCloneHandles: boolean\n  hideRotateHandle: boolean\n  hideBindingHandles: boolean\n  hideResizeHandles: boolean\n  viewportWidth: number\n  children?: React.ReactElement\n}\n\nconst _Bounds = function Bounds({\n  zoom,\n  bounds,\n  viewportWidth,\n  rotation,\n  isHidden,\n  isLocked,\n  hideCloneHandles,\n  hideResizeHandles,\n  hideRotateHandle,\n  hideBindingHandles,\n}: BoundsProps) {\n  // Touch target size\n  const targetSize = (viewportWidth < 768 ? 16 : 8) / zoom\n  // Handle size\n  const size = 8 / zoom\n\n  const smallDimension = Math.min(bounds.width, bounds.height) * zoom\n  // If the bounds are small, don't show the rotate handle\n  const showRotateHandle = !hideRotateHandle && !isHidden && !isLocked && smallDimension > 32\n  // If the bounds are very small, don't show the edge handles\n  const showEdgeHandles = !isHidden && !isLocked && smallDimension > 24\n  // If the bounds are very very small, don't show the corner handles\n  const showCornerHandles = !isHidden && !isLocked && smallDimension > 20\n  // If the bounds are very small, don't show the clone handles\n  const showCloneHandles = !hideCloneHandles && smallDimension > 24\n  // Unless we're hiding the resize handles, show them\n  const showResizeHandles = !hideResizeHandles && !isLocked\n\n  return (\n    <Container bounds={bounds} rotation={rotation}>\n      <SVGContainer>\n        <CenterHandle bounds={bounds} isLocked={isLocked} isHidden={isHidden} />\n        {showResizeHandles ? (\n          <>\n            <EdgeHandle\n              targetSize={targetSize}\n              size={size}\n              bounds={bounds}\n              edge={TLBoundsEdge.Top}\n              isHidden={!showEdgeHandles}\n            />\n            <EdgeHandle\n              targetSize={targetSize}\n              size={size}\n              bounds={bounds}\n              edge={TLBoundsEdge.Right}\n              isHidden={!showEdgeHandles}\n            />\n            <EdgeHandle\n              targetSize={targetSize}\n              size={size}\n              bounds={bounds}\n              edge={TLBoundsEdge.Bottom}\n              isHidden={!showEdgeHandles}\n            />\n            <EdgeHandle\n              targetSize={targetSize}\n              size={size}\n              bounds={bounds}\n              edge={TLBoundsEdge.Left}\n              isHidden={!showEdgeHandles}\n            />\n            <CornerHandle\n              targetSize={targetSize}\n              size={size}\n              bounds={bounds}\n              isHidden={isHidden || !showCornerHandles}\n              corner={TLBoundsCorner.TopLeft}\n            />\n            <CornerHandle\n              targetSize={targetSize}\n              size={size}\n              bounds={bounds}\n              isHidden={isHidden || !showCornerHandles}\n              corner={TLBoundsCorner.TopRight}\n            />\n            <CornerHandle\n              targetSize={targetSize}\n              size={size}\n              bounds={bounds}\n              isHidden={isHidden || !showCornerHandles}\n              corner={TLBoundsCorner.BottomRight}\n            />\n            <CornerHandle\n              targetSize={targetSize}\n              size={size}\n              bounds={bounds}\n              isHidden={isHidden || !showCornerHandles}\n              corner={TLBoundsCorner.BottomLeft}\n            />\n          </>\n        ) : null}\n        {showRotateHandle && (\n          <RotateHandle\n            targetSize={targetSize}\n            size={size}\n            bounds={bounds}\n            isHidden={!showEdgeHandles}\n          />\n        )}\n        {showCloneHandles && <CloneButtons bounds={bounds} targetSize={targetSize} size={size} />}\n        {!hideBindingHandles && (\n          <LinkHandle\n            targetSize={targetSize}\n            size={size}\n            bounds={bounds}\n            isHidden={!showEdgeHandles}\n          />\n        )}\n      </SVGContainer>\n    </Container>\n  )\n}\n\nexport const Bounds = React.memo(_Bounds)\n", "import * as React from 'react'\n\nexport interface SvgContainerProps extends React.SVGProps<SVGSVGElement> {\n  children: React.ReactNode\n  className?: string\n}\n\nexport const SVGContainer = React.memo(\n  React.forwardRef<SVGSVGElement, SvgContainerProps>(function SVGContainer(\n    { id, className = '', children, ...rest },\n    ref\n  ) {\n    return (\n      <svg ref={ref} className={`tl-positioned-svg ${className}`} {...rest}>\n        <g id={id} className=\"tl-centered-g\">\n          {children}\n        </g>\n      </svg>\n    )\n  })\n)\n", "import * as React from 'react'\nimport type { TLBounds } from '~types'\n\nexport interface CenterHandleProps {\n  bounds: TLBounds\n  isLocked: boolean\n  isHidden: boolean\n}\n\nfunction _CenterHandle({ bounds, isLocked, isHidden }: CenterHandleProps) {\n  return (\n    <rect\n      className={['tl-bounds-center', isLocked ? 'tl-dashed' : ''].join(' ')}\n      x={-1}\n      y={-1}\n      width={bounds.width + 2}\n      height={bounds.height + 2}\n      opacity={isHidden ? 0 : 1}\n      pointerEvents=\"none\"\n      aria-label=\"center handle\"\n    />\n  )\n}\n\nexport const CenterHandle = React.memo(_CenterHandle)\n", "import * as React from 'react'\nimport type { TLBounds } from '~types'\nimport { CloneButton } from './CloneButton'\n\nexport interface CloneButtonsProps {\n  bounds: TLBounds\n  targetSize: number\n  size: number\n}\n\nfunction _CloneButtons({ targetSize, size, bounds }: CloneButtonsProps) {\n  return (\n    <>\n      <CloneButton targetSize={targetSize} size={size} bounds={bounds} side=\"top\" />\n      <CloneButton targetSize={targetSize} size={size} bounds={bounds} side=\"right\" />\n      <CloneButton targetSize={targetSize} size={size} bounds={bounds} side=\"bottom\" />\n      <CloneButton targetSize={targetSize} size={size} bounds={bounds} side=\"left\" />\n      <CloneButton targetSize={targetSize} size={size} bounds={bounds} side=\"topLeft\" />\n      <CloneButton targetSize={targetSize} size={size} bounds={bounds} side=\"topRight\" />\n      <CloneButton targetSize={targetSize} size={size} bounds={bounds} side=\"bottomLeft\" />\n      <CloneButton targetSize={targetSize} size={size} bounds={bounds} side=\"bottomRight\" />\n    </>\n  )\n}\n\nexport const CloneButtons = React.memo(_CloneButtons)\n", "import * as React from 'react'\nimport { useTLContext } from '~hooks'\nimport type { TLBounds } from '~types'\n\nconst ROTATIONS = {\n  right: 0,\n  bottomRight: 45,\n  bottom: 90,\n  bottomLeft: 135,\n  left: 180,\n  topLeft: 225,\n  top: 270,\n  topRight: 315,\n}\n\nexport interface CloneButtonProps {\n  bounds: TLBounds\n  targetSize: number\n  size: number\n  side: 'top' | 'right' | 'bottom' | 'left' | 'topLeft' | 'topRight' | 'bottomLeft' | 'bottomRight'\n}\n\nfunction _CloneButton({ bounds, side, targetSize, size }: CloneButtonProps) {\n  const s = targetSize * 2\n  const x = {\n    left: -s,\n    topLeft: -s,\n    bottomLeft: -s,\n    right: bounds.width,\n    topRight: bounds.width,\n    bottomRight: bounds.width,\n    top: bounds.width / 2 - s / 2,\n    bottom: bounds.width / 2 - s / 2,\n  }[side]\n\n  const y = {\n    left: bounds.height / 2 - s / 2,\n    right: bounds.height / 2 - s / 2,\n    top: -s * 2,\n    topLeft: -s,\n    topRight: -s,\n    bottom: bounds.height,\n    bottomLeft: bounds.height,\n    bottomRight: bounds.height,\n  }[side]\n\n  const { callbacks, inputs } = useTLContext()\n\n  const handleClick = React.useCallback(\n    (e: React.PointerEvent<SVGGElement>) => {\n      e.stopPropagation()\n      const info = inputs.pointerDown(e, side)\n      callbacks.onShapeClone?.(info, e)\n    },\n    [callbacks.onShapeClone]\n  )\n\n  return (\n    <g className=\"tl-clone-target\" transform={`translate(${x}, ${y})`} aria-label=\"clone button\">\n      <rect className=\"tl-transparent\" width={targetSize * 2} height={targetSize * 2} />\n      <g\n        className=\"tl-clone-button-target\"\n        onPointerDown={handleClick}\n        transform={`translate(${targetSize}, ${targetSize}) rotate(${ROTATIONS[side]})`}\n      >\n        <circle className=\"tl-transparent \" r={targetSize} />\n        <path\n          className=\"tl-clone-button\"\n          d={`M -${size / 2},-${size / 2} L ${size / 2},0 -${size / 2},${size / 2} Z`}\n          strokeLinejoin=\"round\"\n        />\n      </g>\n    </g>\n  )\n}\n\nexport const CloneButton = React.memo(_CloneButton)\n", "import * as React from 'react'\nimport { useBoundsHandleEvents } from '~hooks'\nimport { TLBounds, TLBoundsCorner } from '~types'\n\nconst cornerBgClassnames = {\n  [TLBoundsCorner.TopLeft]: 'tl-cursor-nwse',\n  [TLBoundsCorner.TopRight]: 'tl-cursor-nesw',\n  [TLBoundsCorner.BottomRight]: 'tl-cursor-nwse',\n  [TLBoundsCorner.BottomLeft]: 'tl-cursor-nesw',\n}\n\nexport interface CornerHandleProps {\n  size: number\n  targetSize: number\n  bounds: TLBounds\n  corner: TLBoundsCorner\n  isHidden?: boolean\n}\n\nfunction _CornerHandle({ size, targetSize, isHidden, corner, bounds }: CornerHandleProps) {\n  const events = useBoundsHandleEvents(corner)\n\n  const isTop = corner === TLBoundsCorner.TopLeft || corner === TLBoundsCorner.TopRight\n  const isLeft = corner === TLBoundsCorner.TopLeft || corner === TLBoundsCorner.BottomLeft\n\n  return (\n    <g opacity={isHidden ? 0 : 1}>\n      <rect\n        className={'tl-transparent ' + (isHidden ? '' : cornerBgClassnames[corner])}\n        aria-label=\"corner transparent\"\n        x={(isLeft ? -1 : bounds.width + 1) - targetSize}\n        y={(isTop ? -1 : bounds.height + 1) - targetSize}\n        width={targetSize * 2}\n        height={targetSize * 2}\n        pointerEvents={isHidden ? 'none' : 'all'}\n        {...events}\n      />\n      <rect\n        className=\"tl-corner-handle\"\n        aria-label=\"corner handle\"\n        x={(isLeft ? -1 : bounds.width + 1) - size / 2}\n        y={(isTop ? -1 : bounds.height + 1) - size / 2}\n        width={size}\n        height={size}\n        pointerEvents=\"none\"\n      />\n    </g>\n  )\n}\n\nexport const CornerHandle = React.memo(_CornerHandle)\n", "import * as React from 'react'\nimport { useBoundsHandleEvents } from '~hooks'\nimport { TLBounds, TLBoundsEdge } from '~types'\n\nconst edgeClassnames = {\n  [TLBoundsEdge.Top]: 'tl-cursor-ns',\n  [TLBoundsEdge.Right]: 'tl-cursor-ew',\n  [TLBoundsEdge.Bottom]: 'tl-cursor-ns',\n  [TLBoundsEdge.Left]: 'tl-cursor-ew',\n}\n\nexport interface EdgeHandleProps {\n  targetSize: number\n  size: number\n  bounds: TLBounds\n  edge: TLBoundsEdge\n  isHidden: boolean\n}\n\nfunction _EdgeHandle({ size, isHidden, bounds, edge }: EdgeHandleProps) {\n  const events = useBoundsHandleEvents(edge)\n\n  const isHorizontal = edge === TLBoundsEdge.Top || edge === TLBoundsEdge.Bottom\n  const isFarEdge = edge === TLBoundsEdge.Right || edge === TLBoundsEdge.Bottom\n\n  const { height, width } = bounds\n\n  return (\n    <rect\n      pointerEvents={isHidden ? 'none' : 'all'}\n      className={'tl-transparent tl-edge-handle ' + (isHidden ? '' : edgeClassnames[edge])}\n      aria-label={`${edge} handle`}\n      opacity={isHidden ? 0 : 1}\n      x={isHorizontal ? size / 2 : (isFarEdge ? width + 1 : -1) - size / 2}\n      y={isHorizontal ? (isFarEdge ? height + 1 : -1) - size / 2 : size / 2}\n      width={isHorizontal ? Math.max(0, width + 1 - size) : size}\n      height={isHorizontal ? size : Math.max(0, height + 1 - size)}\n      {...events}\n    />\n  )\n}\n\nexport const EdgeHandle = React.memo(_EdgeHandle)\n", "import * as React from 'react'\nimport { useBoundsHandleEvents } from '~hooks'\nimport type { TLBounds } from '~types'\n\nexport interface LinkHandleProps {\n  size: number\n  targetSize: number\n  isHidden: boolean\n  bounds: TLBounds\n}\n\nfunction _LinkHandle({ size, bounds, isHidden }: LinkHandleProps) {\n  const leftEvents = useBoundsHandleEvents('left')\n  const centerEvents = useBoundsHandleEvents('center')\n  const rightEvents = useBoundsHandleEvents('right')\n\n  return (\n    <g\n      cursor=\"grab\"\n      transform={`translate(${bounds.width / 2 - size * 4}, ${bounds.height + size * 2})`}\n      aria-label=\"link handle\"\n    >\n      <g className=\"tl-transparent\" pointerEvents={isHidden ? 'none' : 'all'}>\n        <rect x={0} y={0} width={size * 2} height={size * 2} {...leftEvents} />\n        <rect x={size * 3} y={0} width={size * 2} height={size * 2} {...centerEvents} />\n        <rect x={size * 6} y={0} width={size * 2} height={size * 2} {...rightEvents} />\n      </g>\n      <g\n        className=\"tl-rotate-handle\"\n        transform={`translate(${size / 2}, ${size / 2})`}\n        aria-label=\"link rotate handle\"\n      >\n        <path\n          d={`M 0,${size / 2} L ${size},${size} ${size},0 Z`}\n          pointerEvents=\"none\"\n          opacity={isHidden ? 0 : 1}\n        />\n        <path\n          transform={`translate(${size * 3}, 0)`}\n          d={`M 0,0 L ${size},0 ${size / 2},${size} Z`}\n          pointerEvents=\"none\"\n          opacity={isHidden ? 0 : 1}\n        />\n        <path\n          transform={`translate(${size * 6}, 0)`}\n          d={`M ${size},${size / 2} L 0,0 0,${size} Z`}\n          pointerEvents=\"none\"\n          opacity={isHidden ? 0 : 1}\n        />\n      </g>\n    </g>\n  )\n}\n\nexport const LinkHandle = React.memo(_LinkHandle)\n", "import * as React from 'react'\nimport { useBoundsHandleEvents } from '~hooks'\nimport type { TLBounds } from '~types'\n\nexport interface RotateHandleProps {\n  bounds: TLBounds\n  size: number\n  targetSize: number\n  isHidden: boolean\n}\n\nfunction _RotateHandle({ bounds, targetSize, size, isHidden }: RotateHandleProps) {\n  const events = useBoundsHandleEvents('rotate')\n\n  return (\n    <g cursor=\"grab\" opacity={isHidden ? 0 : 1}>\n      <circle\n        className=\"tl-transparent\"\n        aria-label=\"rotate handle transparent\"\n        cx={bounds.width / 2}\n        cy={size * -2}\n        r={targetSize}\n        pointerEvents={isHidden ? 'none' : 'all'}\n        {...events}\n      />\n      <circle\n        className=\"tl-rotate-handle\"\n        aria-label=\"rotate handle\"\n        cx={bounds.width / 2}\n        cy={size * -2}\n        r={size / 2}\n        pointerEvents=\"none\"\n      />\n    </g>\n  )\n}\n\nexport const RotateHandle = React.memo(_RotateHandle)\n", "import * as React from 'react'\nimport { Container } from '~components/Container'\nimport { SVGContainer } from '~components/SVGContainer'\nimport { useBoundsEvents } from '~hooks'\nimport type { TLBounds } from '~types'\n\nexport interface BoundsBgProps {\n  bounds: TLBounds\n  rotation: number\n  isHidden: boolean\n}\n\nfunction _BoundsBg({ bounds, rotation, isHidden }: BoundsBgProps) {\n  const events = useBoundsEvents()\n\n  return (\n    <Container bounds={bounds} rotation={rotation}>\n      <SVGContainer>\n        <rect\n          className=\"tl-bounds-bg\"\n          aria-label=\"bounds bg\"\n          width={bounds.width}\n          height={bounds.height}\n          opacity={isHidden ? 0 : 1}\n          {...events}\n        />\n      </SVGContainer>\n    </Container>\n  )\n}\n\nexport const BoundsBg = React.memo(_BoundsBg)\n", "import { Vec } from '@tldraw/vec'\nimport * as React from 'react'\nimport type { TLHandle, TLShape } from '~types'\nimport { Handle } from './Handle'\n\ninterface HandlesProps {\n  shape: TLShape\n  zoom: number\n}\n\nfunction _Handles({ shape, zoom }: HandlesProps) {\n  if (shape.handles === undefined) {\n    return null\n  }\n\n  let prev: number[] | null = null\n\n  const handlesToShow = Object.values(shape.handles).reduce((acc, cur) => {\n    const point = Vec.add(cur.point, shape.point)\n\n    if (!prev || Vec.dist(point, prev) * zoom >= 32) {\n      acc.push(cur)\n      prev = point\n    }\n\n    return acc\n  }, [] as TLHandle[])\n\n  if (handlesToShow.length === 1) return null\n\n  return (\n    <>\n      {handlesToShow.map((handle) => (\n        <Handle\n          key={shape.id + '_' + handle.id}\n          id={handle.id}\n          point={Vec.add(handle.point, shape.point)}\n        />\n      ))}\n    </>\n  )\n}\n\nexport const Handles = React.memo(_Handles)\n", "import * as React from 'react'\nimport { Container } from '~components/Container'\nimport { SVGContainer } from '~components/SVGContainer'\nimport { useHandleEvents } from '~hooks'\nimport Utils from '~utils'\n\ninterface HandleProps {\n  id: string\n  point: number[]\n}\n\nfunction _Handle({ id, point }: HandleProps) {\n  const events = useHandleEvents(id)\n\n  return (\n    <Container\n      bounds={Utils.translateBounds(\n        {\n          minX: 0,\n          minY: 0,\n          maxX: 0,\n          maxY: 0,\n          width: 0,\n          height: 0,\n        },\n        point\n      )}\n    >\n      <SVGContainer>\n        <g className=\"tl-handle\" aria-label=\"handle\" {...events}>\n          <circle className=\"tl-handle-bg\" pointerEvents=\"all\" />\n          <circle className=\"tl-counter-scaled tl-handle\" pointerEvents=\"none\" r={4} />\n        </g>\n      </SVGContainer>\n    </Container>\n  )\n}\n\nexport const Handle = React.memo(_Handle)\n", "import * as React from 'react'\nimport type { TLShapeUtilsMap } from '~TLShapeUtil'\nimport type { IShapeTreeNode, TLShape } from '~types'\nimport { Shape } from './Shape'\n\nexport interface ShapeNodeProps<T extends TLShape> extends IShapeTreeNode<T> {\n  utils: TLShapeUtilsMap<T>\n}\n\nfunction _ShapeNode<T extends TLShape>({\n  shape,\n  utils,\n  meta,\n  children,\n  ...rest\n}: ShapeNodeProps<T>) {\n  return (\n    <>\n      <Shape shape={shape} utils={(utils as any)[shape.type]} meta={meta} {...rest} />\n      {children &&\n        children.map((childNode) => (\n          <ShapeNode key={childNode.shape.id} utils={utils as any} {...childNode} />\n        ))}\n    </>\n  )\n}\n\nexport const ShapeNode = React.memo(_ShapeNode)\n", "import * as React from 'react'\nimport type { TLShapeUtil } from '~TLShapeUtil'\nimport { Container } from '~components/Container'\nimport { useShapeEvents } from '~hooks'\nimport { useTLContext } from '~hooks'\nimport type { IShapeTreeNode, TLShape } from '~types'\nimport { RenderedShape } from './RenderedShape'\n\nexport interface ShapeProps<T extends TLShape, E extends Element, M> extends IShapeTreeNode<T, M> {\n  utils: TLShapeUtil<T, E, M>\n}\n\nfunction _Shape<T extends TLShape, E extends Element, M>({\n  shape,\n  utils,\n  meta,\n  ...rest\n}: ShapeProps<T, E, M>) {\n  const { callbacks } = useTLContext()\n  const bounds = utils.getBounds(shape)\n  const events = useShapeEvents(shape.id)\n\n  return (\n    <Container\n      id={shape.id}\n      bounds={bounds}\n      rotation={shape.rotation}\n      data-shape={shape.type}\n      isGhost={rest.isGhost}\n      isSelected={rest.isSelected}\n    >\n      <RenderedShape\n        shape={shape}\n        utils={utils as any}\n        meta={meta}\n        events={events}\n        bounds={bounds}\n        onShapeChange={callbacks.onShapeChange}\n        onShapeBlur={callbacks.onShapeBlur}\n        {...rest}\n      />\n    </Container>\n  )\n}\n\nexport const Shape = React.memo(_Shape)\n", "import * as React from 'react'\nimport type { TLShapeUtil } from '~TLShapeUtil'\nimport type { TLComponentProps, TLShape } from '~types'\n\ninterface RenderedShapeProps<T extends TLShape, E extends Element, M>\n  extends TLComponentProps<T, E, M> {\n  shape: T\n  utils: TLShapeUtil<T, E, M>\n}\n\nfunction _RenderedShape<T extends TLShape, E extends Element, M>(\n  props: RenderedShapeProps<T, E, M>\n) {\n  const ref = props.utils.getRef(props.shape)\n  return <props.utils.Component ref={ref} {...props} />\n}\n\nexport const RenderedShape = React.memo(_RenderedShape, (prev, next) => {\n  // If these have changed, then definitely render\n  if (\n    prev.isHovered !== next.isHovered ||\n    prev.isSelected !== next.isSelected ||\n    prev.isEditing !== next.isEditing ||\n    prev.isBinding !== next.isBinding ||\n    prev.isGhost !== next.isGhost ||\n    prev.meta !== next.meta\n  ) {\n    return false\n  }\n\n  // If not, and if the shape has changed, ask the shape's class\n  // whether it should render\n  if (next.shape !== prev.shape) {\n    return !next.utils.shouldRender(next.shape, prev.shape)\n  }\n\n  return true\n})\n", "import * as React from 'react'\nimport { usePosition, useTLContext } from '~hooks'\nimport type { TLShape, TLUser } from '~types'\n\nexport interface IndicatorProps<T extends TLShape, M = unknown> {\n  shape: T\n  meta: M extends unknown ? M : undefined\n  isSelected?: boolean\n  isHovered?: boolean\n  isEditing?: boolean\n  user?: TLUser\n}\n\nfunction _ShapeIndicator<T extends TLShape, M>({\n  isHovered = false,\n  isSelected = false,\n  isEditing = false,\n  shape,\n  user,\n  meta,\n}: IndicatorProps<T, M>) {\n  const { shapeUtils } = useTLContext()\n  const utils = shapeUtils[shape.type]\n  const bounds = utils.getBounds(shape)\n  const rPositioned = usePosition(bounds, shape.rotation)\n\n  return (\n    <div\n      ref={rPositioned}\n      draggable={false}\n      className={[\n        'tl-indicator',\n        'tl-absolute',\n        isSelected && !user ? 'tl-selected' : 'tl-hovered',\n        isEditing ? 'tl-editing' : '',\n        shape.isLocked ? 'tl-locked' : '',\n      ].join(' ')}\n    >\n      <svg width=\"100%\" height=\"100%\">\n        <g className=\"tl-centered-g\" stroke={user?.color}>\n          <utils.Indicator\n            shape={shape}\n            meta={meta}\n            user={user}\n            bounds={bounds}\n            isSelected={isSelected}\n            isHovered={isHovered}\n          />\n        </g>\n      </svg>\n    </div>\n  )\n}\n\nexport const ShapeIndicator = React.memo(_ShapeIndicator)\n", "import * as React from 'react'\nimport type { TLSnapLine } from '~types'\nimport Utils from '~utils'\n\nfunction _SnapLines({ snapLines }: { snapLines: TLSnapLine[] }) {\n  return (\n    <>\n      {snapLines.map((snapLine, i) => (\n        <SnapLine key={i} snapLine={snapLine} />\n      ))}\n    </>\n  )\n}\n\nfunction _SnapLine({ snapLine }: { snapLine: TLSnapLine }) {\n  const bounds = Utils.getBoundsFromPoints(snapLine)\n\n  return (\n    <>\n      <line\n        className=\"tl-snap-line\"\n        x1={bounds.minX}\n        y1={bounds.minY}\n        x2={bounds.maxX}\n        y2={bounds.maxY}\n      />\n      {snapLine.map(([x, y], i) => (\n        <use key={i} href=\"#tl-snap-point\" x={x} y={y} />\n      ))}\n    </>\n  )\n}\n\nexport const SnapLine = React.memo(_SnapLine)\nexport const SnapLines = React.memo(_SnapLines)\n", "import * as React from 'react'\nimport { CursorComponent } from '~components/Cursor'\nimport { User } from '~components/User/User'\nimport type { TLUsers } from '~types'\n\nexport interface UserProps {\n  userId?: string\n  users: TLUsers\n  Cursor: CursorComponent\n}\n\nexport function Users({ userId, users, Cursor }: UserProps) {\n  return (\n    <>\n      {Object.values(users)\n        .filter((user) => user && user.id !== userId)\n        .map((user) => (\n          <User key={user.id} user={user} Cursor={Cursor} />\n        ))}\n    </>\n  )\n}\n", "import * as React from 'react'\nimport { CursorComponent } from '~components/Cursor'\nimport type { TLUser } from '~types'\n\ninterface UserProps {\n  user: TLUser\n  Cursor: CursorComponent\n}\n\nexport function User({ user, Cursor }: UserProps) {\n  const rCursor = React.useRef<HTMLDivElement>(null)\n\n  React.useLayoutEffect(() => {\n    if (rCursor.current) {\n      rCursor.current.style.transform = `translate(${user.point[0]}px, ${user.point[1]}px)`\n    }\n  }, [user.point])\n\n  return (\n    <div\n      ref={rCursor}\n      className={`tl-absolute tl-user tl-counter-scaled ${user.session ? '' : 'tl-animated'}`}\n    >\n      <Cursor id={user.id} color={user.color} metadata={user.metadata} />\n    </div>\n  )\n}\n", "import * as React from 'react'\nimport { ShapeIndicator } from '~components/ShapeIndicator'\nimport { useTLContext } from '~hooks'\nimport type { TLPage, TLShape, TLUsers } from '~types'\nimport Utils from '~utils'\n\ninterface UserIndicatorProps<T extends TLShape> {\n  page: TLPage<any, any>\n  userId: string\n  users: TLUsers\n  meta: any\n}\n\nexport function UsersIndicators<T extends TLShape>({\n  userId,\n  users,\n  meta,\n  page,\n}: UserIndicatorProps<T>) {\n  const { shapeUtils } = useTLContext()\n\n  return (\n    <>\n      {Object.values(users)\n        .filter(Boolean)\n        .filter((user) => user.id !== userId && user.selectedIds.length > 0)\n        .map((user) => {\n          const shapes = user.selectedIds.map((id) => page.shapes[id]).filter(Boolean)\n\n          if (shapes.length === 0) return null\n\n          const bounds = Utils.getCommonBounds(\n            shapes.map((shape) => shapeUtils[shape.type].getBounds(shape))\n          )\n\n          return (\n            <React.Fragment key={user.id + '_shapes'}>\n              <div\n                className=\"tl-absolute tl-user-indicator-bounds\"\n                style={{\n                  backgroundColor: user.color + '0d',\n                  borderColor: user.color + '78',\n                  transform: `translate(${bounds.minX}px, ${bounds.minY}px)`,\n                  width: bounds.width,\n                  height: bounds.height,\n                  pointerEvents: 'none',\n                }}\n              />\n              {shapes.map((shape) => (\n                <ShapeIndicator\n                  key={`${user.id}_${shape.id}_indicator`}\n                  shape={shape}\n                  user={user}\n                  meta={meta}\n                  isHovered\n                />\n              ))}\n            </React.Fragment>\n          )\n        })}\n    </>\n  )\n}\n", "import * as React from 'react'\nimport { useTLContext } from '~hooks'\nimport type { TLBounds } from '~types'\nimport { Utils } from '~utils'\n\n// Credits: from excalidraw\n// https://github.com/excalidraw/excalidraw/blob/07ebd7c68ce6ff92ddbc22d1c3d215f2b21328d6/src/utils.ts#L542-L563\nconst getNearestScrollableContainer = (element: HTMLElement): HTMLElement | Document => {\n  let parent = element.parentElement\n  while (parent) {\n    if (parent === document.body) {\n      return document\n    }\n    const { overflowY } = window.getComputedStyle(parent)\n    const hasScrollableContent = parent.scrollHeight > parent.clientHeight\n    if (\n      hasScrollableContent &&\n      (overflowY === 'auto' || overflowY === 'scroll' || overflowY === 'overlay')\n    ) {\n      return parent\n    }\n    parent = parent.parentElement\n  }\n  return document\n}\n\nexport function useResizeObserver<T extends HTMLElement>(\n  ref: React.RefObject<T>,\n  onBoundsChange: (bounds: TLBounds) => void\n) {\n  const { inputs, callbacks } = useTLContext()\n\n  const rIsMounted = React.useRef(false)\n\n  // When the element resizes, update the bounds (stored in inputs)\n  // and broadcast via the onBoundsChange callback prop.\n  const updateBounds = React.useCallback(() => {\n    if (rIsMounted.current) {\n      const rect = ref.current?.getBoundingClientRect()\n\n      if (rect) {\n        const bounds: TLBounds = {\n          minX: rect.left,\n          maxX: rect.left + rect.width,\n          minY: rect.top,\n          maxY: rect.top + rect.height,\n          width: rect.width,\n          height: rect.height,\n        }\n\n        inputs.bounds = bounds\n\n        onBoundsChange(bounds)\n\n        callbacks.onBoundsChange?.(bounds)\n      }\n    } else {\n      // Skip the first mount\n      rIsMounted.current = true\n    }\n  }, [ref, inputs, callbacks.onBoundsChange])\n\n  React.useEffect(() => {\n    const scrollingAnchor = ref.current ? getNearestScrollableContainer(ref.current) : document\n    const debouncedupdateBounds = Utils.debounce(updateBounds, 100)\n    scrollingAnchor.addEventListener('scroll', debouncedupdateBounds)\n    window.addEventListener('resize', debouncedupdateBounds)\n    return () => {\n      scrollingAnchor.removeEventListener('scroll', debouncedupdateBounds)\n      window.removeEventListener('resize', debouncedupdateBounds)\n    }\n  }, [])\n\n  React.useEffect(() => {\n    const resizeObserver = new ResizeObserver((entries) => {\n      if (inputs.isPinching) {\n        return\n      }\n\n      if (entries[0].contentRect) {\n        updateBounds()\n      }\n    })\n\n    if (ref.current) {\n      resizeObserver.observe(ref.current)\n    }\n\n    return () => {\n      resizeObserver.disconnect()\n    }\n  }, [ref, inputs])\n\n  React.useEffect(() => {\n    updateBounds()\n  }, [ref])\n}\n", "import { Vec } from '@tldraw/vec'\nimport type React from 'react'\nimport type { TLBounds, TLKeyboardInfo, TLPointerInfo } from './types'\nimport { Utils } from './utils'\n\nconst DOUBLE_CLICK_DURATION = 250\n\nexport class Inputs {\n  pointer?: TLPointerInfo<string>\n\n  keyboard?: TLKeyboardInfo\n\n  keys: Record<string, boolean> = {}\n\n  isPinching = false\n\n  bounds: TLBounds = {\n    minX: 0,\n    maxX: 640,\n    minY: 0,\n    maxY: 480,\n    width: 640,\n    height: 480,\n  }\n\n  pointerUpTime = 0\n\n  activePointer?: number\n\n  pointerIsValid(e: TouchEvent | React.TouchEvent | PointerEvent | React.PointerEvent) {\n    if ('pointerId' in e) {\n      if (this.activePointer && this.activePointer !== e.pointerId) {\n        return false\n      }\n    }\n\n    if ('touches' in e) {\n      const touch = e.changedTouches[0]\n      if (this.activePointer && this.activePointer !== touch.identifier) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  touchStart<T extends string>(e: TouchEvent | React.TouchEvent, target: T): TLPointerInfo<T> {\n    const { shiftKey, ctrlKey, metaKey, altKey } = e\n\n    const touch = e.changedTouches[0]\n\n    this.activePointer = touch.identifier\n\n    const info: TLPointerInfo<T> = {\n      target,\n      pointerId: touch.identifier,\n      origin: Inputs.getPoint(touch, this.bounds),\n      delta: [0, 0],\n      point: Inputs.getPoint(touch, this.bounds),\n      pressure: Inputs.getPressure(touch),\n      shiftKey,\n      ctrlKey,\n      metaKey: Utils.isDarwin() ? metaKey : ctrlKey,\n      altKey,\n      spaceKey: this.keys[' '],\n    }\n\n    this.pointer = info\n\n    return info\n  }\n\n  touchEnd<T extends string>(e: TouchEvent | React.TouchEvent, target: T): TLPointerInfo<T> {\n    const { shiftKey, ctrlKey, metaKey, altKey } = e\n\n    const touch = e.changedTouches[0]\n\n    const info: TLPointerInfo<T> = {\n      target,\n      pointerId: touch.identifier,\n      origin: Inputs.getPoint(touch, this.bounds),\n      delta: [0, 0],\n      point: Inputs.getPoint(touch, this.bounds),\n      pressure: Inputs.getPressure(touch),\n      shiftKey,\n      ctrlKey,\n      metaKey: Utils.isDarwin() ? metaKey : ctrlKey,\n      altKey,\n      spaceKey: this.keys[' '],\n    }\n\n    this.pointer = info\n\n    this.activePointer = undefined\n\n    return info\n  }\n\n  touchMove<T extends string>(e: TouchEvent | React.TouchEvent, target: T): TLPointerInfo<T> {\n    const { shiftKey, ctrlKey, metaKey, altKey } = e\n\n    const touch = e.changedTouches[0]\n\n    const prev = this.pointer\n\n    const point = Inputs.getPoint(touch, this.bounds)\n\n    const delta = prev?.point ? Vec.sub(point, prev.point) : [0, 0]\n\n    const info: TLPointerInfo<T> = {\n      origin: point,\n      ...prev,\n      target,\n      pointerId: touch.identifier,\n      point,\n      delta,\n      pressure: Inputs.getPressure(touch),\n      shiftKey,\n      ctrlKey,\n      metaKey: Utils.isDarwin() ? metaKey : ctrlKey,\n      altKey,\n      spaceKey: this.keys[' '],\n    }\n\n    this.pointer = info\n\n    return info\n  }\n\n  pointerDown<T extends string>(e: PointerEvent | React.PointerEvent, target: T): TLPointerInfo<T> {\n    const { shiftKey, ctrlKey, metaKey, altKey } = e\n\n    const point = Inputs.getPoint(e, this.bounds)\n\n    this.activePointer = e.pointerId\n\n    const info: TLPointerInfo<T> = {\n      target,\n      pointerId: e.pointerId,\n      origin: point,\n      point: point,\n      delta: [0, 0],\n      pressure: Inputs.getPressure(e),\n      shiftKey,\n      ctrlKey,\n      metaKey: Utils.isDarwin() ? metaKey : ctrlKey,\n      altKey,\n      spaceKey: this.keys[' '],\n    }\n\n    this.pointer = info\n\n    return info\n  }\n\n  pointerEnter<T extends string>(\n    e: PointerEvent | React.PointerEvent,\n    target: T\n  ): TLPointerInfo<T> {\n    const { shiftKey, ctrlKey, metaKey, altKey } = e\n\n    const point = Inputs.getPoint(e, this.bounds)\n\n    const info: TLPointerInfo<T> = {\n      target,\n      pointerId: e.pointerId,\n      origin: point,\n      delta: [0, 0],\n      point: point,\n      pressure: Inputs.getPressure(e),\n      shiftKey,\n      ctrlKey,\n      metaKey: Utils.isDarwin() ? metaKey : ctrlKey,\n      altKey,\n      spaceKey: this.keys[' '],\n    }\n\n    this.pointer = info\n\n    return info\n  }\n\n  pointerMove<T extends string>(e: PointerEvent | React.PointerEvent, target: T): TLPointerInfo<T> {\n    const { shiftKey, ctrlKey, metaKey, altKey } = e\n\n    const prev = this.pointer\n\n    const point = Inputs.getPoint(e, this.bounds)\n\n    const delta = prev?.point ? Vec.sub(point, prev.point) : [0, 0]\n\n    const info: TLPointerInfo<T> = {\n      origin: point,\n      ...prev,\n      target,\n      pointerId: e.pointerId,\n      point,\n      delta,\n      pressure: Inputs.getPressure(e),\n      shiftKey,\n      ctrlKey,\n      metaKey: Utils.isDarwin() ? metaKey : ctrlKey,\n      altKey,\n      spaceKey: this.keys[' '],\n    }\n\n    this.pointer = info\n\n    return info\n  }\n\n  pointerUp<T extends string>(e: PointerEvent | React.PointerEvent, target: T): TLPointerInfo<T> {\n    const { shiftKey, ctrlKey, metaKey, altKey } = e\n\n    const prev = this.pointer\n\n    const point = Inputs.getPoint(e, this.bounds)\n\n    const delta = prev?.point ? Vec.sub(point, prev.point) : [0, 0]\n\n    this.activePointer = undefined\n\n    const info: TLPointerInfo<T> = {\n      origin: point,\n      ...prev,\n      target,\n      pointerId: e.pointerId,\n      point,\n      delta,\n      pressure: Inputs.getPressure(e),\n      shiftKey,\n      ctrlKey,\n      metaKey: Utils.isDarwin() ? metaKey : ctrlKey,\n      altKey,\n      spaceKey: this.keys[' '],\n    }\n\n    this.pointer = info\n\n    this.pointerUpTime = performance.now()\n\n    return info\n  }\n\n  panStart = (e: WheelEvent): TLPointerInfo<'wheel'> => {\n    const { shiftKey, ctrlKey, metaKey, altKey } = e\n\n    const info: TLPointerInfo<'wheel'> = {\n      target: 'wheel',\n      pointerId: this.pointer?.pointerId || 0,\n      origin: this.pointer?.origin || [0, 0],\n      delta: [0, 0],\n      pressure: 0.5,\n      point: Inputs.getPoint(e, this.bounds),\n      shiftKey,\n      ctrlKey,\n      metaKey,\n      altKey,\n      spaceKey: this.keys[' '],\n    }\n\n    this.pointer = info\n\n    return info\n  }\n\n  pan = (delta: number[], e: WheelEvent): TLPointerInfo<'wheel'> => {\n    if (!this.pointer || this.pointer.target !== 'wheel') {\n      return this.panStart(e)\n    }\n\n    const { shiftKey, ctrlKey, metaKey, altKey } = e\n\n    const prev = this.pointer\n\n    const point = Inputs.getPoint(e, this.bounds)\n\n    const info: TLPointerInfo<'wheel'> = {\n      ...prev,\n      target: 'wheel',\n      delta,\n      point,\n      shiftKey,\n      ctrlKey,\n      metaKey,\n      altKey,\n      spaceKey: this.keys[' '],\n    }\n\n    this.pointer = info\n\n    return info\n  }\n\n  isDoubleClick() {\n    if (!this.pointer) return false\n\n    const { origin, point } = this.pointer\n\n    const isDoubleClick =\n      performance.now() - this.pointerUpTime < DOUBLE_CLICK_DURATION && Vec.dist(origin, point) < 4\n\n    // Reset the active pointer, in case it got stuck\n    if (isDoubleClick) this.activePointer = undefined\n\n    return isDoubleClick\n  }\n\n  clear() {\n    this.pointer = undefined\n  }\n\n  resetDoubleClick() {\n    this.pointerUpTime = 0\n  }\n\n  keydown = (e: KeyboardEvent | React.KeyboardEvent): TLKeyboardInfo => {\n    const { shiftKey, ctrlKey, metaKey, altKey } = e\n\n    this.keys[e.key] = true\n\n    return {\n      point: this.pointer?.point || [0, 0],\n      origin: this.pointer?.origin || [0, 0],\n      key: e.key,\n      keys: Object.keys(this.keys),\n      shiftKey,\n      ctrlKey,\n      metaKey: Utils.isDarwin() ? metaKey : ctrlKey,\n      altKey,\n    }\n  }\n\n  keyup = (e: KeyboardEvent | React.KeyboardEvent): TLKeyboardInfo => {\n    const { shiftKey, ctrlKey, metaKey, altKey } = e\n\n    delete this.keys[e.key]\n\n    return {\n      point: this.pointer?.point || [0, 0],\n      origin: this.pointer?.origin || [0, 0],\n      key: e.key,\n      keys: Object.keys(this.keys),\n      shiftKey,\n      ctrlKey,\n      metaKey: Utils.isDarwin() ? metaKey : ctrlKey,\n      altKey,\n    }\n  }\n\n  pinch(point: number[], origin: number[]) {\n    const { shiftKey, ctrlKey, metaKey, altKey } = this.keys\n\n    const delta = Vec.sub(origin, point)\n\n    const info: TLPointerInfo<'pinch'> = {\n      pointerId: 0,\n      target: 'pinch',\n      origin,\n      delta: delta,\n      point: Vec.sub(Vec.toFixed(point), [this.bounds.minX, this.bounds.minY]),\n      pressure: 0.5,\n      shiftKey,\n      ctrlKey,\n      metaKey: Utils.isDarwin() ? metaKey : ctrlKey,\n      altKey,\n      spaceKey: this.keys[' '],\n    }\n\n    this.pointer = info\n\n    return info\n  }\n\n  reset() {\n    this.pointerUpTime = 0\n    this.pointer = undefined\n    this.keyboard = undefined\n    this.activePointer = undefined\n    this.keys = {}\n  }\n\n  static getPoint(\n    e: PointerEvent | React.PointerEvent | Touch | React.Touch | WheelEvent,\n    bounds: TLBounds\n  ): number[] {\n    return [+e.clientX.toFixed(2) - bounds.minX, +e.clientY.toFixed(2) - bounds.minY]\n  }\n\n  static getPressure(e: PointerEvent | React.PointerEvent | Touch | React.Touch | WheelEvent) {\n    return 'pressure' in e ? +e.pressure.toFixed(2) || 0.5 : 0.5\n  }\n\n  static commandKey(): string {\n    return Utils.isDarwin() ? '\u2318' : 'Ctrl'\n  }\n}\n\nexport const inputs = new Inputs()\n", "import * as React from 'react'\n\ninterface HTMLContainerProps extends React.HTMLProps<HTMLDivElement> {\n  children: React.ReactNode\n}\n\nexport const HTMLContainer = React.memo(\n  React.forwardRef<HTMLDivElement, HTMLContainerProps>(function HTMLContainer(\n    { children, className = '', ...rest },\n    ref\n  ) {\n    return (\n      <div ref={ref} className={`tl-positioned-div ${className}`} draggable={false} {...rest}>\n        <div className=\"tl-inner-div\">{children}</div>\n      </div>\n    )\n  })\n)\n", "import { intersectPolygonBounds } from '@tldraw/intersect'\nimport * as React from 'react'\nimport type { TLBounds, TLComponentProps, TLForwardedRef, TLShape, TLUser } from '~types'\nimport Utils from '~utils'\n\nexport abstract class TLShapeUtil<T extends TLShape, E extends Element = any, M = any> {\n  refMap = new Map<string, React.RefObject<E>>()\n\n  boundsCache = new WeakMap<TLShape, TLBounds>()\n\n  showCloneHandles = false\n\n  hideBounds = false\n\n  isStateful = false\n\n  abstract Component: React.ForwardRefExoticComponent<TLComponentProps<T, E, M>>\n\n  abstract Indicator: (props: {\n    shape: T\n    meta: M\n    user?: TLUser\n    bounds: TLBounds\n    isHovered: boolean\n    isSelected: boolean\n  }) => React.ReactElement | null\n\n  abstract getBounds: (shape: T) => TLBounds\n\n  shouldRender = (prev: T, next: T): boolean => true\n\n  getRef = (shape: T): React.RefObject<E> => {\n    if (!this.refMap.has(shape.id)) {\n      this.refMap.set(shape.id, React.createRef<E>())\n    }\n    return this.refMap.get(shape.id)!\n  }\n\n  hitTestBounds = (shape: T, bounds: TLBounds) => {\n    const shapeBounds = this.getBounds(shape)\n    const corners = Utils.getRotatedCorners(shapeBounds, shape.rotation)\n    return (\n      corners.every((point) => Utils.pointInBounds(point, bounds)) ||\n      intersectPolygonBounds(corners, bounds).length > 0\n    )\n  }\n\n  getRotatedBounds: (shape: T) => TLBounds = (shape) => {\n    return Utils.getBoundsFromPoints(Utils.getRotatedCorners(this.getBounds(shape), shape.rotation))\n  }\n\n  /* --------------------- Static --------------------- */\n\n  static Component = <T extends TLShape, E extends Element = any, M = any>(\n    component: (props: TLComponentProps<T, E, M>, ref: TLForwardedRef<E>) => React.ReactElement\n  ) => {\n    return React.forwardRef(component)\n  }\n\n  static Indicator = <T extends TLShape, M = any>(\n    component: (props: {\n      shape: T\n      meta: M\n      isHovered: boolean\n      isSelected: boolean\n      bounds: TLBounds\n    }) => React.ReactElement\n  ) => component\n}\n"],
  "mappings": "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",
  "names": []
}
